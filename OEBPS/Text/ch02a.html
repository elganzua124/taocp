<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$","$"]],
        displayMath: [["$$","$$"]],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  <title></title>
  <link href="../Styles/caps.css" rel="stylesheet" type="text/css">
</head>
<body><p class="ex-title"><a id="page_297"></a>Exercises</p>
<p class="exercises"><strong><a id="ch02ex_2_5_1" href="../Text/app01a.html#ch02ex_2_5_1a">1</a>.</strong> [<em>21</em>] Give specifications for the insertion and deletion of information at the left end of a doubly linked list represented as in (<a href="../Text/ch02.html#ch02eq-lev2sec5-1">1</a>). (With the dual operations at the right end, which are obtained by symmetry, we therefore have all the actions of a general deque.)</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_5_2" href="../Text/app01a.html#ch02ex_2_5_2a">2</a>.</strong> [<em>22</em>] Explain why a list that is singly linked cannot allow efficient operation as a general deque; the deletion of items can be done efficiently at only one end of a singly linked list.</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_5_3" href="../Text/app01a.html#ch02ex_2_5_3a">3</a>.</strong> [<em>22</em>] The elevator system described in the text uses three call variables, <code>CALLUP</code>, <code>CALLCAR</code>, and <code>CALLDOWN</code>, for each floor, representing buttons that have been pushed by the users in the system. It is conceivable that the elevator actually needs only one or two binary variables for the call buttons on each floor, instead of three. Explain how an experimenter could push buttons in a certain sequence with this elevator system to <em>prove</em> that there are three independent binary variables for each floor (except the top and bottom floors).</p>
<p class="exercises"><strong><a id="ch02ex_2_5_4" href="../Text/app01a.html#ch02ex_2_5_4a">4</a>.</strong> [<em>24</em>] Activity E9 in the elevator coroutine is usually canceled by step E6; and even when it hasn’t been canceled, it doesn’t do very much. Explain under what circumstances the elevator would behave differently if activity E9 were deleted from the system. Would it, for example, sometimes visit floors in a different order?</p>
<p class="exercises"><strong><a id="ch02ex_2_5_5" href="../Text/app01a.html#ch02ex_2_5_5a">5</a>.</strong> [<em>20</em>] In <a href="../Text/ch02.html#ch02tab01">Table 1</a>, user 10 arrived on floor 0 at time 1048. Show that if user 10 had arrived on floor 2 instead of floor 0, the elevator would have gone <em>up</em> after receiving its passengers on floor 1, instead of down, in spite of the fact that user 8 wants to go down to floor 0.</p>
<p class="exercises"><strong><a id="ch02ex_2_5_6" href="../Text/app01a.html#ch02ex_2_5_6a">6</a>.</strong> [<em>23</em>] During the time period 1183–1233 in <a href="../Text/ch02.html#ch02tab01">Table 1</a>, users 7, 8, and 9 all get in the elevator on floor 1; then the elevator goes down to floor 0 and only user 8 gets out. Now the elevator stops again on floor 1, presumably to pick up users 7 and 9 who are already aboard; nobody is actually on floor 1 waiting to get in. (This situation occurs not infrequently at Caltech; if you get on the elevator going the wrong way, you must wait for an extra stop as you go by your original floor again.) In many elevator systems, users 7 and 9 would not have boarded the elevator at time 1183, since lights outside the elevator would show that it was going down, not up; those users would have waited until the elevator came back up and stopped for them. On the system described, there are no such lights and it is impossible to tell which way the elevator is going to go until you are in it; hence <a href="../Text/ch02.html#ch02tab01">Table 1</a> reflects the actual situation.</p>
<p class="indent">What changes should be made to coroutines U and E if we were to simulate the same elevator system, but with indicator lights, so that people do not get on the elevator when its state is contrary to their desired direction?</p>
<p class="exercises"><strong><a id="ch02ex_2_5_7" href="../Text/app01a.html#ch02ex_2_5_7a">7</a>.</strong> [<em>25</em>] Although bugs in programs are often embarrassing to a programmer, if we are to learn from our mistakes we should record them and tell other people about them instead of forgetting them. The following error (among others) was made by the author when he first wrote the program in this section: Line 154 said ‘<code>JANZ CYCLE</code>’ instead of ‘<code>JANZ U4A</code>’. The reasoning was that if indeed the elevator had arrived at this user’s floor, there was no need to perform the “give up” activity U4 any more, so we could simply go to <code>CYCLE</code> and continue simulating other activities. What was the error?</p>
<p class="exercises"><strong><a id="ch02ex_2_5_8" href="../Text/app01a.html#ch02ex_2_5_8a">8</a>.</strong> [<em>21</em>] Write the code for step E8, lines 277–292, which has been omitted from the program in the text.</p>
<p class="exercises"><a id="page_298"></a><strong><a id="ch02ex_2_5_9" href="../Text/app01a.html#ch02ex_2_5_9a">9</a>.</strong> [<em>23</em>] Write the code for the <code>DECISION</code> subroutine, which has been omitted from the program in the text.</p>
<p class="exercises1"><strong><a id="ch02ex_2_5_10"></a>10.</strong> [<em>40</em>] It is perhaps significant to note that although the author had used the elevator system for years and thought he knew it well, it wasn’t until he attempted to write this section that he realized there were quite a few facts about the elevator’s system of choosing directions that he did not know. He went back to experiment with the elevator six separate times, each time believing he had finally achieved a complete understanding of its <em>modus operandi</em>. (Now he is reluctant to ride it for fear that some new facet of its operation will appear, contradicting the algorithms given.) We often fail to realize how little we know about a thing until we attempt to simulate it on a computer.</p>
<p class="exercises1N">Try to specify the actions of some elevator you are familiar with. Check the algorithm by experiments with the elevator itself (looking at its circuitry is not fair!); then design a discrete simulator for the system and run it on a computer.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_5_11" href="../Text/app01a.html#ch02ex_2_5_11a">11</a>.</strong> [<em>21</em>] (<em>A sparse-update memory.</em>) The following problem often arises in <em>synchronous</em> simulations: The system has <em>n</em> variables <code>V[1]</code>, ..., <code>V[</code><em>n</em><code>]</code>, and at every simulated step new values for some of them are calculated from the old values. These calculations are assumed done “simultaneously” in the sense that the variables do not change to their new values until after all assignments have been made. Thus, the two statements</p>
<p class="center"><code>V[1]</code> ← <code>V[2]</code>&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;<code>V[2]</code> ← <code>V[1]</code></p>
<p class="exercisesp">appearing at the same simulated time would interchange the values of <code>V[1]</code> and <code>V[2]</code>; this is quite different from what would happen in a sequential calculation.</p>
<p class="exercises1N">The desired action can of course be simulated by keeping an additional table <code>NEWV[</code>1<code>]</code>, ..., <code>NEWV[</code><em>n</em><code>]</code>. Before each simulated step, we could set <code>NEWV[</code><em>k</em><code>]</code> ← <code>V[</code><em>k</em><code>]</code> for 1 ≤ <em>k</em> ≤ <em>n</em>, then record all changes of <code>V[</code><em>k</em><code>]</code> in <code>NEWV[</code><em>k</em><code>]</code>, and finally, after the step we could set <code>V[</code><em>k</em><code>]</code> ← <code>NEWV[</code><em>k</em><code>]</code>, 1 ≤ <em>k</em> ≤ <em>n</em>. But this “brute force” approach is not completely satisfactory, for the following reasons: (<a href="../Text/ch02.html#ch02eq-lev2sec5-1">1</a>) Often <em>n</em> is very large, but the number of variables changed per step is rather small. (<a href="../Text/ch02.html#ch02eq-lev2sec5-2">2</a>) The variables are often not arranged in a nice table <code>V[</code>1<code>]</code><em>, ...,</em> <code>V[</code><em>n</em><code>]</code>, but are scattered throughout memory in a rather chaotic fashion. (<a href="../Text/ch02.html#ch02eq-lev2sec5-3">3</a>) This method does not detect the situation (usually an error in the model) when one variable is given two values in the same simulated step.</p>
<p class="exercises1N">Assuming that the number of variables changed per step is rather small, design an efficient algorithm that simulates the desired actions, using two auxiliary tables <code>NEWV[</code><em>k</em><code>]</code> and <code>LINK[</code><em>k</em><code>]</code>, 1 ≤ <em>k</em> ≤ <em>n</em>. If possible, your algorithm should give an error stop if the same variable is being given two different values in the same step.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_5_12" href="../Text/app01a.html#ch02ex_2_5_12a">12</a>.</strong> [<em>22</em>] Why is it a good idea to use doubly linked lists instead of singly linked or sequential lists in the simulation program of this section?</p>
<div class="heading">
<h4 id="ch02lev2sec6">2.2.6. Arrays and Orthogonal Lists</h4>
<p class="noindent">One of the simplest generalizations of a linear list is a two-dimensional or higher-dimensional array of information. For example, consider the case of an <em>m</em> × <em>n</em> matrix</p>
</div>
<div class="equation"><a id="ch02eq-lev2sec6-1"></a><img src="../Images/ch02/298equ01.jpg"></div>
<p class="noindent"><a id="page_299"></a>In this two-dimensional array, each node <code>A[</code><em>j,k</em><code>]</code> belongs to two linear lists: the “row <em>j</em>” list <code>A[</code><em>j</em>,1<code>]</code>, <code>A[</code><em>j</em>,2<code>]</code>, ..., <code>A[</code><em>j</em>,<em>n</em><code>]</code> and the “column <em>k</em>” list <code>A[</code>1,<em>k</em><code>]</code>, <code>A[2</code>,<em>k</em><code>]</code>, ..., <code>A[</code><em>m</em>,<em>k</em><code>]</code>. These orthogonal row and column lists essentially account for the two-dimensional structure of a matrix. Similar remarks apply to higherdimensional arrays of information.</p>
<p class="noindent"><strong>Sequential Allocation.</strong> When an array like (<a href="../Text/ch02a.html#ch02eq-lev2sec6-1">1</a>) is stored in <em>sequential</em> memory locations, storage is usually allocated so that</p>
<div class="equation"><a id="ch02eq-lev2sec6-2"></a><img src="../Images/ch02/299equ01.jpg"></div>
<p class="noindent">where <em>a</em><sub>0</sub>, <em>a</em><sub>1</sub>, and <em>a</em><sub>2</sub> are constants. Let us consider a more general case: Suppose we have a four-dimensional array with one-word elements <code>Q[I,J,K,L]</code> for 0 ≤ <code>I</code> ≤ 2, 0 ≤ <code>J</code> ≤ 4, 0 ≤ <code>K</code> ≤ 10, 0 ≤ <code>L</code> ≤ 2. We would like to allocate storage so that</p>
<div class="equation"><a id="ch02eq-lev2sec6-3"></a><img src="../Images/ch02/299equ02.jpg"></div>
<p class="noindent">This means that a change in <code>I</code>, <code>J</code>, <code>K</code>, or <code>L</code> leads to a readily calculated change in the location of <code>Q[I,J,K,L]</code>. The most natural (and most commonly used) way to allocate storage is to arrange the array elements according to the lexicographic order of their indices (<a href="../Text/ch01.html#ch01ex_2_1_15">exercise 1.2.1–15</a>(d)), sometimes called “row major order”:</p>
<div class="equation"><img src="../Images/ch02/299equ03a.jpg"></div>
<p class="noindent">It is easy to see that this order satisfies the requirements of (<a href="../Text/ch02a.html#ch02eq-lev2sec6-3">3</a>), and we have</p>
<div class="equation"><a id="ch02eq-lev2sec6-4"></a><img src="../Images/ch02/299equ03.jpg"></div>
<p class="noindent">In general, given a <em>k</em>-dimensional array with <em>c</em>-word elements <code>A[I</code><sub>1</sub><code>,I</code><sub>2</sub>, ... <code>,I</code><sub><em>k</em></sub><code>]</code> for</p>
<p class="center">0 ≤ <code>I</code><sub>1</sub> ≤ <em>d</em><sub>1</sub><em>,</em> 0 ≤ <code>I</code><sub>2</sub> ≤ <em>d</em><sub>2</sub><em>,&nbsp;&nbsp;&nbsp;...,</em>&nbsp;&nbsp;&nbsp;0 ≤ <code>I</code><sub><em>k</em></sub> ≤ <em>d</em><sub><em>k</em></sub><em>,</em></p>
<p class="noindent">we can store it in memory as</p>
<div class="equation"><a id="ch02eq-lev2sec6-5"></a><img src="../Images/ch02/299equ04.jpg"></div>
<p class="noindent">where</p>
<div class="equation"><a id="ch02eq-lev2sec6-6"></a><img src="../Images/ch02/299equ05.jpg"></div>
<p class="noindent">To see why this formula works, observe that <em>a</em><sub><em>r</em></sub> is the amount of memory needed to store the subarray <code>A[I</code><sub>1</sub>, ...,<code>I</code><sub><em>r</em></sub>,<code>J</code><sub><em>r</em>+1</sub>, ...,<code>J</code><sub><em>k</em></sub><code>]</code> if <code>I</code><sub>1</sub><em>, ...,</em> <code>I</code><sub><em>r</em></sub> are constant and <code>J</code><sub><em>r</em>+1</sub><em>, ...,</em> <code>J</code><sub><em>k</em></sub> vary through all values 0 ≤ <code>J</code><sub><em>r</em>+1</sub> ≤ <em>d</em><sub><em>r</em>+1</sub>, ..., 0 ≤ <code>J</code><sub><em>k</em></sub> ≤ <em>d</em><sub><em>k</em></sub>; hence by the nature of lexicographic order the address of <code>A[I</code><sub>1</sub>, ...,<code>I</code><sub><em>k</em></sub><code>]</code> should change by precisely this amount when <code>I</code><sub><em>r</em></sub> changes by 1.</p>
<p class="indent"><a id="page_300"></a>Formulas (<a href="../Text/ch02a.html#ch02eq-lev2sec6-5">5</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec6-6">6</a>) correspond to the value of the number <code>I</code><sub>1</sub><code>I</code><sub>2</sub> ... <code>I</code><sub><em>k</em></sub> in a mixed-radix number system. For example, if we had the array <code>TIME[W,D,H,M,S]</code> with 0 ≤ <code>W</code> &lt; 4, 0 ≤ <code>D</code> &lt; 7, 0 ≤ <code>H</code> &lt; 24, 0 ≤ <code>M</code> &lt; 60, and 0 ≤ <code>S</code> &lt; 60, the location of <code>TIME[W,D,H,M,S]</code> would be the location of <code>TIME[0,0,0,0,0]</code> plus the quantity “<code>W</code> weeks + <code>D</code> days + <code>H</code> hours + <code>M</code> minutes + <code>S</code> seconds” converted to seconds. Of course, it takes a pretty fancy application to make use of an array that has 2,419,200 elements.</p>
<p class="indent">The normal method for storing arrays is generally suitable when the array has a complete rectangular structure, so that all elements <code>A[I</code><sub>1</sub>,<code>I</code><sub>2</sub>, ...,<code>I</code><sub><em>k</em></sub><code>]</code> are present for indices in the independent ranges <em>l</em><sub>1</sub> ≤ <code>I</code><sub>1</sub> ≤ <em>u</em><sub>1</sub>, <em>l</em><sub>2</sub> ≤ <code>I</code><sub>2</sub> ≤ <em>u</em><sub>2</sub>, ..., <em>l</em><sub><em>k</em></sub> ≤ <code>I</code><sub><em>k</em></sub> ≤ <em>u</em><sub><em>k</em></sub> . <a href="../Text/ch02a.html#ch02ex_2_6_2">Exercise 2</a> shows how to adapt (<a href="../Text/ch02a.html#ch02eq-lev2sec6-5">5</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec6-6">6</a>) to the case when the lower bounds (<em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, ..., <em>l</em><sub><em>k</em></sub>) are not (0, 0, ..., 0).</p>
<p class="indent">But there are many situations in which an array is not perfectly rectangular. Most common is the <em>triangular matrix</em>, where we want to store only the entries <code>A[</code><em>j,k</em><code>]</code> for, say, 0 ≤ <em>k</em> ≤ <em>j</em> ≤ <em>n</em>:</p>
<div class="equation"><a id="ch02eq-lev2sec6-7"></a><img src="../Images/ch02/300equ01.jpg"></div>
<p class="noindent">We may know that all other entries are zero, or that <code>A[</code><em>j</em>,<em>k</em><code>]</code> = <code>A[</code><em>k</em>,<em>j</em><code>]</code>, so that only half of the values need to be stored. If we want to store the lower triangular matrix (<a href="../Text/ch02a.html#ch02eq-lev2sec6-7">7</a>) in <span class="middle"><img src="../Images/ch02/1by2.jpg"></span>(<em>n</em> + 1)(<em>n</em> + 2) consecutive memory positions, we are forced to give up the possibility of linear allocation as in Eq. (<a href="../Text/ch02a.html#ch02eq-lev2sec6-2">2</a>), but we can ask instead for an allocation arrangement of the form</p>
<div class="equation"><a id="ch02eq-lev2sec6-8"></a><img src="../Images/ch02/300equ02.jpg"></div>
<p class="noindent">where <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> are functions of one variable. (The constant <em>a</em><sub>0</sub> may be absorbed into either <em>f</em><sub>1</sub> or <em>f</em><sub>2</sub> if desired.) When the addressing has the form (<a href="../Text/ch02a.html#ch02eq-lev2sec6-8">8</a>), a random element <code>A[</code><em>j</em>,<em>k</em><code>]</code> can be quickly accessed if we keep two (rather short) auxiliary tables of the values of <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub>; therefore these functions need to be calculated only once.</p>
<p class="indent">It turns out that lexicographic order of indices for the array (<a href="../Text/ch02a.html#ch02eq-lev2sec6-7">7</a>) satisfies condition (<a href="../Text/ch02a.html#ch02eq-lev2sec6-8">8</a>), and with one-word entries we have in fact the simple formula</p>
<div class="equation"><a id="ch02eq-lev2sec6-9"></a><img src="../Images/ch02/300equ03.jpg"></div>
<p class="indent">But there is actually a far better way to store triangular matrices, if we are fortunate enough to have two of them with the same size. Suppose that we want to store both <code>A[</code><em>j,k</em><code>]</code> and <code>B[</code><em>j,k</em><code>]</code> for 0 ≤ <em>k</em> ≤ <em>j</em> ≤ <em>n</em>. Then we can fit them both into a single matrix <code>C[</code><em>j</em>,<em>k</em><code>]</code> for 0 ≤ <em>j</em> ≤ <em>n</em>, 0 ≤ <em>k</em> ≤ <em>n</em> + 1, using the convention</p>
<div class="equation"><a id="ch02eq-lev2sec6-10"></a><img src="../Images/ch02/300equ04.jpg"></div>
<p class="noindent"><a id="page_301"></a>Thus</p>
<div class="image"><img src="../Images/ch02/e301_01.jpg"></div>
<p class="noindent">The two triangular matrices are packed together tightly within the space of (<em>n</em> + 1)(<em>n</em> + 2) locations, and we have linear addressing as in (<a href="../Text/ch02a.html#ch02eq-lev2sec6-2">2</a>).</p>
<p class="indent">The generalization of triangular matrices to higher dimensions is called a <em>tetrahedral array</em>. This interesting topic is the subject of <a href="../Text/ch02a.html#ch02ex_2_6_6">exercises 6</a> through <a href="../Text/ch02a.html#ch02ex_2_6_8">8</a>.</p>
<p class="indent">As an example of typical programming techniques for use with sequentially stored arrays, see <a href="../Text/ch01b.html#ch01ex_2_13_10">exercise 1.3.2–10</a> and the two answers given for that exercise. The fundamental techniques for efficient traversal of rows and columns, as well as the uses of sequential stacks, are of particular interest within those programs.</p>
<p class="noindent"><strong>Linked Allocation.</strong> Linked memory allocation also applies to higher-dimensional arrays of information in a natural way. In general, our nodes can contain <em>k</em> link fields, one for each list the node belongs to. The use of linked memory is generally for cases in which the arrays are not strictly rectangular in character.</p>
<p class="indent">As an example, we might have a list in which every node represents a person, with four link fields: <code>SEX</code>, <code>AGE</code>, <code>EYES</code>, and <code>HAIR</code>. In the <code>EYES</code> field we link together all nodes with the same eye color, etc. (See <a href="../Text/ch02a.html#ch02fig13">Fig. 13</a>.) It is easy to visualize efficient algorithms for inserting new people into the list; deletion would, however, be much slower, unless we used double linking. We can also conceive of algorithms of varying degrees of efficiency for doing things like “Find all blue-eyed blonde women of ages 21 through 23”; see <a href="../Text/ch02a.html#ch02ex_2_6_9">exercises 9</a> and <a href="../Text/ch02a.html#ch02ex_2_6_10">10</a>. Problems in which each node of a list is to reside in several kinds of other lists at once arise rather frequently; indeed, the elevator system simulation described in the preceding section has nodes that are in both the <code>QUEUE</code> and <code>WAIT</code> lists simultaneously.</p>
<div class="image"><a id="ch02fig13"></a><img src="../Images/ch02/02fig13.jpg"><p class="fig-caption"><strong>Fig. 13.</strong> Each node in four different lists.</p></div>
<p class="indent"><a id="page_302"></a>As a detailed example of the use of linked allocation for orthogonal lists, we will consider the case of <em>sparse matrices</em> (that is, matrices of large order in which most of the elements are zero). The goal is to operate on these matrices as though the entire matrix were present, but to save great amounts of time and space because the zero entries need not be represented. One way to do this, intended for random references to elements of the matrix, would be to use the storage and retrieval methods of Chapter 6, to find <code>A[</code><em>j</em>,<em>k</em><code>]</code> from the key “<code>[</code><em>j, k</em><code>]</code>”; however, there is another way to deal with sparse matrices that is often preferable because it reflects the matrix structure more appropriately, and this is the method we will discuss here.</p>
<p class="indent">The representation we will discuss consists of circularly linked lists for each row and column. Every node of the matrix contains three words and five fields:</p>
<div class="equation"><a id="ch02eq-lev2sec6-11"></a><img src="../Images/ch02/302equ01.jpg"></div>
<p class="noindent">Here <code>ROW</code> and <code>COL</code> are the row and column indices of the node; <code>VAL</code> is the value stored at that part of the matrix; <code>LEFT</code> and <code>UP</code> are links to the next nonzero entry to the left in the row, or upward in the column, respectively. There are special list head nodes, <code>BASEROW[</code><em>i</em><code>]</code> and <code>BASECOL[</code><em>j</em><code>]</code>, for every row and column. These nodes are identified by</p>
<p class="center"><code>COL(LOC(BASEROW[</code><em>i</em><code>]))</code> &lt; 0&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;<code>ROW(LOC(BASECOL[</code><em>j</em><code>]))</code> &lt; 0.</p>
<p class="noindent">As usual in a circular list, the <code>LEFT</code> link in <code>BASEROW[</code><em>i</em><code>]</code> is the location of the rightmost value in that row, and <code>UP</code> in <code>BASECOL[</code><em>j</em><code>]</code> points to the bottom-most value in that column. For example, the matrix</p>
<div class="equation"><a id="ch02eq-lev2sec6-12"></a><img src="../Images/ch02/302equ02.jpg"></div>
<p class="noindent">would be represented as shown in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>.</p>
<div class="image"><a id="ch02fig14"></a><img src="../Images/ch02/02fig14.jpg"><p class="fig-caption"><strong>Fig. 14.</strong> Representation of matrix (<a href="../Text/ch02a.html#ch02eq-lev2sec6-12">12</a>), with nodes in the format <span class="middle"><img src="../Images/ch02/e303_01.jpg"></span>. List heads appear at the left and at the top.</p></div>
<p class="indent">Using sequential allocation of storage, a 200 × 200 matrix would take 40000 words, and this is more memory than many computers used to have; but a suitably sparse 200 × 200 matrix can be represented as above even in <code>MIX</code>’s 4000-word memory. (See <a href="../Text/ch02a.html#ch02ex_2_6_11">exercise 11</a>.) The amount of time taken to access a random element <code>A[</code><em>j</em>,<em>k</em><code>]</code> is also quite reasonable, <em>if</em> there are but few elements in each row or column; and since most matrix algorithms proceed by walking sequentially through a matrix, instead of accessing elements at random, this linked representation often works faster than a sequential one.</p>
<p class="indent">As a typical example of a nontrivial algorithm dealing with sparse matrices in this form, we will consider the <em>pivot step</em> operation, which is an important part of algorithms for solving linear equations, for inverting matrices, and for solving <a id="page_303"></a>linear programming problems by the simplex method. A pivot step is the following matrix transformation (see M. H. Doolittle, <em>Report of the Superintendent of the U.S. Coast and Geodetic Survey</em> (1878), 115–120):</p>
<div class="equation"><a id="ch02eq-lev2sec6-13"></a><img src="../Images/ch02/303equ01.jpg"></div>
<p class="noindent">It is assumed that the <em>pivot element</em>, a, is nonzero. For example, a pivot step applied to matrix (<a href="../Text/ch02a.html#ch02eq-lev2sec6-12">12</a>), with the element 10 in row 2 column 1 as pivot, leads to</p>
<div class="equation"><a id="ch02eq-lev2sec6-14"></a><img src="../Images/ch02/303equ02.jpg"></div>
<p class="indent"><a id="page_304"></a>Our goal is to design an algorithm that performs this pivot operation on sparse matrices that are represented as in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>. It is clear that the transformation (<a href="../Text/ch02a.html#ch02eq-lev2sec6-13">13</a>) affects only those rows of a matrix for which there is a nonzero element in the pivot column, and it affects only those columns for which there is a nonzero entry in the pivot row.</p>
<p class="indent">The pivoting algorithm is in many ways a straightforward application of linking techniques we have already discussed; in particular, it bears strong resemblances to <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm 2.2.4A</a> for addition of polynomials. There are two things, however, that make the problem a little tricky: If in (<a href="../Text/ch02a.html#ch02eq-lev2sec6-13">13</a>) we have <em>b</em> ≠ 0 and <em>c</em> ≠ 0 but <em>d</em> ≠ 0, the sparse matrix representation has no entry for <em>d</em> and we must insert a new entry; and if <em>b</em> ≠ 0, <em>c</em> ≠ 0, <em>d</em> ≠ 0, but <em>d</em> − <em>bc</em>/<em>a</em> = 0, we must delete the entry that was formerly there. These insertion and deletion operations are more interesting in a two-dimensional array than in the one-dimensional case; to do them we must know what links are affected. Our algorithm processes the matrix rows successively from bottom to top. The efficient ability to insert and delete involves the introduction of a set of pointer variables <code>PTR[</code><em>j</em><code>]</code>, one for each column considered; these variables traverse the columns upwards, giving us the ability to update the proper links in both dimensions.</p>
<p class="noindent"><a id="ch02alg-lev2sec6-S"></a><strong>Algorithm S</strong> (<em>Pivot step in a sparse matrix</em>). Given a matrix represented as in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>, we perform the pivot operation (<a href="../Text/ch02a.html#ch02eq-lev2sec6-13">13</a>). Assume that <code>PIVOT</code> is a link variable pointing to the pivot element. The algorithm makes use of an auxiliary table of link variables <code>PTR[</code><em>j</em><code>]</code>, one for each column of the matrix. The variable <code>ALPHA</code> and the <code>VAL</code> field of each node are assumed to be floating point or rational quantities, while everything else in this algorithm has integer values.</p>
<p class="indenthanging"><strong>S1.</strong> [Initialize.] Set <code>ALPHA</code> ← 1.0<em>/</em><code>VAL(PIVOT)</code>, <code>VAL(PIVOT)</code> ← 1.0, and</p>
<p class="center"><code>I0</code> ← <code>ROW(PIVOT)</code><em>,</em> <code>P0</code> ← <code>LOC(BASEROW[I0])</code>;</p>
<p class="center"><code>J0</code> ← <code>COL(PIVOT)</code><em>,</em> <code>Q0</code> ← <code>LOC(BASECOL[J0])</code>.</p>
<p class="indenthanging"><strong>S2.</strong> [Process pivot row.] Set <code>P0</code> ← <code>LEFT(P0)</code>, <code>J</code> ← <code>COL(P0)</code>. If <code>J</code> &lt; 0, go on to step S3 (the pivot row has been traversed). Otherwise set <code>PTR[J]</code> ← <code>LOC(BASECOL[J])</code> and <code>VAL(P0)</code> ← <code>ALPHA</code> × <code>VAL(P0)</code>, and repeat step S2.</p>
<p class="indenthanging"><strong>S3.</strong> [Find new row.] Set <code>Q0</code> ← <code>UP(Q0)</code>. (The remainder of the algorithm deals successively with each row, from bottom to top, for which there is an entry in the pivot column.) Set <code>I</code> ← <code>ROW(Q0)</code>. If <code>I</code> &lt; 0, the algorithm terminates. If <code>I</code> = <code>I0</code>, repeat step S3 (we have already done the pivot row). Otherwise set <code>P</code> ← <code>LOC(BASEROW[I])</code>, <code>P1</code> ← <code>LEFT(P)</code>. (The pointers <code>P</code> and <code>P1</code> will now proceed across row <code>I</code> from right to left, as <code>P0</code> goes in synchronization across row <code>I0</code>; <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm 2.2.4A</a> is analogous. We have <code>P0</code> = <code>LOC(BASEROW[I0])</code> at this point.)</p>
<p class="indenthanging"><strong>S4.</strong> [Find new column.] Set <code>P0</code> ← <code>LEFT(P0)</code>, <code>J</code> ← <code>COL(P0)</code>. If <code>J</code> &lt; 0, set <code>VAL(Q0)</code> ← –<code>ALPHA</code> × <code>VAL(Q0)</code> and return to S3. If <code>J</code> = <code>J0</code>, repeat step S4. (Thus we process the pivot column entry in row <code>I</code> <em>after</em> all other column entries have been processed; the reason is that <code>VAL(Q0)</code> is needed in step S7.)</p>
<p class="indenthanging"><a id="page_305"></a><strong>S5.</strong> [Find <code>I</code>, <code>J</code> element.] If <code>COL(P1)</code> &gt; <code>J</code>, set <code>P</code> ← <code>P1</code>, <code>P1</code> ← <code>LEFT(P)</code>, and repeat step S5. If <code>COL(P1)</code> = <code>J</code>, go to step S7. Otherwise go to step S6 (we need to insert a new element in column <code>J</code> of row <code>I</code>).</p>
<p class="indenthanging"><strong>S6.</strong> [Insert <code>I</code>, <code>J</code> element.] If <code>ROW(UP(PTR[J]))</code> &gt; <code>I</code>, set <code>PTR[J]</code> ← <code>UP(PTR[J])</code>, and repeat step S6. (Otherwise, we will have <code>ROW(UP(PTR[J]))</code> &lt; <code>I</code>; the new element is to be inserted just above <code>NODE(PTR[J])</code> in the vertical dimension, and just left of <code>NODE(P)</code> in the horizontal dimension.) Otherwise set <code>X</code> <span class="ent">⇐</span> <code>AVAIL</code>, <code>VAL(X)</code> ← 0, <code>ROW(X)</code> ← <code>I</code>, <code>COL(X)</code> ← <code>J</code>, <code>LEFT(X)</code> ← <code>P1</code>, <code>UP(X)</code> ← <code>UP(PTR[J])</code>, <code>LEFT(P)</code> ← <code>X</code>, <code>UP(PTR[J])</code> ← <code>X</code>, <code>P1</code> ← <code>X</code>.</p>
<p class="indenthanging"><strong>S7.</strong> [Pivot.] Set <code>VAL(P1)</code> ← <code>VAL(P1)</code> − <code>VAL(Q0)</code> × <code>VAL(P0)</code>. If now <code>VAL(P1)</code> = 0, go to S8. (<em>Note:</em> When floating point arithmetic is being used, this test “<code>VAL(P1)</code> = 0” should be replaced by “|<code>VAL(P1)</code>| &lt; <code>EPSILON</code>” or better yet by the condition “most of the significant figures of <code>VAL(P1)</code> were lost in the subtraction.”) Otherwise, set <code>PTR[J]</code> ← <code>P1</code>, <code>P</code> ← <code>P1</code>, <code>P1</code> ← <code>LEFT(P)</code>, and go back to S4.</p>
<p class="indenthanging"><strong>S8.</strong> [Delete <code>I</code>, <code>J</code> element.] If <code>UP(PTR[J])</code> ≠ <code>P1</code> (or, what is essentially the same thing, if <code>ROW(UP(PTR[J])</code>) &gt; <code>I</code>), set <code>PTR[J]</code> ← <code>UP(PTR[J])</code> and repeat step S8; otherwise, set <code>UP(PTR[J])</code> ← <code>UP(P1)</code>, <code>LEFT(P)</code> ← <code>LEFT(P1)</code>, <code>AVAIL</code> <span class="ent">⇐</span> <code>P1</code>, <code>P1</code> ← <code>LEFT(P)</code>. Go back to S4. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">The programming of this algorithm is left as a very instructive exercise for the reader (see <a href="../Text/ch02a.html#ch02ex_2_6_15">exercise 15</a>). It is worth pointing out here that it is necessary to allocate only one word of memory to each of the nodes <code>BASEROW[</code><em>i</em><code>]</code>, <code>BASECOL[</code><em>j</em><code>]</code>, since most of their fields are irrelevant. (See the shaded areas in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>, and see the program of <a href="../Text/ch02.html#ch02lev2sec5">Section 2.2.5</a>.) Furthermore, the value −<code>PTR[</code><em>j</em><code>]</code> can be stored as <code>ROW(LOC(BASECOL[</code><em>j</em><code>]))</code> for additional storage space economy. The running time of <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> is very roughly proportional to the number of matrix elements affected by the pivot operation.</p>
<p class="indent">This representation of sparse matrices via orthogonal circular lists is instructive, but numerical analysts have developed better methods. See Fred G. Gustavson, <em>ACM Trans. on Math. Software</em> <strong>4</strong> (1978), 250–269; see also the graph and network algorithms in Chapter 7 (for example, Algorithm 7B).</p>
<p class="ex-title">Exercises</p>
<p class="exercises"><strong><a id="ch02ex_2_6_1" href="../Text/app01a.html#ch02ex_2_6_1a">1</a>.</strong> [<em>17</em>] Give a formula for <code>LOC(A[J,K])</code> if A is the matrix of (<a href="../Text/ch02a.html#ch02eq-lev2sec6-1">1</a>), and if each node of the array is two words long, assuming that the nodes are stored consecutively in lexicographic order of the indices.</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_2" href="../Text/app01a.html#ch02ex_2_6_2a">2</a>.</strong> [<em>21</em>] Formulas (<a href="../Text/ch02a.html#ch02eq-lev2sec6-5">5</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec6-6">6</a>) have been derived from the assumption that 0 ≤ <code>I</code><sub><em>r</em></sub> ≤ <em>d</em><sub><em>r</em></sub> for 1 ≤ <em>r</em> ≤ <em>k</em>. Give a general formula that applies to the case <em>l</em><sub><em>r</em></sub> ≤ <code>I</code><sub><em>r</em></sub> ≤ <em>u</em><sub><em>r</em></sub>, where <em>l</em><sub><em>r</em></sub> and <em>u</em><sub><em>r</em></sub> are any lower and upper bounds on the dimensionality.</p>
<p class="exercises"><strong><a id="ch02ex_2_6_3" href="../Text/app01a.html#ch02ex_2_6_3a">3</a>.</strong> [<em>21</em>] The text considers lower triangular matrices <code>A[</code><em>j</em>,<em>k</em><code>]</code> for 0 ≤ <em>k</em> ≤ <em>j</em> ≤ <em>n</em>. How can the discussion of such matrices readily be modified for the case that subscripts start at 1 instead of 0, so that 1 ≤ <em>k</em> ≤ <em>j</em> ≤ <em>n</em>?</p>
<p class="exercises"><strong><a id="ch02ex_2_6_4" href="../Text/app01a.html#ch02ex_2_6_4a">4</a>.</strong> [<em>22</em>] Show that if we store the <em>upper</em> triangular array <code>A[</code><em>j</em>,<em>k</em><code>]</code> for 0 ≤ <em>j</em> ≤ <em>k</em> ≤ <em>n</em> in lexicographic order of the indices, the allocation satisfies the condition of Eq. (<a href="../Text/ch02a.html#ch02eq-lev2sec6-8">8</a>). Find a formula for <code>LOC(A[J,K])</code> in this sense.</p>
<p class="exercises"><a id="page_306"></a><strong><a id="ch02ex_2_6_5" href="../Text/app01a.html#ch02ex_2_6_5a">5</a>.</strong> [<em>20</em>] Show that it is possible to bring the value of <code>A[J,K]</code> into register A in one <code>MIX</code> instruction, using the indirect addressing feature of <a href="../Text/ch02.html#ch02ex_2_2_3">exercise 2.2.2–3</a>, even when <code>A</code> is a <em>triangular</em> matrix as in (<a href="../Text/ch02a.html#ch02eq-lev2sec6-9">9</a>). (Assume that the values of <code>J</code> and <code>K</code> are in index registers.)</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_6" href="../Text/app01a.html#ch02ex_2_6_6a">6</a>.</strong> [<em>M24</em>] Consider the “tetrahedral arrays” <code>A[</code><em>i</em>,<em>j</em>,<em>k</em><code>]</code>, <code>B[</code><em>i</em>,<em>j</em>,<em>k</em><code>]</code>, where 0 ≤ <em>k</em> ≤ <em>j</em> ≤ <em>i</em> ≤ <em>n</em> in <code>A</code>, and 0 ≤ <em>i</em> ≤ <em>j</em> ≤ <em>k</em> ≤ <em>n</em> in <code>B</code>. Suppose that both of these arrays are stored in consecutive memory locations in lexicographic order of the indices; show that <code>LOC(A[I,J,K])</code> = <em>a</em><sub>0</sub> + <em>f</em><sub>1</sub> (<code>I)</code> + <em>f</em><sub>2</sub> (<code>J)</code> + <em>f</em><sub>3</sub> (<code>K)</code> for certain functions <em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>, <em>f</em><sub>3</sub>. Can <code>LOC(B[I,J,K])</code> be expressed in a similar manner?</p>
<p class="exercises"><strong><a id="ch02ex_2_6_7" href="../Text/app01a.html#ch02ex_2_6_7a">7</a>.</strong> [<em>M23</em>] Find a general formula to allocate storage for the <em>k</em>-dimensional tetrahedral array <code>A[</code><em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>, ...,<em>i</em><sub><em>k</em></sub><code>]</code>, where 0 ≤ <em>i</em><sub><em>k</em></sub> ≤ · · · ≤ <em>i</em><sub>2</sub> ≤ <em>i</em><sub>1</sub> ≤ <em>n</em>.</p>
<p class="exercises"><strong><a id="ch02ex_2_6_8" href="../Text/app01a.html#ch02ex_2_6_8a">8</a>.</strong> [<em>33</em>] (P. Wegner.) Suppose we have six tetrahedral arrays <code>A[I,J,K]</code>, <code>B[I,J,K]</code>, <code>C[I,J,K]</code>, <code>D[I,J,K]</code>, <code>E[I,J,K]</code>, and <code>F[I,J,K]</code> to store in memory, where 0 ≤ <code>K</code> ≤ <code>J</code> ≤ <code>I</code> ≤ <em>n</em>. Is there a neat way to accomplish this, analogous to (<a href="../Text/ch02a.html#ch02eq-lev2sec6-10">10</a>) in the two-dimensional case?</p>
<p class="exercises"><strong><a id="ch02ex_2_6_9" href="../Text/app01a.html#ch02ex_2_6_9a">9</a>.</strong> [<em>22</em>] Suppose a table, like that indicated in <a href="../Text/ch02a.html#ch02fig13">Fig. 13</a> but much larger, has been set up so that all links go in the same direction as shown there (namely, <code>LINK(X)</code> &lt; <code>X</code> for all nodes and links). Design an algorithm that finds the addresses of all blue-eyed blonde women of ages 21 through 23, by going through the various link fields in such a way that upon completion of the algorithm at most one pass has been made through each of the lists <code>FEMALE</code>, <code>A21</code>, <code>A22</code>, <code>A23</code>, <code>BLOND</code>, and <code>BLUE</code>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_10" href="../Text/app01a.html#ch02ex_2_6_10a">10</a>.</strong> [<em>26</em>] Can you think of a better way to organize a personnel table so that searches as described in the previous exercise would be more efficient? (The answer to this exercise is <em>not</em> merely “yes” or “no.”)</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_11" href="../Text/app01a.html#ch02ex_2_6_11a">11</a>.</strong> [<em>11</em>] Suppose that we have a 200 × 200 matrix in which there are at most four nonzero entries per row. How much storage is required to represent this matrix as in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>, if we use three words per node except for list heads, which will use one word?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_12" href="../Text/app01a.html#ch02ex_2_6_12a">12</a>.</strong> [<em>20</em>] What are <code>VAL(Q0)</code>, <code>VAL(P0)</code>, and <code>VAL(P1)</code> at the beginning of step S7, in terms of the notation <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em> used in (<a href="../Text/ch02a.html#ch02eq-lev2sec6-13">13</a>)?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_13" href="../Text/app01a.html#ch02ex_2_6_13a">13</a>.</strong> [<em>22</em>] Why were circular lists used in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a> instead of straight linear lists? Could <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> be rewritten so that it does not make use of the circular linkage?</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_14" href="../Text/app01a.html#ch02ex_2_6_14a">14</a>.</strong> [<em>22</em>] <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> actually saves pivoting time in a sparse matrix, since it avoids consideration of those columns in which the pivot row has a zero entry. Show that this savings in running time can be achieved in a large sparse matrix that is stored sequentially, with the help of an auxiliary table <code>LINK[j]</code>, 1 ≤ <em>j</em> ≤ <em>n</em>.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_15" href="../Text/app01a.html#ch02ex_2_6_15a">15</a>.</strong> [<em>29</em>] Write a <code>MIXAL</code> program for <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a>. Assume that the <code>VAL</code> field is a floating point number, and that <code>MIX</code>’s floating point arithmetic operators <code>FADD</code>, <code>FSUB</code>, <code>FMUL</code>, and <code>FDIV</code> can be used for operations on this field. Assume for simplicity that <code>FADD</code> and <code>FSUB</code> return the answer zero when the operands added or subtracted cancel most of the significance, so that the test “<code>VAL(P1)</code> = 0” may safely be used in step S7. The floating point operations use only rA, not rX.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_16"></a>16.</strong> [<em>25</em>] Design an algorithm to <em>copy</em> a sparse matrix. (In other words, the algorithm is to yield two distinct representations of a matrix in memory, having the form of <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>, given just one such representation initially.)</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_17" href="../Text/app01a.html#ch02ex_2_6_17a">17</a>.</strong> [<em>26</em>] Design an algorithm to <em>multiply</em> two sparse matrices; given matrices <code>A</code> and <code>B</code>, form a new matrix <code>C</code>, where <code>C[</code><em>i</em>,<em>j</em><code>]</code> = ∑<sub><em>k</em></sub><code>A[</code><em>i</em>,<em>k</em><code>]B[</code><em>k</em>,<em>j</em><code>]</code>. The two input matrices and the output matrix should be represented as in <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>.</p>
<p class="exercises1"><a id="page_307"></a><strong><a id="ch02ex_2_6_18" href="../Text/app01a.html#ch02ex_2_6_18a">18</a>.</strong> [<em>22</em>] The following algorithm replaces a matrix by the inverse of that matrix, assuming that the entries are <code>A[</code><em>i</em>,<em>j</em><code>]</code>, for 1 ≤ <em>i</em>, <em>j</em> ≤ <em>n</em>:</p>
<p class="exercises1I">i) For <em>k</em> = 1, 2, ..., <em>n</em> do the following: Search row <em>k</em> in all columns not yet used as a pivot column, to find an entry with the greatest absolute value; set <code>C[</code><em>k</em><code>]</code> equal to the column in which this entry was found, and do a pivot step with this entry as pivot. (If all such entries are zero, the matrix is singular and has no inverse.)</p>
<p class="exercises1I">ii) Permute rows and columns so that what was row <em>k</em> becomes row <code>C[</code><em>k</em><code>]</code>, and what was column <code>C[</code><em>k</em><code>]</code> becomes column <em>k</em>.</p>
<p class="exercisesp">The problem in this exercise is to use the stated algorithm to invert the matrix</p>
<div class="image"><img src="../Images/ch02/e307_01.jpg"></div>
<p class="exercisesp">by hand calculation.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_19"></a>19.</strong> [<em>31</em>] Modify the algorithm described in <a href="../Text/ch02a.html#ch02ex_2_6_18">exercise 18</a> so that it obtains the inverse of a sparse matrix that is represented in the form of <a href="../Text/ch02a.html#ch02fig14">Fig. 14</a>. Pay special attention to making the row-and column-permutation operations of step (ii) efficient.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_20" href="../Text/app01a.html#ch02ex_2_6_20a">20</a>.</strong> [<em>20</em>] A <em>tridiagonal matrix</em> has entries <em>a<sub>ij</sub></em> that are zero except when |<em>i</em> − <em>j</em>| ≤ 1, for 1 ≤ <em>i</em>, <em>j</em> ≤ <em>n</em>. Show that there is an allocation function of the form</p>
<p class="center"><code>LOC(A[I,J])</code> = <em>a</em><sub>0</sub> + <em>a</em><sub>1</sub><code>I</code> + <em>a</em><sub>2</sub><code>J</code><em>,</em>&nbsp;&nbsp;&nbsp;|<code>I</code> − <code>J</code>| ≤ 1<em>,</em></p>
<p class="exercisesp">which represents all of the relevant elements of a tridiagonal matrix in (3<em>n</em> − 2) consecutive locations.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_21" href="../Text/app01a.html#ch02ex_2_6_21a">21</a>.</strong> [<em>20</em>] Suggest a storage allocation function for <em>n</em> × <em>n</em> matrices where <em>n</em> is variable. The elements <code>A[I,J]</code> for 1 ≤ <code>I,J</code> ≤ <em>n</em> should occupy <em>n</em><sup>2</sup> consecutive locations, regardless of the value of <em>n</em>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_22" href="../Text/app01a.html#ch02ex_2_6_22a">22</a>.</strong> [<em>M25</em>] (P. Chowla, 1961.) Find a polynomial <em>p</em>(<em>i</em><sub>1</sub>, ..., <em>i</em><sub><em>k</em></sub>) that assumes each nonnegative integer value exactly once as the indices (<em>i</em><sub>1</sub>, ..., <em>i</em><sub><em>k</em></sub>) run through all <em>k</em>-dimensional nonnegative integer vectors, with the additional property that <em>i</em><sub>1</sub> +· · ·+<em>i</em><sub><em>k</em></sub> &lt; <em>j</em><sub>1</sub> + · · · + <em>j</em><sub><em>k</em></sub> implies <em>p</em>(<em>i</em><sub>1</sub>, ..., <em>i</em><sub><em>k</em></sub>) &lt; <em>p</em>(<em>j</em><sub>1</sub>, ..., <em>j</em><sub><em>k</em></sub>).</p>
<p class="exercises1"><strong><a id="ch02ex_2_6_23" href="../Text/app01a.html#ch02ex_2_6_23a">23</a>.</strong> [<em>23</em>] An <em>extendible matrix</em> is initially 1 × 1, then it grows from size <em>m</em> × <em>n</em> either to size (<em>m</em> + 1) × <em>n</em> or to size <em>m</em> × (<em>n</em> + 1) by adding either a new row or a new column. Show that such a matrix can be given a simple allocation function in which the elements <code>A[I,J]</code> occupy <em>mn</em> consecutive locations, for 0 ≤ <code>I</code> <em>&lt; m</em> and 0 ≤ <code>J</code> <em>&lt; n</em>; no elements change location when the matrix grows.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_6_24" href="../Text/app01a.html#ch02ex_2_6_24a">24</a>.</strong> [<em>25</em>] (<em>The sparse array trick.</em>) Suppose you want to use a large array for random access, although you won’t actually be referring to very many of its entries. You want <code>A[</code><em>k</em><code>]</code> to be zero the first time you access it, yet you don’t want to spend the time to set every location to zero. Explain how it is possible to read and write any desired elements <code>A[</code><em>k</em><code>]</code> reliably, given <em>k</em>, without assuming anything about the actual initial memory contents, by doing only a small fixed number of additional operations per array access.</p>
<div class="heading">
<h3 id="ch02lev1sec3"><a id="page_308"></a>2.3. Trees</h3>
<p class="noindent">W<small>E NOW TURN</small> to a study of trees, the most important nonlinear structures that arise in computer algorithms. Generally speaking, tree structure means a “branching” relationship between nodes, much like that found in the trees of nature.</p>
</div>
<p class="indent">Let us define a <em>tree</em> formally as a finite set <em>T</em> of one or more nodes such that</p>
<p class="indenti">a) there is one specially designated node called the <em>root</em> of the tree, root(<em>T</em>); and</p>
<p class="indenti">b) the remaining nodes (excluding the root) are partitioned into <em>m</em> ≥ 0 disjoint sets <em>T</em><sub>1</sub>, ..., <em>T</em><sub><em>m</em></sub>, and each of these sets in turn is a tree. The trees <em>T</em><sub>1</sub>, ..., <em>T</em><sub><em>m</em></sub> are called the <em>subtrees</em> of the root.</p>
<p class="indent">The definition just given is recursive: We have defined a tree in terms of trees. Of course, there is no problem of circularity involved here, since trees with one node must consist of only the root, and trees with <em>n</em> &gt; 1 nodes are defined in terms of trees with fewer than <em>n</em> nodes; hence the concept of a tree with two nodes, three nodes, or ultimately any number of nodes, is determined by the definition given. There are nonrecursive ways to define trees (for example, see <a href="../Text/ch02a.html#ch02ex_1_3_10">exercises 10</a>, <a href="../Text/ch02a.html#ch02ex_1_3_12">12</a>, and <a href="../Text/ch02a.html#ch02ex_1_3_14">14</a>, and <a href="../Text/ch02b.html#ch02lev2sec10">Section 2.3.4</a>), but a recursive definition seems most appropriate since recursion is an innate characteristic of tree structures. The recursive character of trees is present also in nature, since buds on young trees eventually grow into subtrees with buds of their own, and so on. <a href="../Text/ch02a.html#ch02ex_1_3_3">Exercise 3</a> illustrates how to give rigorous proofs of important facts about trees based on a recursive definition such as the one above, by using induction on the number of nodes in a tree.</p>
<p class="indent">It follows from our definition that every node of a tree is the root of some subtree contained in the whole tree. The number of subtrees of a node is called the <em>degree</em> of that node. A node of degree zero is called a <em>terminal node</em>, or sometimes a <em>leaf</em>. A nonterminal node is often called a <em>branch node</em>. The <em>level</em> of a node with respect to <em>T</em> is defined recursively: The level of root(<em>T</em>) is zero, and the level of any other node is one higher than that node’s level with respect to the subtree of root(<em>T</em>) containing it.</p>
<p class="indent">These concepts are illustrated in <a href="../Text/ch02a.html#ch02fig15">Fig. 15</a>, which shows a tree with seven nodes. The root is <em>A</em>, and it has the two subtrees {<em>B</em>} and {<em>C, D, E, F, G</em>}. The tree {<em>C, D, E, F, G</em>} has node <em>C</em> as its root. Node <em>C</em> is on level 1 with respect to the whole tree, and it has three subtrees {<em>D</em>}, {<em>E</em>}, and {<em>F, G</em>}; therefore <em>C</em> has degree 3. The terminal nodes in <a href="../Text/ch02a.html#ch02fig15">Fig. 15</a> are <em>B</em>, <em>D</em>, <em>E</em>, and <em>G</em>; <em>F</em> is the only node with degree 1; <em>G</em> is the only node with level 3.</p>
<div class="image"><a id="ch02fig15"></a><img src="../Images/ch02/02fig15.jpg"><p class="fig-caption"><strong>Fig. 15.</strong> A tree.</p></div>
<p class="indent">If the relative order of the subtrees <em>T</em><sub>1</sub>, ..., <em>T</em><sub><em>m</em></sub> in (b) of the definition is important, we say that the tree is an <em>ordered tree</em>; when <em>m</em> ≥ 2 in an ordered tree, it makes sense to call <em>T</em><sub>2</sub> the “second subtree” of the root, etc. Ordered trees are also called “plane trees” by some authors, since the manner of embedding the tree in a plane is relevant. If we do not care to regard two trees as different when they differ only in the respective ordering of subtrees of nodes, the tree is said to be <em>oriented</em>, since only the relative orientation of the nodes, not their <a id="page_309"></a>order, is being considered. The very nature of computer representation defines an implicit ordering for any tree, so in most cases ordered trees are of greatest interest to us. We will therefore tacitly assume that <em>all trees we discuss</em> are ordered, <em>unless explicitly stated otherwise.</em> Accordingly, the trees of <a href="../Text/ch02a.html#ch02fig15">Figs. 15</a> and <a href="../Text/ch02a.html#ch02fig16">16</a> will generally be considered to be different, although they would be the same as oriented trees.</p>
<div class="image"><a id="ch02fig16"></a><img src="../Images/ch02/02fig16.jpg"><p class="fig-caption"><strong>Fig. 16.</strong> Another tree.</p></div>
<p class="indent">A <em>forest</em> is a set (usually an ordered set) of zero or more disjoint trees. Another way to phrase part (b) of the definition of tree would be to say that <em>the nodes of a tree excluding the root form a forest.</em></p>
<p class="indent">There is very little distinction between abstract forests and trees. If we delete the root of a tree, we have a forest; conversely, if we add just one node to any forest and regard the trees of the forest as subtrees of the new node, we get a tree. Therefore the words tree and forest are often used almost interchangeably during informal discussions about data structures.</p>
<p class="indent">Trees can be drawn in many ways. Besides the diagram of <a href="../Text/ch02a.html#ch02fig15">Fig. 15</a>, three of the principal alternatives are shown in <a href="../Text/ch02a.html#ch02fig17">Fig. 17</a>, depending on where the root is placed. It is not a frivolous joke to worry about how tree structures are drawn in diagrams, since there are many occasions in which we want to say that one node is “above” or “higher than” another node, or to refer to the “rightmost” element, etc. Certain algorithms for dealing with tree structures have become known as “top down” methods, as opposed to “bottom up.” Such terminology leads to confusion unless we adhere to a uniform convention for drawing trees.</p>
<div class="image"><a id="ch02fig17"></a><img src="../Images/ch02/02fig17.jpg"><p class="fig-caption"><strong>Fig. 17.</strong> How shall we draw a tree?</p></div>
<p class="indent">It may seem that the form of <a href="../Text/ch02a.html#ch02fig15">Fig. 15</a> would be preferable simply because that is how trees grow in nature; in the absence of any compelling reason to adopt any of the other three forms, we might as well adopt nature’s time-honored <a id="page_310"></a><a id="page_311"></a>tradition. With real trees in mind, the author consistently followed a root-at-the-bottom convention as the present set of books was first being prepared, but after two years of trial it was found to be a mistake: Observations of the computer literature and numerous informal discussions with computer scientists about a wide variety of algorithms showed that trees were drawn with the <em>root at the top</em> in more than 80 percent of the cases examined. There is an overwhelming tendency to make hand-drawn charts grow downwards instead of upwards (and this is easy to understand in view of the way we write); even the word “subtree,” as opposed to “supertree,” tends to connote a downward relationship. From these considerations we conclude that <em>Fig</em>. <em>15 is upside down</em>. Henceforth we will almost always draw trees as in <a href="../Text/ch02a.html#ch02fig17">Fig. 17</a>(b), with the root at the top and leaves at the bottom. Corresponding to this orientation, we should perhaps call the root node the <em>apex</em> of the tree, and speak of nodes at <em>shallow</em> and <em>deep</em> levels.</p>
<p class="indent">It is necessary to have good descriptive terminology for talking about trees. Instead of making somewhat ambiguous references to “above” and “below,” we generally use genealogical words taken from the terminology of <em>family trees</em>. <a href="../Text/ch02a.html#ch02fig18">Figure 18</a> shows two common types of family trees. The two types are quite different: A <em>pedigree</em> shows the ancestors of a given individual, while a <em>lineal chart</em> shows the descendants.</p>
<div class="image4"><a id="ch02fig18"></a><img class="img1" src="./ch02a_files/02fig18.jpg"><p class="fig-caption"><strong>Fig. 18.</strong> Family trees: (a) pedigree; (b) lineal chart. [References: Burke’s <em>Peerage</em> (1959); <em>Almanach de Gotha</em> (1871); <em>Genealogisches Handbuch des Adels: Fürstliche Häuser</em>, <strong>1</strong>; Genesis 10 : 1–25.]</p></div>
<p class="indent">If “cross-breeding” occurs, a pedigree is not really a tree, because different branches of a tree (as we have defined it) can never be joined together. To compensate for this discrepancy, <a href="../Text/ch02a.html#ch02fig18">Fig. 18</a>(a) mentions Queen Victoria and Prince Albert twice in the sixth generation; King Christian IX and Queen Louise actually appear in both the fifth and sixth generations. A pedigree can be regarded as a true tree if each of its nodes represents “a person in the role of mother or father of so-and-so,” not simply a person as an individual.</p>
<p class="indent">Standard terminology for tree structures is taken from the <em>second</em> form of family tree, the lineal chart: Each root is said to be the <em>parent</em> of the roots of its subtrees, and the latter are said to be <em>siblings</em>; they are <em>children</em> of their parent. The root of the entire tree has no parent. For example, in <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a>, <em>C</em> has three children, <em>D</em>, <em>E</em>, and <em>F</em>; <em>E</em> is the parent of <em>G</em>; <em>B</em> and <em>C</em> are siblings. Extension of this terminology — for example, <em>A</em> is the great-grandparent of <em>G</em>; <em>B</em> is an aunt or uncle of <em>F</em>; <em>H</em> and <em>F</em> are first cousins — is clearly possible. Some authors use the masculine designations “father, son, brother” instead of “parent, child, sibling”; others use “mother, daughter, sister.” In any case a node has at most one parent or progenitor. We use the words <em>ancestor</em> and <em>descendant</em> to denote a relationship that may span several levels of the tree: The descendants of <em>C</em> in <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a> are <em>D</em>, <em>E</em>, <em>F</em>, and <em>G</em>; the ancestors of <em>G</em> are <em>E</em>, <em>C</em>, and <em>A</em>. Sometimes, especially when talking about “nearest common ancestors,” we consider a node to be an ancestor of itself (and a descendant of itself); the <em>inclusive ancestors</em> of <em>G</em> are <em>G</em>, <em>E</em>, <em>C</em>, and <em>A</em>, while its <em>proper ancestors</em> are just <em>E</em>, <em>C</em>, and <em>A</em>.</p>
<div class="image"><a id="ch02fig19"></a><img src="../Images/ch02/02fig19.jpg"><p class="fig-caption"><strong>Fig. 19.</strong> Conventional tree diagram.</p></div>
<p class="indent"><a id="page_312"></a>The pedigree in <a href="../Text/ch02a.html#ch02fig18">Figure 18</a>(a) is an example of a <em>binary tree</em>, which is another important type of tree structure. The reader has undoubtedly seen binary trees in connection with tennis tournaments or other sporting events. In a binary tree each node has at most two subtrees; and when only one subtree is present, we distinguish between the left and right subtree. More formally, let us define a binary tree as <em>a finite set of nodes that either is empty, or consists of a root and the elements of two disjoint binary trees</em> called the left and right subtrees of the root.</p>
<p class="indent">This recursive definition of binary tree should be studied carefully. Notice that a binary tree is <em>not</em> a special case of a tree; it is another concept entirely (although we will see many relations between the two concepts). For example, the binary trees</p>
<div class="equation"><a id="ch02eq-lev1sec3-1"></a><img src="../Images/ch02/312equ01.jpg"></div>
<p class="noindent">are distinct — the root has an empty right subtree in one case and a nonempty right subtree in the other — although as trees these diagrams would represent identical structures. A binary tree can be empty; a tree cannot. Therefore we will always be careful to use the word “binary” to distinguish between binary trees and ordinary trees. Some authors define binary trees in a slightly different manner (see <a href="../Text/ch02a.html#ch02ex_1_3_20">exercise 20</a>).</p>
<p class="indent">Tree structure can be represented graphically in several other ways bearing no resemblance to actual trees. <a href="../Text/ch02a.html#ch02fig20">Figure 20</a> shows three diagrams that reflect the structure of <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a>: <a href="../Text/ch02a.html#ch02fig20">Figure 20</a>(a) essentially represents <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a> as an <em>oriented</em> tree; this diagram is a special case of the general idea of <em>nested sets</em>, namely a collection of sets in which any pair of sets is either disjoint or one contains the other. (See <a href="../Text/ch02a.html#ch02ex_1_3_10">exercise 10</a>.) Part (b) of the figure shows nested sets in a line, much as part (a) shows them in a plane; in part (b) the ordering of the tree is also indicated. Part (b) may also be regarded as an outline of an algebraic formula involving nested parentheses. Part (c) shows still another common way to represent tree structure, using <em>indentation</em>. The number of different representation methods in itself is ample evidence for the importance of tree structures in everyday life as well as in computer programming. Any hierarchical classification scheme leads to a tree structure.</p>
<div class="image"><a id="ch02fig20"></a><img src="../Images/ch02/02fig20.jpg"><p class="fig-caption"><strong>Fig. 20.</strong> Further ways to show tree structure: (a) nested sets; (b) nested parentheses; (c) indentation.</p></div>
<p class="indent"><a id="page_313"></a>An algebraic formula defines an implicit tree structure that is often conveyed by other means instead of, or in addition to, the use of parentheses. For example, <a href="../Text/ch02a.html#ch02fig21">Figure 21</a> shows a tree corresponding to the arithmetic expression</p>
<div class="equation"><a id="ch02eq-lev1sec3-2"></a><img src="../Images/ch02/313equ01.jpg"></div>
<div class="image"><a id="ch02fig21"></a><img src="../Images/ch02/02fig21.jpg"><p class="fig-caption"><strong>Fig. 21.</strong> Tree representation of formula (<a href="../Text/ch02a.html#ch02eq-lev1sec3-2">2</a>).</p></div>
<p class="noindent">Standard mathematical conventions, according to which multiplication and division take precedence over addition and subtraction, allow us to use a simplified form like (<a href="../Text/ch02a.html#ch02eq-lev1sec3-2">2</a>) instead of the fully parenthesized form “<em>a</em> − (<em>b</em> × ((<em>c/d</em>) + (<em>e/f</em>)))”. This connection between formulas and trees is very important in applications.</p>
<p class="indent">Notice that the indented list in <a href="../Text/ch02a.html#ch02fig20">Fig. 20</a>(c) looks very much like the table of contents in a book. Indeed, this book itself has a tree structure; the tree structure of <a href="../Text/ch02.html#ch02">Chapter 2</a> is shown in <a href="../Text/ch02a.html#ch02fig22">Fig. 22</a>. Here we notice a significant idea: <em>The method used to number sections in this book is another way to specify tree structure</em>. Such a method is often called “Dewey decimal notation” for trees, by analogy with the similar classification scheme of this name used in libraries. The Dewey decimal notation for the tree of <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a> is</p>
<p class="center">1 <em>A</em>;&nbsp;&nbsp;&nbsp;1.1 <em>B</em>;&nbsp;&nbsp;&nbsp;1.1.1 <em>H</em>;&nbsp;&nbsp;&nbsp;1.1.2 <em>J</em>;&nbsp;&nbsp;&nbsp;1.2 <em>C</em>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.1 <em>D</em>;&nbsp;&nbsp;&nbsp;1.2.2 <em>E</em>;&nbsp;&nbsp;&nbsp;1.2.2.1 <em>G</em>;&nbsp;&nbsp;&nbsp;1.2.3 <em>F.</em></p>
<div class="image4"><a id="ch02fig22"></a><img class="img1" src="./ch02a_files/02fig22.jpg"><p class="fig-caption"><strong>Fig. 22.</strong> The structure of <a href="../Text/ch02.html#ch02">Chapter 2</a>.</p></div>
<p class="noindent">Dewey decimal notation applies to any forest: The root of the <em>k</em>th tree in the forest is given number <em>k</em>; and if α is the number of any node of degree <em>m</em>, its children are numbered <em>α.</em>1<em>, α.</em>2<em>, ..., α.m</em>. The Dewey decimal notation satisfies many simple mathematical properties, and it is a useful tool in the analysis of trees. One example of this is the natural sequential ordering it gives to the nodes of an arbitrary tree, analogous to the ordering of sections within this book. <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a> precedes <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a>, and follows <a href="../Text/ch02a.html#ch02lev2sec6">Section 2.2.6</a>.</p>
<p class="indent">There is an intimate relation between Dewey decimal notation and the notation for indexed variables that we have already been using extensively. If <em>F</em> is a forest of trees, we may let <em>F</em> [1] denote the subtrees of the first tree, so that <em>F</em> [1][2] ≡ <em>F</em> [1<em>,</em> 2] stands for the subtrees of the second subtree of <em>F</em> [1], and <em>F</em> [1, 2, 1] stands for the first subforest of the latter, and so on. Node <em>a.b.c.d</em> in Dewey decimal notation is the parent of <em>F</em> [<em>a, b, c, d</em>]. This notation is an extension of ordinary index notation, because the admissible range of each index depends on the values in the preceding index positions.</p>
<p class="indent"><a id="page_314"></a><a id="page_315"></a>Thus, in particular, we see that any rectangular array can be thought of as a special case of a tree or forest structure. For example, here are two representations of a 3 × 4 matrix:</p>
<div class="image"><img src="../Images/ch02/e315_01.jpg"></div>
<p class="noindent">It is important to observe, however, that this tree structure does not faithfully reflect all of the matrix structure; the row relationships appear explicitly in the tree but the column relationships do not.</p>
<p class="indent">A forest can, in turn, be regarded as a special case of what is commonly called a <em>list structure</em>. The word “list” is being used here in a very technical sense, and to distinguish the technical use of the word we will always capitalize it: “List.” A List is defined (recursively) as <em>a finite sequence of zero or more atoms or Lists</em>. Here “atom” is an undefined concept referring to elements from any universe of objects that might be desired, so long as it is possible to distinguish an atom from a List. By means of an obvious notational convention involving commas and parentheses, we can distinguish between atoms and Lists and we can conveniently display the ordering within a List. As an example, consider</p>
<div class="equation"><a id="ch02eq-lev1sec3-3"></a><img src="../Images/ch02/315equ01.jpg"></div>
<p class="noindent">which is a List with five elements: first the atom <em>a</em>, then the List (<em>b, a, b</em>), then the empty List (), then the atom <em>c</em>, and finally the List (((<a href="../Text/ch02a.html#ch02eq-lev1sec3-2">2</a>))). The latter List consists of the List ((<a href="../Text/ch02a.html#ch02eq-lev1sec3-2">2</a>)), which consists of the List (<a href="../Text/ch02a.html#ch02eq-lev1sec3-2">2</a>), which consists of the atom 2.</p>
<p class="indent">The following tree structure corresponds to <em>L</em>:</p>
<div class="equation"><a id="ch02eq-lev1sec3-4"></a><img src="../Images/ch02/315equ02.jpg"></div>
<p class="noindent">The asterisks in this diagram indicate the definition and appearance of a List, as opposed to the appearance of an atom. Index notation applies to Lists as it does to forests; for example, <em>L</em>[2] = (<em>b, a, b</em>), and <em>L</em>[2<em>,</em> 2] = <em>a</em>.</p>
<p class="indent">No data is carried in the nodes for the Lists in (<a href="../Text/ch02a.html#ch02eq-lev1sec3-4">4</a>) other than the fact that they are Lists. But it is possible to label the nonatomic elements of Lists with information, as we have done for trees and other structures; thus</p>
<p class="center"><em>A</em> = (<em>a</em>: (<em>b, c</em>), <em>d</em>: ())</p>
<p class="noindent"><a id="page_316"></a>would correspond to a tree that we can draw as follows:</p>
<div class="image"><img src="../Images/ch02/e316_01.jpg"></div>
<p class="indent">The big difference between Lists and trees is that Lists may overlap (that is, sub-Lists need not be disjoint) and they may even be recursive (may contain themselves). The List</p>
<div class="equation"><a id="ch02eq-lev1sec3-5"></a><img src="../Images/ch02/316equ01.jpg"></div>
<p class="noindent">corresponds to no tree structure, nor does the List</p>
<div class="equation"><a id="ch02eq-lev1sec3-6"></a><img src="../Images/ch02/316equ02.jpg"></div>
<p class="noindent">(In these examples, capital letters refer to Lists, lowercase letters to labels and atoms.) We might diagram (<a href="../Text/ch02a.html#ch02eq-lev1sec3-5">5</a>) and (<a href="../Text/ch02a.html#ch02eq-lev1sec3-6">6</a>) as follows, using an asterisk to denote each place where a List is defined:</p>
<div class="equation"><a id="ch02eq-lev1sec3-7"></a><img src="../Images/ch02/316equ03.jpg"></div>
<p class="indent">Actually, Lists are not so complicated as the examples above might indicate. They are, in essence, a rather simple generalization of the linear lists that we have considered in <a href="../Text/ch02.html#ch02lev1sec2">Section 2.2</a>, with the additional proviso that the elements of linear Lists may be link variables that point to other linear Lists (and possibly to themselves).</p>
<p class="indent"><em>Summary</em>: Four closely related kinds of information structures — trees, forests, binary trees, and Lists — arise from many sources, and they are therefore important in computer algorithms. We have seen various ways to diagram these structures, and we have considered some terminology and notations that are useful in talking about them. The following sections develop these ideas in greater detail.</p>
<p class="ex-title">Exercises</p>
<p class="exercises"><strong><a id="ch02ex_1_3_1" href="../Text/app01a.html#ch02ex_1_3_1a">1</a>.</strong> [<em>18</em>] How many different trees are there with three nodes, <em>A</em>, <em>B</em>, and <em>C</em> ?</p>
<p class="exercises"><strong><a id="ch02ex_1_3_2" href="../Text/app01a.html#ch02ex_1_3_2a">2</a>.</strong> [<em>20</em>] How many different <em>oriented</em> trees are there with three nodes, <em>A</em>, <em>B</em>, and <em>C</em> ?</p>
<p class="exercises"><strong><a id="ch02ex_1_3_3" href="../Text/app01a.html#ch02ex_1_3_3a">3</a>.</strong> [<em>M20</em>] Prove rigorously from the definitions that for every node <em>X</em> in a tree there is a unique path up to the root, namely a unique sequence of <em>k</em> ≥ 1 nodes <em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ..., <em>X</em><sub><em>k</em></sub> such that <em>X</em><sub>1</sub> is the root of the tree, <em>X</em><sub><em>k</em></sub> = <em>X</em>, and <em>X</em><sub><em>j</em></sub> is the parent of <em>X</em><sub><em>j</em>+1</sub> for 1 ≤ <em>j &lt; k</em>. (This proof will be typical of the proofs of nearly all the elementary facts about tree structures.) <em>Hint:</em> Use induction on the number of nodes in the tree.</p>
<p class="exercises"><strong><a id="ch02ex_1_3_4" href="../Text/app01a.html#ch02ex_1_3_4a">4</a>.</strong> [<em>01</em>] True or false: In a conventional tree diagram (root at the top), if node <em>X</em> has a <em>higher</em> level number than node <em>Y</em>, then node <em>X</em> appears <em>lower</em> in the diagram than node <em>Y</em>.</p>
<p class="exercises"><a id="page_317"></a><strong><a id="ch02ex_1_3_5" href="../Text/app01a.html#ch02ex_1_3_5a">5</a>.</strong> [<em>02</em>] If node <em>A</em> has three siblings and <em>B</em> is the parent of <em>A</em>, what is the degree of <em>B</em>?</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_6" href="../Text/app01a.html#ch02ex_1_3_6a">6</a>.</strong> [<em>21</em>] Define the statement “<em>X</em> is an <em>m</em>th cousin of <em>Y</em>, <em>n</em> times removed” as a meaningful relation between nodes <em>X</em> and <em>Y</em> of a tree, by analogy with family trees, if <em>m</em> &gt; 0 and <em>n</em> ≥ 0. (See a dictionary for the meaning of these terms in regard to family trees.)</p>
<p class="exercises"><strong><a id="ch02ex_1_3_7" href="../Text/app01a.html#ch02ex_1_3_7a">7</a>.</strong> [<em>23</em>] Extend the definition given in the previous exercise to all <em>m</em> ≥ −1 and to all integers <em>n</em> ≥ −(<em>m</em> + 1) in such a way that for any two nodes <em>X</em> and <em>Y</em> of a tree there are unique <em>m</em> and <em>n</em> such that <em>X</em> is an <em>m</em>th cousin of <em>Y</em>, <em>n</em> times removed.</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_8" href="../Text/app01a.html#ch02ex_1_3_8a">8</a>.</strong> [<em>03</em>] What binary tree is not a tree?</p>
<p class="exercises"><strong><a id="ch02ex_1_3_9" href="../Text/app01a.html#ch02ex_1_3_9a">9</a>.</strong> [<em>00</em>] In the two binary trees of (<a href="../Text/ch02a.html#ch02eq-lev1sec3-1">1</a>), which node is the root (<em>B</em> or <em>A</em>)?</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_10" href="../Text/app01a.html#ch02ex_1_3_10a">10</a>.</strong> [<em>M20</em>] A collection of nonempty sets is said to be <em>nested</em> if, given any pair <em>X</em>, <em>Y</em> of the sets, either <em>X</em> <span class="ent">⊆</span> <em>Y</em> or <em>X</em> <span class="ent">⊇</span> <em>Y</em> or <em>X</em> and <em>Y</em> are disjoint. (In other words, <em>X</em> ∩ <em>Y</em> is either <em>X</em>, <em>Y</em>, or <span class="middle"><img src="../Images/ch02/0-slash.jpg"></span>.) <a href="../Text/ch02a.html#ch02fig20">Figure 20</a>(a) indicates that any tree corresponds to a collection of nested sets; conversely, does every such collection correspond to a tree?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_11" href="../Text/app01a.html#ch02ex_1_3_11a">11</a>.</strong> [<em>HM32</em>] Extend the definition of tree to infinite trees by considering collections of nested sets as in <a href="../Text/ch02a.html#ch02ex_1_3_10">exercise 10</a>. Can the concepts of level, degree, parent, and child be defined for each node of an infinite tree? Give examples of nested sets of real numbers that correspond to a tree in which</p>
<p class="indenthangingA">a) every node has uncountable degree and there are infinitely many levels;</p>
<p class="indenthangingA">b) there are nodes with uncountable level;</p>
<p class="indenthangingA">c) every node has degree at least 2 and there are uncountably many levels.</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_12" href="../Text/app01a.html#ch02ex_1_3_12a">12</a>.</strong> [<em>M23</em>] Under what conditions does a partially ordered set correspond to an unordered tree or forest? (Partially ordered sets are defined in <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a>.)</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_13" href="../Text/app01a.html#ch02ex_1_3_13a">13</a>.</strong> [<em>10</em>] Suppose that node <em>X</em> is numbered <em>a</em><sub>1</sub> .<em>a</em><sub>2</sub> . · · · .<em>a</em><sub><em>k</em></sub> in the Dewey decimal system; what are the Dewey numbers of the nodes in the path from <em>X</em> to the root (see <a href="../Text/ch02a.html#ch02ex_1_3_3">exercise 3</a>)?</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_14" href="../Text/app01a.html#ch02ex_1_3_14a">14</a>.</strong> [<em>M22</em>] Let S be any nonempty set of elements having the form “1.<em>a</em><sub>1</sub> . · · · .<em>a</em><sub><em>k</em></sub>”, where <em>k</em> ≥ 0 and <em>a</em><sub>1</sub>, ..., <em>a</em><sub><em>k</em></sub> are positive integers. Show that <em>S</em> specifies a tree when it is finite and satisfies the following condition: “If <em>α.m</em> is in the set, then so is <em>α.</em>(<em>m</em> − 1) if <em>m</em> &gt; 1, or α if <em>m</em> = 1.” (This condition is clearly satisfied in the Dewey decimal notation for a tree; therefore it is another way to characterize tree structure.)</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_15" href="../Text/app01a.html#ch02ex_1_3_15a">15</a>.</strong> [<em>20</em>] Invent a notation for the nodes of binary trees, analogous to the Dewey decimal notation for nodes of trees.</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_16" href="../Text/app01a.html#ch02ex_1_3_16a">16</a>.</strong> [<em>20</em>] Draw trees analogous to <a href="../Text/ch02a.html#ch02fig21">Fig. 21</a> corresponding to the arithmetic expressions (a) 2(<em>a</em> − <em>b/c</em>); (b) <em>a</em> + <em>b</em> + 5<em>c</em>.</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_17" href="../Text/app01a.html#ch02ex_1_3_17a">17</a>.</strong> [<em>01</em>] If <em>Z</em> stands for <a href="../Text/ch02a.html#ch02fig19">Fig. 19</a> regarded as a forest, what node is parent(<em>Z</em> [1<em>,</em> 2<em>,</em> 2])?</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_18" href="../Text/app01a.html#ch02ex_1_3_18a">18</a>.</strong> [<em>08</em>] In List (<a href="../Text/ch02a.html#ch02eq-lev1sec3-3">3</a>), what is <em>L</em>[5<em>,</em> 1<em>,</em> 1]? What is <em>L</em>[3<em>,</em> 1]?</p>
<p class="exercises1"><strong><a id="ch02ex_1_3_19" href="../Text/app01a.html#ch02ex_1_3_19a">19</a>.</strong> [<em>15</em>] Draw a List diagram analogous to (<a href="../Text/ch02a.html#ch02eq-lev1sec3-7">7</a>) for the List <em>L</em> = (<em>a,</em> (<em>L</em>)). What is <em>L</em>[2] in this List? What is <em>L</em>[2<em>,</em> 1<em>,</em> 1]?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_20" href="../Text/app01a.html#ch02ex_1_3_20a">20</a>.</strong> [<em>M21</em>] Define a <em>0-2-tree</em> as a tree in which each node has exactly zero or two children. (Formally, a 0 -2-tree consists of a single node, called its root, plus 0 or 2 disjoint 0 -2-trees.) Show that every 0 -2-tree has an odd number of nodes; and give a one-to-one correspondence between binary trees with <em>n</em> nodes and (ordered) 0 -2-trees with 2<em>n</em> + 1 nodes.</p>
<p class="exercises1"><a id="page_318"></a><strong><a id="ch02ex_1_3_21" href="../Text/app01a.html#ch02ex_1_3_21a">21</a>.</strong> [<em>M22</em>] If a tree has <em>n</em><sub>1</sub> nodes of degree 1, <em>n</em><sub>2</sub> nodes of degree 2, ..., and <em>n</em><sub>m</sub> nodes of degree <em>m</em>, how many terminal nodes does it have?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_1_3_22" href="../Text/app01a.html#ch02ex_1_3_22a">22</a>.</strong> [<em>21</em>] Standard European paper sizes A0, A1, A2, ..., A<em>n</em>, ... are rectangles whose sides are in the ratio <span class="middle"><img src="../Images/ch02/root-2.jpg"></span> to 1 and whose areas are 2<sup>−<em>n</em></sup> square meters. Therefore if we cut a sheet of A<em>n</em> paper in half, we get two sheets of A(<em>n</em> + 1) paper. Use this principle to design a graphic representation of binary trees, and illustrate your idea by drawing the representation of <a href="../Text/ch02a.html#ch02lev2sec7">2.3.1</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>) below.</p>
<div class="heading">
<h4 id="ch02lev2sec7">2.3.1. Traversing Binary Trees</h4>
<p class="noindent">It is important to acquire a good understanding of the properties of binary trees before making further investigations of trees, since general trees are usually represented in terms of some equivalent binary tree inside a computer.</p>
</div>
<p class="indent">We have defined a binary tree as a finite set of nodes that either is empty, or consists of a root together with two binary trees. This definition suggests a natural way to represent binary trees within a computer: We can have two links, <code>LLINK</code> and <code>RLINK</code>, within each node, and a link variable <code>T</code> that is a “pointer to the tree.” If the tree is empty, <code>T</code> = <em>Λ;</em> otherwise <code>T</code> is the address of the root node of the tree, and <code>LLINK(T)</code>, <code>RLINK(T)</code> are pointers to the left and right subtrees of the root, respectively. These rules recursively define the memory representation of any binary tree; for example,</p>
<div class="equation"><a id="ch02eq-lev2sec7-1"></a><img src="../Images/ch02/318equ01.jpg"></div>
<p class="noindent">is represented by</p>
<div class="equation"><a id="ch02eq-lev2sec7-2"></a><img src="../Images/ch02/318equ02.jpg"></div>
<p class="indent">This simple and natural memory representation accounts for the special importance of binary tree structures. We will see in <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a> that general trees can conveniently be represented as binary trees. Moreover, many trees that arise in applications are themselves inherently binary, so binary trees are of interest in their own right.</p>
<p class="indent"><a id="page_319"></a>There are many algorithms for manipulation of tree structures, and one idea that occurs repeatedly in these algorithms is the notion of <em>traversing</em> or “walking through” a tree. This is a method of examining the nodes of the tree systematically so that each node is visited exactly once. A complete traversal of the tree gives us a linear arrangement of the nodes, and many algorithms are facilitated if we can talk about the “next” node following or preceding a given node in such a sequence.</p>
<p class="indent">Three principal ways may be used to traverse a binary tree: We can visit the nodes in <em>preorder</em>, <em>inorder</em>, or <em>postorder</em>. These three methods are defined recursively. When the binary tree is empty, it is “traversed” by doing nothing; otherwise the traversal proceeds in three steps:</p>
<div class="image"><img src="../Images/ch02/e319_01.jpg"></div>
<p class="noindent">If we apply these definitions to the binary tree of (<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), we find that the nodes in preorder are</p>
<div class="equation"><a id="ch02eq-lev2sec7-3"></a><img src="../Images/ch02/319equ01.jpg"></div>
<p class="noindent">(First comes the root A, then comes the left subtree</p>
<div class="image"><img src="../Images/ch02/e319_02.jpg"></div>
<p class="noindent">in preorder, and finally we traverse the right subtree in preorder.) For inorder we visit the root between visits to the nodes of each subtree, essentially as though the nodes were “projected” down onto a single horizontal line, and this gives the sequence</p>
<div class="equation"><a id="ch02eq-lev2sec7-4"></a><img src="../Images/ch02/319equ02.jpg"></div>
<p class="noindent">The postorder for the nodes of this binary tree is, similarly,</p>
<div class="equation"><a id="ch02eq-lev2sec7-5"></a><img src="../Images/ch02/319equ03.jpg"></div>
<p class="indent">We will see that these three ways of arranging the nodes of a binary tree into a sequence are extremely important, as they are intimately connected with most of the computer methods for dealing with trees. The names <em>preorder</em>, <em>inorder</em>, and <em>postorder</em> come, of course, from the relative position of the root with respect to its subtrees. In many applications of binary trees, there is symmetry between the meanings of left subtrees and right subtrees, and in such cases the term <em>symmetric order</em> is used as a synonym for inorder. Inorder, which puts the root <a id="page_320"></a>in the middle, is essentially symmetric between left and right: If the binary tree is reflected about a vertical axis, the symmetric order is simply reversed.</p>
<div class="image"><a id="ch02fig23"></a><img src="../Images/ch02/02fig23.jpg"><p class="fig-caption"><strong>Fig. 23.</strong> <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> for inorder traversal.</p></div>
<p class="indent">A recursively stated definition, such as the one just given for the three basic orders, must be reworked in order to make it directly applicable to computer implementation. General methods for doing this are discussed in Chapter 8; we usually make use of an auxiliary stack, as in the following algorithm:</p>
<p class="noindent"><a id="ch02alg-lev2sec7-T"></a><strong>Algorithm T</strong> <em>(Traverse binary tree in inorder).</em> Let <code>T</code> be a pointer to a binary tree having a representation as in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>); this algorithm visits all the nodes of the binary tree in inorder, making use of an auxiliary stack <code>A</code>.</p>
<p class="indenthanging"><strong>T1.</strong> [Initialize.] Set stack <code>A</code> empty, and set the link variable <code>P</code> ← <code>T.</code></p>
<p class="indenthanging"><strong>T2.</strong> <code>[P</code> = <em>Λ</em>?] If <code>P</code> = <em>Λ</em>, go to step T4.</p>
<p class="indenthanging"><strong>T3.</strong> [Stack <span class="ent">⇐</span> <code>P</code>.] (Now <code>P</code> points to a nonempty binary tree that is to be traversed.) Set <code>A</code> <span class="ent">⇐</span> <code>P</code>; that is, push the value of <code>P</code> onto stack <code>A</code>. (See <a href="../Text/ch02.html#ch02lev2sec1">Section 2.2.1</a>.) Then set <code>P</code> ← <code>LLINK(P)</code> and return to step T2.</p>
<p class="indenthanging"><strong>T4.</strong> [<code>P</code> <span class="ent">⇐</span> Stack.] If stack <code>A</code> is empty, the algorithm terminates; otherwise set <code>p</code> <span class="ent">⇐</span> <code>A</code>.</p>
<p class="indenthanging"><strong>T5.</strong> [Visit <code>P</code>.] Visit <code>NDDE(P).</code> Then set <code>P</code> ← <code>RLINK (P)</code> and return to step T2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">In the final step of this algorithm, the word “visit” means that we do whatever activity is intended as the tree is being traversed. <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> runs like a coroutine with respect to this other activity: The main program activates the coroutine whenever it wants <code>P</code> to move from one node to its inorder successor. Of course, since this coroutine calls the main routine in only one place, it is not much different from a subroutine (see <a href="../Text/ch01c.html#ch01lev2sec16">Section 1.4.2</a>). <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> assumes that the external activity deletes neither <code>NODE(P)</code> nor any of its ancestors from the tree.</p>
<p class="indent">The reader should now attempt to play through <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> using the binary tree (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) as a test case, in order to see the reasons behind the procedure. When we get to step T3, we want to traverse the binary tree whose root is indicated by pointer <code>P</code>. The idea is to save <code>P</code> on a stack and then to traverse the left subtree; when this has been done, we will get to step T4 and will find the <a id="page_321"></a>old value of <code>P</code> on the stack again. After visiting the root, <code>NODE(P)</code>, in step T5, the remaining job is to traverse the right subtree.</p>
<p class="indent"><a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> is typical of many other algorithms that we will see later, so it is instructive to look at a formal proof of the remarks made in the preceding paragraph. Let us now attempt to <em>prove</em> that <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> traverses a binary tree of <em>n</em> nodes in inorder, by using induction on <em>n</em>. Our goal is readily established if we can prove a slightly more general result:</p>
<p class="uln-indent"><em>Starting at step T2 with</em> <code>P</code> <em>a pointer to a binary tree of n nodes and with the stack</em> <code>A</code> <em>containing</em> <code>A[1]</code> ... <code>A[</code><em>m</em><code>]</code> <em>for some m</em> ≥ 0, <em>the procedure of steps T2–T5 will traverse the binary tree in question, in inorder, and will then arrive at step T4 with stack</em> <code>A</code> returned to its original value <code>A[1]</code> ... <code>A[</code><em>m</em><code>]</code>.</p>
<p class="noindent">This statement is obviously true when <em>n</em> = 0, because of step T2. If <em>n</em> &gt; 0, let <code>P</code><sub>0</sub> be the value of <code>P</code> upon entry to step T2. Since <code>P</code><sub>0</sub> ≠ <em>Λ</em>, we will perform step T3, which means that stack <code>A</code> is changed to <code>A[1]</code> ... <code>A[</code><em>m</em><code>] P</code><sub>0</sub> and <code>P</code> is set to <code>LLINK(P</code><sub>0</sub>). Now the left subtree has fewer than <em>n</em> nodes, so by induction we will traverse the left subtree in inorder and will ultimately arrive at step T4 with <code>A[1]</code> ... <code>A[</code><em>m</em><code>] P</code><sub>0</sub> on the stack. Step T4 returns the stack to <code>A[1]</code> ... <code>A[</code><em>m</em><code>]</code> and sets <code>P</code> ← <code>P</code><sub>0</sub> . Step T5 now visits <code>NODE(P</code><sub>0</sub>) and sets <code>P</code> ← <code>RLINK(P</code><sub>0</sub>). Now the right subtree has fewer than <em>n</em> nodes, so by induction we will traverse the right subtree in inorder and arrive at step T4 as required. The tree has been traversed in inorder, by the definition of that order. This completes the proof.</p>
<p class="indent">An almost identical algorithm may be formulated that traverses binary trees in preorder (see <a href="../Text/ch02a.html#ch02ex_2_7_12">exercise 12</a>). It is slightly more difficult to achieve the traversal in postorder (see <a href="../Text/ch02a.html#ch02ex_2_7_13">exercise 13</a>), and for this reason postorder is not as important for binary trees as the others are.</p>
<p class="indent">It is convenient to define a new notation for the successors and predecessors of nodes in these various orders. If <code>P</code> points to a node of a binary tree, let</p>
<div class="equation"><a id="ch02eq-lev2sec7-6"></a><img src="../Images/ch02/321equ01.jpg"></div>
<p class="noindent">If there is no such successor or predecessor of <code>NODE(P)</code>, the value <code>LOC(T)</code> is generally used, where <code>T</code> is an external pointer to the tree in question. We have <code>*(P*)</code> = (<code>*P)</code><code>*</code> = <code>P</code>, <code>$(P$)</code> = <code>($P)$</code> = <code>P</code>, and <code>#(P#)</code> = <code>(#P)#</code> = <code>P</code>. As an example of this notation, let <code>INFO(P)</code> be the letter shown in <code>NODE(P)</code> in the tree (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>); then if <code>P</code> points to the root, we have <code>INFO(P)</code> = <em>A</em>, <code>INFO(P*)</code> = <em>B</em>, <code>INFO(P$)</code> = <em>E</em>, <code>INFO($P)</code> = <em>B</em>, <code>INFO(#P)</code> = <em>C</em>, and <code>P#</code> = <code>*P</code> = <code>LOC(T)</code>.</p>
<p class="indent">At this point the reader will perhaps experience a feeling of insecurity about the intuitive meanings of <code>P*</code>, <code>P$</code>, etc. As we proceed further, the ideas will gradually become clearer; <a href="../Text/ch02a.html#ch02ex_2_7_16">exercise 16</a> at the end of this section may also be of help. The “<code>$</code>” in “<code>P$</code>” is meant to suggest the letter S, for “symmetric order.”</p>
<p class="indent"><a id="page_322"></a>There is an important alternative to the memory representation of binary trees given in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), which is somewhat analogous to the difference between circular lists and straight one-way lists. Notice that there are more null links than other pointers in the tree (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), and indeed this is true of any binary tree represented by the conventional method (see <a href="../Text/ch02a.html#ch02ex_2_7_14">exercise 14</a>). But we don’t really need to waste all that memory space. For example, we could store two “tag” indicators with each node, which would tell in just two bits of memory whether or not the <code>LLINK</code> or <code>RLINK</code>, or both, are null; the memory space for terminal links could then be used for other purposes.</p>
<p class="indent">An ingenious use of this extra space has been suggested by A. J. Perlis and C. Thornton, who devised the so-called <em>threaded</em> tree representation. In this method, terminal links are replaced by “threads” to other parts of the tree, as an aid to traversal. The threaded tree equivalent to (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) is</p>
<div class="equation"><a id="ch02eq-lev2sec7-7"></a><img src="../Images/ch02/322equ01.jpg"></div>
<p class="noindent">Here dotted lines represent the “threads,” which always go to a higher node of the tree. <em>Every</em> node now has two links: Some nodes, like <em>C</em>, have two ordinary links to left and right subtrees; other nodes, like <em>H</em>, have two thread links; and some nodes have one link of each type. The special threads emanating from <em>D</em> and <em>J</em> will be explained later. They appear in the “leftmost” and “rightmost” nodes.</p>
<p class="indent">In the memory representation of a threaded binary tree it is necessary to distinguish between the dotted and solid links; this can be done as suggested above by two additional one-bit fields in each node, <code>LTAG</code> and <code>RTAG</code>. The threaded representation may be defined precisely as follows:</p>
<div class="image"><img src="../Images/ch02/e322_01.jpg"></div>
<p class="indent">According to this definition, each new thread link points directly to the predecessor or successor of the node in question, in symmetric order (inorder). <a href="../Text/ch02a.html#ch02fig24">Figure 24</a> illustrates the general orientation of thread links in any binary tree.</p>
<div class="image"><a id="ch02fig24"></a><img src="../Images/ch02/02fig24.jpg"><p class="fig-caption"><strong>Fig. 24.</strong> General orientation of left and right thread links in a threaded binary tree. Wavy lines indicate links or threads to other parts of the tree.</p></div>
<p class="indent">In some algorithms it can be guaranteed that the root of any subtree always will appear in a lower memory location than the other nodes of the subtree. Then <code>LTAG(P)</code> will be 1 if and only if <code>LLINK(P)</code> &lt; <code>P</code>, so <code>LTAG</code> will be redundant. The <code>RTAG</code> bit will be redundant for the same reason.</p>
<p class="indent"><a id="page_323"></a>The great advantage of threaded trees is t hat traversal algorithms become simpler. For example, the following algorithm calculates <code>P$</code>, given <code>P</code>:</p>
<p class="noindent"><strong>Algorithm S</strong> (<em>Symmetric (inorder) successor in a threaded binary tree).</em> If <code>P</code> points to a node of a threaded binary tree, this algorithm sets <code>Q</code> ← <code>P$</code>.</p>
<p class="indenthanging"><strong>S1.</strong> [<code>RLINK(P)</code> a thread?] Set <code>Q</code> ← <code>RLINK(P)</code>. If <code>RTAG(P)</code> = 1, terminate the algorithm.</p>
<p class="indenthanging"><strong>S2.</strong> [Search to left.] If <code>LTAG(Q)</code> = 0, set <code>Q</code> ← <code>LLINK(Q)</code> and repeat this step. Otherwise the algorithm terminates. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">Notice that no stack is needed here to accomplish what was done using a stack in <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>. In fact, the ordinary representation (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) makes it impossible to find <code>P$</code> efficiently, given only the address of a random point <code>P</code> in the tree. Since no links point upward in an unthreaded representation, there is no clue to what nodes are above a given node, unless we retain a history of how we reached that point. The stack in <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> provides the necessary history when threads are absent.</p>
<p class="indent">We claim that <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> is “efficient,” although this property is not immediately obvious, since step S2 can be executed any number of times. In view of the loop in step S2, would it perhaps be faster to use a stack after all, <a id="page_324"></a>as <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> does? To investigate this question, we will consider the average number of times that step S2 must be performed if <code>P</code> is a “random” point in the tree; or what is the same, we will determine the total number of times that step S2 is performed if <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> is used repeatedly to traverse an entire tree.</p>
<p class="indent">At the same time as this analysis is being carried out, it will be instructive to study complete programs for both Algorithms <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">S</a> and <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">T</a>. As usual, we should be careful to set all of our algorithms up so that they work properly with empty binary trees; and if <code>T</code> is the pointer to the tree, we would like to have <code>LOC(T)*</code> and <code>LOC(T)$</code> be the <em>first</em> nodes in preorder or symmetric order, respectively. For threaded trees, it turns out that things will work nicely if <code>NODE(LOC(T))</code> is made into a “list head” for the tree, with</p>
<div class="equation"><a id="ch02eq-lev2sec7-8"></a><img src="../Images/ch02/324equ01.jpg"></div>
<p class="noindent">(Here <code>HEAD</code> denotes <code>LOC(T)</code>, the address of the list head.) An empty threaded tree will satisfy the conditions</p>
<div class="equation"><a id="ch02eq-lev2sec7-9"></a><img src="../Images/ch02/324equ02.jpg"></div>
<p class="noindent">The tree grows by having nodes inserted to the <em>left</em> of the list head. (These initial conditions are primarily dictated by the algorithm to compute <code>P*</code>, which appears in <a href="../Text/ch02a.html#ch02ex_2_7_17">exercise 17</a>.) In accordance with these conventions, the computer representation for the binary tree (<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>), as a threaded tree, is</p>
<div class="equation"><a id="ch02eq-lev2sec7-10"></a><img src="../Images/ch02/324equ03.jpg"></div>
<p class="indent">With these preliminaries out of the way, we are now ready to consider <code>MIX</code> versions of <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithms S</a> and <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">T</a>. The following programs assume that binary tree nodes have the two-word form</p>
<div class="image"><img src="../Images/ch02/e324_01.jpg"></div>
<p class="noindent">In an unthreaded tree, <code>LTAG</code> and <code>RTAG</code> will always be “+” and terminal links will be represented by zero. In a threaded tree, we will use “+” for tags that are 0 and “−” for tags that are 1. The abbreviations <code>LLINKT</code> and <code>RLINKT</code> will be used to stand for the combined <code>LTAG-LLINK</code> and <code>RTAG-RLINK</code> fields, respectively.</p>
<p class="noindent"><a id="page_325"></a><span class="middle"><img src="../Images/ch02/signal.jpg"></span> <em>The two tag bits occupy otherwise-unused sign positions of a <code>MIX</code> word, so they cost nothing in memory space. Similarly, with the <code>MMIX</code> computer we will be able to use the least significant bits of link fields as tag bits that come “for free,” because pointer values will generally be even, and because <code>MMIX</code> will make it easy to ignore the low-order bits when addressing memory.</em></p>
<p class="indent">The following two programs traverse a binary tree in symmetric order (that is, inorder), jumping to location <code>VISIT</code> periodically with index register 5 pointing to the node that is currently of interest.</p>
<p class="noindent"><a id="ch02a_pro_t"></a><strong>Program T.</strong> In this implementation of <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>, the stack is kept in locations <code>A</code> + 1, <code>A</code> + 2, ..., <code>A</code> + <code>MAX</code>; r<code>I</code>6 is the stack pointer and r<code>I</code>5 ≡ P. <code>OVERFLOW</code> occurs if the stack grows too large. The program has been rearranged slightly from <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> (step T2 appears thrice), so that the test for an empty stack need not be made when going directly from T3 to T2 to T4.</p>
<div class="image"><img src="../Images/ch02/325pro01.jpg"></div>
<p class="noindent"><a id="ch02a_pro_s"></a><strong>Program S.</strong> <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> has been augmented with initialization and termination conditions to make this program comparable to <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a>.</p>
<div class="image"><img src="../Images/ch02/325pro02.jpg"></div>
<p class="indent"><a id="page_326"></a>An analysis of the running time appears with the code above. These quantities are easy to determine, using Kirchhoff’s law and the facts that</p>
<p class="indenti">i) in <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a>, the number of insertions onto the stack must equal the number of deletions;</p>
<p class="indenti">ii) in <a href="../Text/ch02a.html#ch02a_pro_s">Program S</a>, the <code>LLINK</code> and <code>RLINK</code> of each node are examined precisely once;</p>
<p class="indenti">iii) the number of “visits” is the number of nodes in the tree.</p>
<p class="noindent">The analysis tells us <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> takes 15<em>n</em> + <em>a</em> + 4 units of time, and <a href="../Text/ch02a.html#ch02a_pro_s">Program S</a> takes 11<em>n</em> − <em>a</em> + 7 units, where <em>n</em> is the number of nodes in the tree and <em>a</em> is the number of terminal right links (nodes with no right subtree). The quantity <em>a</em> can be as low as 1, assuming that <em>n</em> ≠ 0, and it can be as high as <em>n</em>. If left and right are symmetrical, the average value of <em>a</em> is (<em>n</em> + 1)<em>/</em>2, as a consequence of facts proved in <a href="../Text/ch02a.html#ch02ex_2_7_14">exercise 14</a>.</p>
<p class="indent">The principal conclusions we may reach on the basis of this analysis are:</p>
<p class="indenti">i) Step S2 of <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> is performed only <em>once</em> on the average per execution of that algorithm, if <code>P</code> is a random node of the tree.</p>
<p class="indenti">ii) Traversal is slightly faster for threaded trees, because it requires no stack manipulation.</p>
<p class="indenti">iii) <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> needs more memory space than <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> because of the auxiliary stack required. In <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> we kept the stack in consecutive memory locations; therefore we needed to put an arbitrary bound on its size. It would be very embarrassing if this bound were exceeded, so it must be set reasonably large (see <a href="../Text/ch02a.html#ch02ex_2_7_10">exercise 10</a>); thus the memory requirement of <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> is significantly more than <a href="../Text/ch02a.html#ch02a_pro_s">Program S</a>. Not infrequently a complex computer application will be independently traversing several trees at once, and a separate stack will be needed for each tree under <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a>. This suggests that <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> might use linked allocation for its stack (see <a href="../Text/ch02a.html#ch02ex_2_7_20">exercise 20</a>); its execution time then becomes 30<em>n</em> + <em>a</em> + 4 units, roughly twice as slow as before, although the traversal speed may not be terribly important when the execution time for the other coroutine is added in. Still another alternative is to keep the stack links within the tree itself in a tricky way, as discussed in <a href="../Text/ch02a.html#ch02ex_2_7_21">exercise 21</a>.</p>
<p class="indenti">iv) <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> is, of course, more general than <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>, since it allows us to go from <code>P</code> to <code>P</code>$ when we are not necessarily traversing the entire binary tree.</p>
<p class="indent">So a threaded binary tree is decidedly superior to an unthreaded one, with respect to traversal. These advantages are offset in some applications by the slightly increased time needed to insert and delete nodes in a threaded tree. It is also sometimes possible to save memory space by “sharing” common subtrees with an unthreaded representation, while threaded trees require adherence to a strict tree structure with no overlapping of subtrees.</p>
<p class="indent">Thread links can also be used to compute <code>P</code>*, $<code>P</code>, and #<code>P</code> with efficiency comparable to that of <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a>. The functions *<code>P</code> and <code>P</code># are slightly harder <a id="page_327"></a>to compute, just as they are for unthreaded tree representations. The reader is urged to work <a href="../Text/ch02a.html#ch02ex_2_7_17">exercise 17</a>.</p>
<p class="indent">Most of the usefulness of threaded trees would disappear if it were hard to set up the thread links in the first place. What makes the idea really work is that threaded trees grow almost as easily as ordinary ones do. We have the following algorithm:</p>
<p class="noindent"><a id="ch02alg-lev2sec7-I"></a><strong>Algorithm I</strong> (<em>Insertion into a threaded binary tree</em>). This algorithm attaches a single node, <code>NODE(Q)</code>, as the right subtree of <code>NODE(P)</code>, if the right subtree is empty (that is, if <code>RTAG(P)</code> = 1); otherwise it inserts <code>NODE(Q)</code> between <code>NODE(P)</code> and <code>NODE(RLINK(P))</code>, making the latter node the right child of <code>NODE(Q)</code>. The binary tree in which the insertion takes place is assumed to be threaded as in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-10">10</a>); for a modification, see <a href="../Text/ch02a.html#ch02ex_2_7_23">exercise 23</a>.</p>
<p class="indenthanging"><strong>I1.</strong> [Adjust tags and links.] Set <code>RLINK(Q)</code> ← <code>RLINK(P)</code>, <code>RTAG(Q)</code> ← <code>RTAG(P)</code>, <code>RLINK(P)</code> ← <code>Q</code>, <code>RTAG(P)</code> ← 0, <code>LLINK(Q)</code> ← <code>P</code>, <code>LTAG(Q)</code> ← 1.</p>
<p class="indenthanging"><strong>I2.</strong> [Was <code>RLINK(P)</code> a thread?] If <code>RTAG(Q)</code> = 0, set <code>LLINK(Q$)</code> ← <code>Q</code>. (Here <code>Q$</code> is determined by <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a>, which will work properly even though <code>LLINK(Q$)</code> now points to <code>NODE(P)</code> instead of <code>NODE(Q)</code>. This step is necessary only when inserting into the midst of a threaded tree instead of merely inserting a new leaf.) <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">By reversing the roles of left and right (in particular, by replacing <code>Q$</code> by <code>$Q</code> in step I2), we obtain an algorithm that inserts to the left in a similar way.</p>
<p class="indent">Our discussion of threaded binary trees so far has made use of thread links both to the left and to the right. There is an important middle ground between the completely unthreaded and completely threaded methods of representation: A <em>right-threaded binary tree</em> combines the two approaches by making use of threaded <code>RLINK</code><small>s</small>, while representing empty left subtrees by <code>LLINK</code> = <em>Λ</em>. (Similarly, a left-threaded binary tree threads only the null <code>LLINK</code><small>s</small>.) <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> does not make essential use of threaded <code>LLINK</code><small>s</small>; if we change the test “<code>LTAG</code> = 0” in step S2 to “<code>LLINK</code> ≠ <em>Λ</em>”, we obtain an algorithm for traversing right-threaded binary trees in symmetric order. <a href="../Text/ch02a.html#ch02a_pro_s">Program S</a> works without change in the rightthreaded case. A great many applications of binary tree structures require only a left-to-right traversal of trees using the functions <code>P$</code> and/or <code>P*</code>, and for these applications there is no need to thread the <code>LLINK</code><small>s</small>. We have described threading in both the left and right directions in order to indicate the symmetry and possibilities of the situation, but in practice one-sided threading is much more common.</p>
<p class="indent">Let us now consider an important property of binary trees, and its connection to traversal. Two binary trees <em>T</em> and <em>T</em> ′ are said to be <em>similar</em> if they have the same structure; formally, this means that (a) they are both empty, or (b) they are both nonempty and their left and right subtrees are respectively similar. Similarity means, informally, that the diagrams of <em>T</em> and <em>T</em>′ have the same “shape.” Another way to phrase similarity is to say that there is a one-to-one correspondence between the nodes of <em>T</em> and <em>T</em>′ that preserves the structure:</p>
<p class="noindent"><a id="page_328"></a>If nodes <em>u</em><sub>1</sub> and <em>u</em><sub>2</sub> in <em>T</em> correspond respectively to <span class="middle"><img src="../Images/ch02/e328_01.jpg"></span> and <span class="middle"><img src="../Images/ch02/e328_02.jpg"></span> in <em>T</em> ′, then <em>u</em><sub>1</sub> is in the left subtree of <em>u</em><sub>2</sub> if and only if <span class="middle"><img src="../Images/ch02/e328_03.jpg"></span> is in the left subtree of <span class="middle"><img src="../Images/ch02/e328_04.jpg"></span>, and the same is true for right subtrees.</p>
<p class="indent">The binary trees <em>T</em> and <em>T</em>′ are said to be <em>equivalent</em> if they are similar and if corresponding nodes contain the same information. Formally, let info(<em>u</em>) denote the information contained in a node <em>u</em>; the trees are equivalent if and only if (a) they are both empty, or (b) they are both nonempty and info(root(<em>T</em>)) = info(root(<em>T</em>′)) and their left and right subtrees are respectively equivalent.</p>
<p class="indent">As examples of these definitions, consider the four binary trees</p>
<div class="image"><img src="../Images/ch02/e328_05.jpg"></div>
<p class="noindent">in which the first two are dissimilar. The second, third, and fourth are similar and, in fact, the second and fourth are equivalent.</p>
<p class="indent">Some computer applications involving tree structures require an algorithm to decide whether two binary trees are similar or equivalent. The following theorem is useful in this regard:</p>
<p class="noindent"><a id="ch02a_the_a"></a><strong>Theorem A.</strong> <em>Let the nodes of binary trees T and T′ be respectively</em></p>
<div class="image"><img src="../Images/ch02/e328_06.jpg"></div>
<p class="noindent"><em>in preorder. For any node <em>u</em> let</em></p>
<div class="equation"><a id="ch02eq-lev2sec7-11"></a><img src="../Images/ch02/328equ01.jpg"></div>
<p class="noindent"><em>Then <em>T</em> and <em>T</em>′ are similar if and only if n = n′ and</em></p>
<div class="equation"><a id="ch02eq-lev2sec7-12"></a><img src="../Images/ch02/328equ02.jpg"></div>
<p class="noindent"><em>Moreover, <em>T</em> and <em>T</em>′ are equivalent if and only if in addition we have</em></p>
<div class="equation"><a id="ch02eq-lev2sec7-13"></a><img src="../Images/ch02/328equ03.jpg"></div>
<p class="indent">Notice that <em>l</em> and <em>r</em> are the complements of the <code>LTAG</code> and <code>RTAG</code> bits in a threaded tree. This theorem characterizes any binary tree structure in terms of two sequences of 0s and 1s.</p>
<p class="noindent"><em>Proof.</em> It is clear that the condition for equivalence of binary trees will follow immediately if we prove the condition for similarity; furthermore the conditions <em>n</em> = <em>n</em>′ and (<a href="../Text/ch02a.html#ch02eq-lev2sec7-12">12</a>) are certainly necessary, since corresponding nodes of similar trees must have the same position in preorder. Therefore it suffices to prove that the conditions (<a href="../Text/ch02a.html#ch02eq-lev2sec7-12">12</a>) and <em>n</em> = <em>n</em>′ are sufficient to guarantee the similarity of <em>T</em> and <em>T</em> ′. The proof is by induction on <em>n</em>, using the following auxiliary result:</p>
<p class="noindent"><a id="ch02aLemma-p"></a><a id="page_329"></a><strong>Lemma P.</strong> <em>Let the nodes of a nonempty binary tree be u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ..., <em>u</em><sub><em>n</em></sub><em>in preorder, and let f</em>(<em>u</em>) = <em>l</em>(<em>u</em>) + <em>r</em>(<em>u</em>) − 1. Then</p>
<div class="equation"><a id="ch02eq-lev2sec7-14"></a><img src="../Images/ch02/329equ01.jpg"></div>
<p class="noindent"><em>Proof</em>. The result is clear for <em>n</em> = 1. If <em>n</em> &gt; 1, the binary tree consists of its root <em>u</em><sub>1</sub> and further nodes. If <em>f</em> (<em>u</em><sub>1</sub>) = 0, then either the left subtree or the right subtree is empty, so the condition is obviously true by induction. If <em>f</em> (<em>u</em><sub>1</sub>) = 1, let the left subtree have <em>n</em><sub><em>l</em></sub> nodes; by induction we have</p>
<div class="equation"><a id="ch02eq-lev2sec7-15"></a><img src="../Images/ch02/329equ02.jpg"></div>
<p class="noindent">and the condition (<a href="../Text/ch02a.html#ch02eq-lev2sec7-14">14</a>) is again evident. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">(For other theorems analogous to Lemma P, see the discussion of Polish notation in Chapter 10.)</p>
<p class="indent">To complete the proof of <a href="../Text/ch02a.html#ch02a_the_a">Theorem A</a>, we note that the theorem is clearly true when <em>n</em> = 0. If <em>n</em> &gt; 0, the definition of preorder implies that <em>u</em><sub>1</sub> and <span class="middle"><img src="../Images/ch02/e328_01.jpg"></span> are the respective roots of their trees, and there are integers <em>n</em><sub><em>l</em></sub> and <span class="middle"><img src="../Images/ch02/e329_02.jpg"></span> (the sizes of the left subtrees) such that</p>
<div class="image"><img src="../Images/ch02/e329_03.jpg"></div>
<p class="indent">The proof by induction will be complete if we can show <em>n</em><sub><em>l</em></sub> = <span class="middle"><img src="../Images/ch02/e329_02.jpg"></span>. There are three cases:</p>
<p class="indent">if <em>l</em>(<em>u</em><sub>1</sub>) = 0, then <em>n</em><sub>l</sub> = 0 = <span class="middle"><img src="../Images/ch02/e329_02.jpg"></span>;</p>
<p class="indent">if <em>l</em>(<em>u</em><sub>1</sub>) = 1, <em>r</em>(<em>u</em><sub>1</sub>) = 0, then <em>n</em><sub><em>l</em></sub> = <em>n</em> − 1 = <span class="middle"><img src="../Images/ch02/e329_02.jpg"></span>;</p>
<p class="indent">if <em>l</em>(<em>u</em><sub>1</sub>) = <em>r</em>(<em>u</em><sub>1</sub>) = 1, then by Lemma P we can find the least <em>k</em> &gt; 0 such that <em>f</em> (<em>u</em><sub>1</sub>) + · · · + <em>f</em> (<em>u</em><sub><em>k</em></sub>) = 0; and <em>n</em><sub>l</sub> = <em>k</em> − 1 = <span class="middle"><img src="../Images/ch02/e329_02.jpg"></span> (see (<a href="../Text/ch02a.html#ch02eq-lev2sec7-15">15</a>)). <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">As a consequence of <a href="../Text/ch02a.html#ch02a_the_a">Theorem A</a>, we can test two threaded binary trees for equivalence or similarity by simply traversing them in preorder and checking the <code>INFO</code> and <code>TAG</code> fields. Some interesting extensions of <a href="../Text/ch02a.html#ch02a_the_a">Theorem A</a> have been obtained by A. J. Blikle, <em>Bull. de l’Acad. Polonaise des Sciences</em>, Série des Sciences Math., Astr., Phys., <strong>14</strong> (1966), 203–208; he considered an infinite class of possible traversal orders, only six of which (including preorder) were called “addressless” because of their simple properties.</p>
<p class="indent">We conclude this section by giving a typical, yet basic, algorithm for binary trees, one that makes a copy of a binary tree into different memory locations.</p>
<p class="noindent"><a id="ch02alg-lev2sec7-C"></a><strong>Algorithm C</strong> (<em>Copy a binary tree</em>). Let <code>HEAD</code> be the address of the list head of a binary tree <em>T</em>; thus, <em>T</em> is the left subtree of <code>HEAD</code>, reached via <code>LLINK(HEAD)</code>. Let <code>NODE(U)</code> be a node with an empty left subtree. This algorithm makes a copy of <em>T</em> and the copy becomes the left subtree of <code>NODE(U)</code>. In particular, if <code>NODE(U)</code> is the list head of an empty binary tree, this algorithm changes the empty tree into a copy of <em>T</em>.</p>
<p class="indenthanging"><strong>C1.</strong> [Initialize.] Set <code>P</code> ← <code>HEAD</code>, <code>Q</code> ← <code>U</code>. Go to C4.</p>
<p class="indenthanging"><a id="page_330"></a><strong>C2.</strong> [Anything to right?] If <code>NODE(P)</code> has a nonempty right subtree, set <code>R</code> <span class="ent">⇐</span> <code>AVAIL</code>, and attach <code>NODE(R)</code> to the right of <code>NODE(Q)</code>. (At the beginning of step C2, the right subtree of <code>NODE(Q)</code> was empty.)</p>
<p class="indenthanging"><strong>C3.</strong> [Copy <code>INFO</code>.] Set <code>INFO(Q)</code> ← <code>INFO(P)</code>. (Here <code>INFO</code> denotes all parts of the node that are to be copied, except for the links.)</p>
<p class="indenthanging"><strong>C4.</strong> [Anything to left?] If <code>NODE(P)</code> has a nonempty left subtree, set <code>R</code> <span class="ent">⇐</span> <code>AVAIL</code>, and attach <code>NODE(R)</code> to the left of <code>NODE(Q)</code>. (At the beginning of step C4, the left subtree of <code>NODE(Q)</code> was empty.)</p>
<p class="indenthanging"><strong>C5.</strong> [Advance.] Set <code>P</code> ← <code>P*</code>, <code>Q</code> ← <code>Q*</code>.</p>
<p class="indenthanging"><strong>C6.</strong> [Test if complete.] If <code>P</code> = <code>HEAD</code> (or equivalently if <code>Q</code> = <code>RLINK(U)</code>, assuming that <code>NODE(U)</code> has a nonempty right subtree), the algorithm terminates; otherwise go to step C2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">This simple algorithm shows a typical application of tree traversal. The description here applies to threaded, unthreaded, or partially threaded trees. Step C5 requires the calculation of preorder successors <code>P*</code> and <code>Q*</code>; for unthreaded trees, this generally is done with an auxiliary stack. A proof of the validity of <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> appears in <a href="../Text/ch02a.html#ch02ex_2_7_29">exercise 29</a>; a <code>MIX</code> program corresponding to this algorithm in the case of a right-threaded binary tree appears in <a href="../Text/ch02a.html#ch02ex_2_8_13">exercise 2.3.2–13</a>. For threaded trees, the “attaching” in steps C2 and C4 is done using <a href="../Text/ch02a.html#ch02alg-lev2sec7-I">Algorithm I</a>.</p>
<p class="indent">The exercises that follow include quite a few topics of interest relating to the material of this section.</p>
<p class="blockquote"><span class="roman_italic">Binary or dichotomous systems, although regulated by a principle,<br>are among the most artificial arrangements<br>that have ever been invented.</span></p>
<p class="attribution">— WILLIAM SWAINSON, <span class="roman_italic">A Treatise on the Geography and<br>Classification of Animals</span> (1835)</p>
<p class="ex-title">Exercises</p>
<p class="exercises"><strong><a id="ch02ex_2_7_1" href="../Text/app01b.html#ch02ex_2_7_1a">1</a>.</strong> [<em>01</em>] In the binary tree (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), let <code>INFO(P)</code> denote the letter stored in <code>NODE(P)</code>. What is <code>INFO(LLINK(RLINK(RLINK(T))))</code>?</p>
<p class="exercises"><strong><a id="ch02ex_2_7_2" href="../Text/app01b.html#ch02ex_2_7_2a">2</a>.</strong> [<em>11</em>] List the nodes of the binary tree <span class="middle"><img src="../Images/ch02/e330_01.jpg"></span> in (a) preorder; (b) symmetric order; (c) postorder.</p>
<p class="exercises"><strong><a id="ch02ex_2_7_3" href="../Text/app01b.html#ch02ex_2_7_3a">3</a>.</strong> [<em>20</em>] Is the following statement true or false? “The terminal nodes of a binary tree occur in the same relative position in preorder, inorder, and postorder.”</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_4" href="../Text/app01b.html#ch02ex_2_7_4a">4</a>.</strong> [<em>20</em>] The text defines three basic orders for traversing a binary tree; another alternative would be to proceed in three steps as follows:</p>
<p class="indenthangingA">a) Visit the root,</p>
<p class="indenthangingA">b) traverse the right subtree,</p>
<p class="indenthangingA">c) traverse the left subtree,</p>
<p class="exercisesp">using the same rule recursively on all nonempty subtrees. Does this new order bear any simple relation to the three orders already discussed?</p>
<p class="exercises"><a id="page_331"></a><strong><a id="ch02ex_2_7_5" href="../Text/app01b.html#ch02ex_2_7_5a">5</a>.</strong> [<em>22</em>] The nodes of a binary tree may be identified by a sequence of zeros and ones, in a notation analogous to “Dewey decimal notation” for trees, as follows: The root (if present) is represented by the sequence “1”. Roots (if present) of the left and right subtrees of the node represented by α are respectively represented by α0 and α1. For example, the node <em>H</em> in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>) would have the representation “1110”. (See <a href="../Text/ch02a.html#ch02ex_1_3_15">exercise 2.3–15</a>.)</p>
<p class="exercises1N">Show that preorder, inorder, and postorder can be described conveniently in terms of this notation.</p>
<p class="exercises"><strong><a id="ch02ex_2_7_6" href="../Text/app01b.html#ch02ex_2_7_6a">6</a>.</strong> [<em>M22</em>] Suppose that a binary tree has <em>n</em> nodes that are <em>u</em><sub>1</sub><em>u</em><sub>2</sub> ... <em>u</em><sub><em>n</em></sub> in preorder and <em>u</em><sub><em>p</em><sub>1</sub></sub><em>u</em><sub><em>p</em><sub>2</sub></sub> ... <em>u</em><sub><em>p</em><sub><em>n</em></sub></sub> in inorder. Show that the permutation <em>p</em><sub>1</sub><em>p</em><sub>2</sub> ... <em>p</em><sub><em>n</em></sub> can be obtained by passing 12 ... <em>n</em> through a stack, in the sense of <a href="../Text/ch02.html#ch02lev2sec1">exercise 2.2.1</a>–<a href="../Text/ch02.html#ch02ex_2_1_2">2</a>. Conversely, show that any permutation <em>p</em><sub>1</sub><em>p</em><sub>2</sub> ... <em>p</em><sub><em>n</em></sub> obtainable with a stack corresponds to some binary tree in this way.</p>
<p class="exercises"><strong><a id="ch02ex_2_7_7" href="../Text/app01b.html#ch02ex_2_7_7a">7</a>.</strong> [<em>22</em>] Show that if we are given the preorder and the inorder of the nodes of a binary tree, the binary tree structure may be constructed. (Assume that the nodes are distinct.) Does the same result hold true if we are given the preorder and postorder, instead of preorder and inorder? Or if we are given the inorder and postorder?</p>
<p class="exercises"><strong><a id="ch02ex_2_7_8" href="../Text/app01b.html#ch02ex_2_7_8a">8</a>.</strong> [<em>20</em>] Find all binary trees whose nodes appear in exactly the same sequence in both (a) preorder and inorder; (b) preorder and postorder; (c) inorder and postorder. (As in the previous exercise, we assume that the nodes have distinct labels.)</p>
<p class="exercises"><strong><a id="ch02ex_2_7_9" href="../Text/app01b.html#ch02ex_2_7_9a">9</a>.</strong> [<em>M20</em>] When a binary tree having <em>n</em> nodes is traversed using <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>, state how many times each of steps T1, T2, T3, T4, and T5 is performed (as a function of <em>n</em>).</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_10" href="../Text/app01b.html#ch02ex_2_7_10a">10</a>.</strong> [<em>20</em>] What is the largest number of entries that can be in the stack at once, during the execution of <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>, if the binary tree has <em>n</em> nodes? (The answer to this question is very important for storage allocation, if the stack is being stored consecutively.)</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_11" href="../Text/app01b.html#ch02ex_2_7_11a">11</a>.</strong> [<em>HM41</em>] Analyze the <em>average</em> value of the largest stack size occurring during the execution of <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> as a function of <em>n</em>, given that all binary trees with <em>n</em> nodes are considered equally probable.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_12" href="../Text/app01b.html#ch02ex_2_7_12a">12</a>.</strong> [<em>22</em>] Design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> that traverses a binary tree in <em>preorder</em>, and prove that your algorithm is correct.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_13" href="../Text/app01b.html#ch02ex_2_7_13a">13</a>.</strong> [<em>24</em>] Design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> that traverses a binary tree in <em>postorder</em>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_14" href="../Text/app01b.html#ch02ex_2_7_14a">14</a>.</strong> [<em>20</em>] Show that if a binary tree with <em>n</em> nodes is represented as in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), the total number of <em>Λ</em> links in the representation can be expressed as a simple function of <em>n</em>; this quantity does not depend on the shape of the tree.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_15" href="../Text/app01b.html#ch02ex_2_7_15a">15</a>.</strong> [<em>15</em>] In a threaded-tree representation like (<a href="../Text/ch02a.html#ch02eq-lev2sec7-10">10</a>), each node except the list head has exactly one link pointing to it from above, namely the link from its parent. Some of the nodes also have links pointing to them from below; for example, the node containing <em>C</em> has two pointers coming up from below, while node <em>E</em> has just one. Is there any simple connection between the number of links pointing to a node and some other basic property of that node? (We need to know how many links point to a given node when we are changing the tree structure.)</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_16" href="../Text/app01b.html#ch02ex_2_7_16a">16</a>.</strong> [<em>22</em>] The diagrams in <a href="../Text/ch02a.html#ch02fig24">Fig. 24</a> help to provide an intuitive characterization of the position of <code>NODE(Q$)</code> in a binary tree, in terms of the structure near <code>NODE(Q)</code>: If <code>NODE(Q)</code> has a nonempty right subtree, consider <code>Q</code> = <code>$P</code>, <code>Q$</code> = <code>P</code> in the upper diagrams; <code>NODE(Q$)</code> <a id="page_332"></a>is the “leftmost” node of that right subtree. If <code>NODE(Q)</code> has an empty right subtree, consider <code>Q</code> = <code>P</code> in the lower diagrams; <code>NODE(Q$)</code> is located by proceeding upward in the tree until after the first upward step to the right.</p>
<p class="indent">Give a similar “intuitive” rule for finding the position of <code>NODE(Q*)</code> in a binary tree in terms of the structure near <code>NODE(Q)</code>.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_17" href="../Text/app01b.html#ch02ex_2_7_17a">17</a>.</strong> [<em>22</em>] Give an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> for determining <code>P</code>* in a threaded binary tree. Assume that the tree has a list head as in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-8">8</a>), (<a href="../Text/ch02a.html#ch02eq-lev2sec7-9">9</a>), and (<a href="../Text/ch02a.html#ch02eq-lev2sec7-10">10</a>).</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_18" href="../Text/app01b.html#ch02ex_2_7_18a">18</a>.</strong> [<em>24</em>] Many algorithms dealing with trees like to visit each node <em>twice</em> instead of once, using a combination of preorder and inorder that we might call <em>double order</em>. Traversal of a binary tree in double order is defined as follows: If the binary tree is empty, do nothing; otherwise</p>
<p class="indenthangingA">a) visit the root, for the first time;</p>
<p class="indenthangingA">b) traverse the left subtree, in double order;</p>
<p class="indenthangingA">c) visit the root, for the second time;</p>
<p class="indenthangingA">d) traverse the right subtree, in double order.</p>
<p class="noindent">For example, traversal of (<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>) in double order gives the sequence</p>
<p class="center"><em>A</em><sub>1</sub><em>B</em><sub>1</sub><em>D</em><sub>1</sub><em>D</em><sub>2</sub><em>B</em><sub>2</sub><em>A</em><sub>2</sub><em>C</em><sub>1</sub><em>E</em><sub>1</sub><em>E</em><sub>2</sub><em>G</em><sub>1</sub><em>G</em><sub>2</sub><em>C</em><sub>2</sub><em>F</em><sub>1</sub><em>H</em><sub>1</sub><em>H</em><sub>2</sub><em>F</em><sub>2</sub><em>J</em><sub>1</sub><em>J</em><sub>2</sub>,</p>
<p class="noindent">where <em>A</em><sub>1</sub> means that <em>A</em> is being visited for the first time.</p>
<p class="indent">If <code>P</code> points to a node of the tree and if <em>d</em> = 1 or 2, define (<code>P</code><em>, d</em>)<em><sup>Δ</sup></em> = (<code>Q</code><em>, e</em>) if the next step in double order after visiting <code>NODE(P)</code> the <em>d</em>th time is to visit <code>NODE(Q)</code> the <em>e</em>th time; or, if (<code>P</code><em>, d</em>) is the last step in double order, we write (<code>P</code><em>, d</em>)<em><sup>Δ</sup></em> = (<code>HEAD</code><em>,</em> 2), where <code>HEAD</code> is the address of the list head. We also define (<code>HEAD</code><em>,</em> 1)<em><sup>Δ</sup></em> as the first step in double order.</p>
<p class="indent">Design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> that traverses a binary tree in double order, and also design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> that computes (<code>P</code><em>, d</em>)<sup>Δ</sup>. Discuss the relation between these algorithms and <a href="../Text/ch02a.html#ch02ex_2_7_12">exercises 12</a> and <a href="../Text/ch02a.html#ch02ex_2_7_17">17</a>.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_19" href="../Text/app01b.html#ch02ex_2_7_19a">19</a>.</strong> [<em>27</em>] Design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> for the calculation of <code>P#</code> in (a) a right-threaded binary tree; (b) a fully threaded binary tree. If possible, the average running time of your algorithm should be at most a small constant, when <code>P</code> is a random node of the tree.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_20" href="../Text/app01b.html#ch02ex_2_7_20a">20</a>.</strong> [<em>23</em>] Modify <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> so that it keeps the stack in a linked list, not in consecutive memory locations.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_21" href="../Text/app01b.html#ch02ex_2_7_21a">21</a>.</strong> [<em>33</em>] Design an algorithm that traverses an unthreaded binary tree in inorder <em>without using any auxiliary stack</em>. It is permissible to alter the <code>LLINK</code> and <code>RLINK</code> fields of the tree nodes in any manner whatsoever during the traversal, subject only to the condition that the binary tree should have the conventional representation illustrated in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) both before and after your algorithm has traversed the tree. No other bits in the tree nodes are available for temporary storage.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_22" href="../Text/app01b.html#ch02ex_2_7_22a">22</a>.</strong> [<em>25</em>] Write a <code>MIX</code> program for the algorithm given in <a href="../Text/ch02a.html#ch02ex_2_7_21">exercise 21</a> and compare its execution time to <a href="../Text/ch02a.html#ch02a_pro_s">Programs S</a> and <a href="../Text/ch02a.html#ch02a_pro_t">T</a>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_23" href="../Text/app01b.html#ch02ex_2_7_23a">23</a>.</strong> [<em>22</em>] Design algorithms analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec7-I">Algorithm I</a> for insertion to the right and insertion to the left in a <em>right-threaded</em> binary tree. Assume that the nodes have the fields <code>LLINK</code>, <code>RLINK</code>, and <code>RTAG</code>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_24" href="../Text/app01b.html#ch02ex_2_7_24a">24</a>.</strong> [<em>M20</em>] Is <a href="../Text/ch02a.html#ch02a_the_a">Theorem A</a> still valid if the nodes of <em>T</em> and <em>T</em>′ are given in symmetric order instead of preorder?</p>
<p class="exercises1"><a id="page_333"></a><strong><a id="ch02ex_2_7_25" href="../Text/app01b.html#ch02ex_2_7_25a">25</a>.</strong> [<em>M24</em>] Let <em>τ</em> be a set of binary trees in which the value of each info field belongs to a given set <em>S</em>, where <em>S</em> is linearly ordered by a relation “<span class="ent">≼</span>” (see <a href="../Text/ch02.html#ch02lev2sec3">exercise 2.2.3</a>–<a href="../Text/ch02.html#ch02ex_2_3_5">14</a>). Given any trees <em>T</em>, <em>T</em> ′ in <em>τ</em>, let us now define <em>T</em> <span class="ent">≼</span> <em>T</em> ′ if and only if</p>
<p class="indenti">i) <em>T</em> is empty; or</p>
<p class="indenti">ii) <em>T</em> and <em>T</em> ′ are not empty, and info(root(<em>T</em>)) <span class="ent">≺</span> info(root(<em>T</em> ′)); or</p>
<p class="indenti">iii) <em>T</em> and <em>T</em> ′ are not empty, info(root(<em>T</em>)) = info(root(<em>T</em> ′)), left(<em>T</em>) <span class="ent">≼</span> left(<em>T</em> ′), and left(<em>T</em>) is not equivalent to left(<em>T</em> ′); or</p>
<p class="indenti">iv) <em>T</em> and <em>T</em> ′ are not empty, info(root(<em>T</em>)) = info(root(<em>T</em> ′)), left(<em>T</em>) is equivalent to left(<em>T</em> ′), and right(<em>T</em>) <span class="ent">≼</span> right(<em>T</em> ′).</p>
<p class="exercisesp">Here left(<em>T</em>) and right(<em>T</em>) denote the left and right subtrees of <em>T</em> . Prove that (a) <em>T</em> <span class="ent">≼</span> <em>T</em>′ and <em>T</em>′ <span class="ent">≼</span> <em>T</em><sup>′′</sup> implies <em>T</em> <span class="ent">≼</span> <em>T</em><sup>′′</sup>; (b) <em>T</em> is equivalent to <em>T</em>′ if and only if <em>T</em> <span class="ent">≼</span> <em>T</em>′ and <em>T</em>′ <span class="ent">≼</span> <em>T</em>; (c) for any <em>T</em>, <em>T</em>′ in <em>T</em> we have either <em>T</em> <span class="ent">≼</span> <em>T</em>′ or <em>T</em>′ <span class="ent">≼</span> <em>T</em> . [Thus, if equivalent trees in <em>τ</em> are regarded as equal, the relation <span class="ent">≼</span> induces a linear ordering on <em>τ</em> . This ordering has many applications (for example, in the simplification of algebraic expressions). When <em>S</em> has only one element, so that the “info” of each node is the same, we have the special case that equivalence is the same as similarity.]</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_26" href="../Text/app01b.html#ch02ex_2_7_26a">26</a>.</strong> [<em>M24</em>] Consider the ordering <em>T</em> <span class="ent">≼</span> <em>T</em>′ defined in the preceding exercise. Prove a theorem analogous to <a href="../Text/ch02a.html#ch02a_the_a">Theorem A</a>, giving a necessary and sufficient condition that <em>T</em> <span class="ent">≼</span> <em>T</em>′, and making use of double order as defined in <a href="../Text/ch02a.html#ch02ex_2_7_18">exercise 18</a>.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_27" href="../Text/app01b.html#ch02ex_2_7_27a">27</a>.</strong> [<em>28</em>] Design an algorithm that tests two given trees <em>T</em> and <em>T</em>′ to see whether <em>T</em> <span class="ent">≺</span> <em>T</em>′, <em>T</em> <span class="ent">≻</span> <em>T</em>′, or <em>T</em> is equivalent to <em>T</em>′, in terms of the relation defined in <a href="../Text/ch02a.html#ch02ex_2_7_25">exercise 25</a>, assuming that both binary trees are right-threaded. Assume that each node has the fields <code>LLINK</code>, <code>RLINK</code>, <code>RTAG</code>, <code>INFO</code>; use no auxiliary stack.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_28" href="../Text/app01b.html#ch02ex_2_7_28a">28</a>.</strong> [<em>00</em>] After <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> has been used to make a copy of a tree, is the new binary tree <em>equivalent</em> to the original, or <em>similar</em> to it?</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_29" href="../Text/app01b.html#ch02ex_2_7_29a">29</a>.</strong> [<em>M25</em>] Prove as rigorously as possible that <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> is valid.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_30" href="../Text/app01b.html#ch02ex_2_7_30a">30</a>.</strong> [<em>22</em>] Design an algorithm that threads an unthreaded tree; for example, it should transform (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) into (<a href="../Text/ch02a.html#ch02eq-lev2sec7-10">10</a>). <em>Note:</em> Always use notations like <code>P*</code> and <code>P$</code> when possible, instead of repeating the steps for traversal algorithms like <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_31" href="../Text/app01b.html#ch02ex_2_7_31a">31</a>.</strong> [<em>23</em>] Design an algorithm that “erases” a right-threaded binary tree. Your algorithm should return all of the tree nodes except the list head to the <code>AVAIL</code> list, and it should make the list head signify an empty binary tree. Assume that each node has the fields <code>LLINK</code>, <code>RLINK</code>, <code>RTAG</code>; use no auxiliary stack.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_32" href="../Text/app01b.html#ch02ex_2_7_32a">32</a>.</strong> [<em>21</em>] Suppose that each node of a binary tree has four link fields: <code>LLINK</code> and <code>RLINK</code>, which point to left and right subtrees or <em>Λ</em>, as in an unthreaded tree; <code>SUC</code> and <code>PRED</code>, which point to the successor and predecessor of the node in symmetric order. (Thus <code>SUC(P)</code> = <code>P$</code> and <code>PRED(P)</code> = <code>$P</code>. Such a tree contains more information than a threaded tree.) Design an algorithm like <a href="../Text/ch02a.html#ch02alg-lev2sec7-I">Algorithm I</a> for insertion into such a tree.</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_33" href="../Text/app01b.html#ch02ex_2_7_33a">33</a>.</strong> [<em>30</em>] There is more than one way to thread a tree! Consider the following representation, using three fields <code>LTAG, LLINK, RLINK</code> in each node:</p>
<p class="indent"><code>LTAG(P)</code>: defined the same as in a threaded binary tree;</p>
<p class="indent"><code>LLINK(P)</code>: always equal to <code>P*</code>;</p>
<p class="indent"><code>RLINK(P)</code>: defined the same as in an unthreaded binary tree.</p>
<p class="exercisesp">Discuss insertion algorithms for such a representation, and write out the copying algorithm, <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a>, in detail for this representation.</p>
<p class="exercises1"><a id="page_334"></a><strong><a id="ch02ex_2_7_34" href="../Text/app01b.html#ch02ex_2_7_34a">34</a>.</strong> [<em>22</em>] Let <code>P</code> point to a node in some binary tree, and let <code>HEAD</code> point to the list head of an empty binary tree. Give an algorithm that (i) removes <code>NODE(P)</code> and all of its subtrees from whatever tree it was in, and then (ii) attaches <code>NODE(P)</code> and its subtrees to <code>NODE(HEAD)</code>. Assume that all the binary trees in question are right-threaded, with fields <code>LLINK, RTAG, RLINK</code> in each node.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_35"></a>35.</strong> [<em>40</em>] Define a <em>ternary tree</em> (and, more generally, a <em>t</em>-ary tree for any <em>t</em> ≥ 2) in a manner analogous to our definition of a binary tree, and explore the topics discussed in this section (including topics found in the exercises above) that can be generalized to <em>t</em>-ary trees in a meaningful way.</p>
<p class="exercises1"><strong><a id="ch02ex_2_7_36" href="../Text/app01b.html#ch02ex_2_7_36a">36</a>.</strong> [<em>M23</em>] <a href="../Text/ch02a.html#ch02ex_2_7_2">Exercise 1.2.1–15</a> shows that lexicographic order extends a well-ordering of a set <em>S</em> to a well-ordering of the <em>n</em>-tuples of elements of <em>S</em>. <a href="../Text/ch02a.html#ch02ex_2_7_25">Exercise 25</a> above shows that a linear ordering of the information in tree nodes can be extended to a linear ordering of trees, using a similar definition. If the relation <span class="ent">≺</span> well-orders <em>S</em>, is the extended relation of <a href="../Text/ch02a.html#ch02ex_2_7_25">exercise 25</a> a well-ordering of <em>τ</em> ?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_7_37" href="../Text/app01b.html#ch02ex_2_7_37a">37</a>.</strong> [<em>24</em>] (D. Ferguson.) If two computer words are necessary to contain two link fields and an <code>INFO</code> field, representation (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) requires 2<em>n</em> words of memory for a tree with <em>n</em> nodes. Design a representation scheme for binary trees that uses less space, assuming that <em>one</em> link and an <code>INFO</code> field will fit in a single computer word.</p>
<div class="heading">
<h4 id="ch02lev2sec8">2.3.2. Binary Tree Representation of Trees</h4>
<p class="noindent">We turn now from binary trees to just plain trees. Let us recall the basic differences between trees and binary trees as we have defined them:</p>
</div>
<p class="indenthangingA">1) A tree always has a root node, so it is never empty; each node of a tree can have 0, 1, 2, 3, ... children.</p>
<p class="indenthangingA">2) A binary tree can be empty, and each of its nodes can have 0, 1, or 2 children; we distinguish between a “left” child and a “right” child.</p>
<p class="noindent">Recall also that a forest is an ordered set of zero or more trees. The subtrees immediately below any node of a tree form a forest.</p>
<p class="indent">There is a natural way to represent any forest as a binary tree. Consider the following forest of two trees:</p>
<div class="equation"><a id="ch02eq-lev2sec8-1"></a><img src="../Images/ch02/334equ01.jpg"></div>
<p class="noindent">The corresponding binary tree is obtained by linking together the children of each family and removing vertical links except from a parent to a first child:</p>
<div class="equation"><a id="ch02eq-lev2sec8-2"></a><img src="../Images/ch02/334equ02.jpg"></div>
<p class="noindent"><a id="page_335"></a>Then, tilt the diagram 45° clockwise and tweak it slightly, obtaining a binary tree:</p>
<div class="equation"><a id="ch02eq-lev2sec8-3"></a><img src="../Images/ch02/335equ01.jpg"></div>
<p class="noindent">Conversely, it is easy to see that any binary tree corresponds to a unique forest of trees by reversing the process.</p>
<p class="indent">The transformation from (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) to (<a href="../Text/ch02a.html#ch02eq-lev2sec8-3">3</a>) is extremely important; it is called the <em>natural correspondence</em> between forests and binary trees. In particular, it gives a correspondence between trees and a special class of binary trees, namely the binary trees that have a root but no right subtree. (We might also change our viewpoint slightly and let the root of a tree correspond to the list head of a binary tree, thus obtaining a one-to-one correspondence between trees with <em>n</em> + 1 nodes and binary trees with <em>n</em> nodes.)</p>
<p class="indent">Let <em>F</em> = (<em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, ..., <em>T</em><sub><em>n</em></sub>) be a forest of trees. The binary tree <em>B</em>(<em>F</em>) corresponding to <em>F</em> can be defined rigorously as follows:</p>
<p class="indenthangingA">a) If <em>n</em> = 0, <em>B</em>(<em>F</em>) is empty.</p>
<p class="indenthangingA">b) If <em>n</em> &gt; 0, the root of <em>B</em>(<em>F</em>) is root(<em>T</em><sub>1</sub>); the left subtree of <em>B</em>(<em>F</em>) is <em>B</em>(<em>T</em><sub>11</sub>, <em>T</em><sub>12</sub>, ..., <em>T</em><sub>1<em>m</em></sub>), where <em>T</em><sub>11</sub>, <em>T</em><sub>12</sub>, ..., <em>T</em><sub>1<em>m</em></sub> are the subtrees of root(<em>T</em><sub>1</sub>); and the right subtree of B(F) is B(<em>T</em><sub>2</sub>, ..., <em>T</em><sub><em>n</em></sub>).</p>
<p class="noindent">These rules specify the transformation from (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) to (<a href="../Text/ch02a.html#ch02eq-lev2sec8-3">3</a>) precisely.</p>
<p class="indent">It will occasionally be convenient to draw our binary tree diagram as in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-2">2</a>), without the 45° rotation. The <em>threaded</em> binary tree corresponding to (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) is</p>
<div class="equation"><a id="ch02eq-lev2sec8-4"></a><img src="../Images/ch02/335equ02.jpg"></div>
<p class="noindent">(compare with <a href="../Text/ch02a.html#ch02fig24">Fig. 24</a>, giving the latter a 45° change in orientation). Notice that <em>right thread links go from the rightmost child of a family to the parent</em>.</p>
<p class="noindent"><a id="page_336"></a>Left thread links do not have such a natural interpretation, due to the lack of symmetry between left and right.</p>
<p class="indent">The ideas about traversal explored in the previous section can be recast in terms of forests (and, therefore, trees). There is no simple analog of the inorder sequence, since there is no obvious place to insert a root among its descendants; but preorder and postorder carry over in an obvious manner. Given any nonempty forest, the two basic ways to traverse it may be defined as follows:</p>
<div class="image"><img src="../Images/ch02/336tab01.jpg"></div>
<p class="indent">In order to understand the significance of these two methods of traversal, consider the following notation for expressing tree structure by nested parentheses:</p>
<div class="equation"><a id="ch02eq-lev2sec8-5"></a><img src="../Images/ch02/336equ01.jpg"></div>
<p class="noindent">This notation corresponds to the forest (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>): We represent a tree by the information written in its root, followed by a representation of its subtrees; we represent a nonempty forest by a parenthesized list of the representations of its trees, separated by commas.</p>
<p class="indent">If (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) is traversed in preorder, we visit the nodes in the sequence <em>A B C K D E H F J G</em>; this is simply (<a href="../Text/ch02a.html#ch02eq-lev2sec8-5">5</a>) with the parentheses and commas removed. Preorder is a natural way to list the nodes of a tree: We list the root first, then the descendants. If a tree structure is represented by indentation as in <a href="../Text/ch02a.html#ch02fig20">Fig. 20</a>(c), the rows appear in preorder. The section numbers of this book itself (see <a href="../Text/ch02a.html#ch02fig22">Fig. 22</a>) appear in preorder; thus, for example, <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a> is followed by <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a>, then come <a href="../Text/ch02a.html#ch02lev2sec8">Sections 2.3.2</a>, <a href="../Text/ch02a.html#ch02lev2sec9">2.3.3</a>, <a href="../Text/ch02b.html#ch02lev2sec10">2.3.4</a>, <a href="../Text/ch02b.html#ch02lev3sec1">2.3.4.1</a>, ..., <a href="../Text/ch02b.html#ch02lev3sec6">2.3.4.6</a>, <a href="../Text/ch02c.html#ch02lev2sec11">2.3.5</a>, <a href="../Text/ch02c.html#ch02lev1sec4">2.4</a>, etc.</p>
<p class="indent">It is interesting to note that preorder is a time-honored concept that might meaningfully be called <em>dynastic order</em>. At the death of a king, duke, or earl, the title passes to the first son, then to descendants of the first son, and finally if these all die out it passes to other sons of the family in the same way. (English custom also includes daughters in a family on the same basis as sons, except that they come after all the sons.) In theory, we could take a lineal chart of all the aristocracy and write out the nodes in preorder; then if we consider only the people presently living, we would obtain the <em>order of succession to the throne</em> (except as modified by Acts of Abdication).</p>
<p class="indent">Postorder for the nodes in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) is <em>B K C A H E J F G D</em>; this is analogous to preorder, except that it corresponds to the similar parenthesis notation</p>
<div class="equation"><a id="ch02eq-lev2sec8-6"></a><img src="../Images/ch02/336equ02.jpg"></div>
<p class="noindent">in which a node appears just <em>after</em> its descendants instead of just before.</p>
<p class="indent">The definitions of preorder and postorder mesh very nicely with the natural correspondence between trees and binary trees, since the subtrees of the first tree correspond to the left binary subtree, and the remaining trees correspond to the right binary subtree. By comparing these definitions with the corresponding <a id="page_337"></a>definitions on page <a href="../Text/ch02a.html#page_319">319</a>, we find that traversing a forest in preorder is <em>exactly the same</em> as traversing the corresponding binary tree in preorder. Traversing a forest in postorder is exactly the same as traversing the corresponding binary tree in <em>inorder</em>. The algorithms developed in <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a> may therefore be used without change. (Note that postorder for trees corresponds to inorder, <em>not</em> postorder, for binary trees. This is fortunate, since we have seen that it is comparatively hard to traverse binary trees in postorder.) Because of this equivalence, we use the notation <code>P$</code> for the <em>postorder</em> successor of node <code>P</code> in a tree or forest, while it denotes the <em>inorder</em> successor in a binary tree.</p>
<p class="indent">As an example of the application of these methods to a practical problem, we will consider the manipulation of algebraic formulas. Such formulas are most properly regarded as representations of tree structures, not as one-or two-dimensional configurations of symbols, nor even as binary trees. For example, the formula <em>y</em> = 3 ln(<em>x</em> + 1) − <em>a/x</em><sup>2</sup> has the tree representation</p>
<div class="equation"><a id="ch02eq-lev2sec8-7"></a><img src="../Images/ch02/337equ01.jpg"></div>
<p class="noindent">Here the illustration on the left is a conventional tree diagram like <a href="../Text/ch02a.html#ch02fig21">Fig. 21</a>, in which the binary operators +, −, ×, <em>/</em>, and ↑ (the latter denotes exponentiation) have two subtrees corresponding to their operands; the unary operator “ln” has one subtree; variables and constants are terminal nodes. The illustration on the right shows the equivalent right-threaded binary tree, including an additional node <em>y</em> that is a list head for the tree. The list head has the form described in <a href="../Text/ch02a.html#ch02lev2sec7">2.3.1</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec7-8">8</a>).</p>
<p class="indent">It is important to note that, even though the left-hand tree in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>) bears a superficial resemblance to a binary tree, we are treating it here as a <em>tree</em>, and representing it by a quite different binary tree, shown at the right in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>). Although we could develop routines for algebraic manipulations based directly on binary tree structures — the so-called “three-address code” representations of algebraic formulas — several simplifications occur in practice if we use the general tree representation of algebraic formulas, as in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>), because postorder traversal is easier in a tree.</p>
<p class="indent"><a id="page_338"></a>The nodes of the left-hand tree in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>) are</p>
<div class="equation"><a id="ch02eq-lev2sec8-8"></a><img src="../Images/ch02/338equ01.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-9"></a><img src="../Images/ch02/338equ02.jpg"></div>
<p class="noindent">Algebraic expressions like (<a href="../Text/ch02a.html#ch02eq-lev2sec8-8">8</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec8-9">9</a>) are very important, and they are known as “Polish notations” because form (<a href="../Text/ch02a.html#ch02eq-lev2sec8-8">8</a>) was introduced by the Polish logician, Jan Łukasiewicz. Expression (<a href="../Text/ch02a.html#ch02eq-lev2sec8-8">8</a>) is the <em>prefix notation</em> for formula (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>), and (<a href="../Text/ch02a.html#ch02eq-lev2sec8-9">9</a>) is the corresponding <em>postfix notation</em>. We will return to the interesting topic of Polish notation in later chapters; for now let us be content with the knowledge that Polish notation is directly related to the basic orders of tree traversal.</p>
<p class="noindent">We shall assume that tree structures for the algebraic formulas with which we will be dealing have nodes of the following form in <code>MIX</code> programs:</p>
<div class="equation"><a id="ch02eq-lev2sec8-10"></a><img src="../Images/ch02/338equ03.jpg"></div>
<p class="noindent">Here <code>RLINK</code> and <code>LLINK</code> have the usual significance, and <code>RTAG</code> is negative for thread links (corresponding to <code>RTAG</code> = 1 in the statements of algorithms). The <code>TYPE</code> field is used to distinguish different kinds of nodes: <code>TYPE</code> = 0 means that the node represents a constant, and <code>INFO</code> is the value of the constant. <code>TYPE</code> = 1 means that the node represents a variable, and <code>INFO</code> is the five-letter alphabetic name of this variable. <code>TYPE</code> ≥ 2 means that the node represents an operator; <code>INFO</code> is the alphabetic name of the operator and the value <code>TYPE</code> = 2, 3, 4, ... is used to distinguish the different operators +, −, ×, <em>/</em>, etc. We will not concern ourselves here with how the tree structure has been set up inside the computer memory in the first place, since this topic is analyzed in great detail in Chapter 10; let us merely assume that the tree already appears in our computer memory, deferring questions of input and output until later.</p>
<p class="indent">We shall now discuss the classical example of algebraic manipulation, finding the <em>derivative</em> of a formula with respect to the variable <em>x</em>. Programs for algebraic differentiation were among the first symbol-manipulation routines ever written for computers; they were used as early as 1952. The process of differentiation illustrates many of the techniques of algebraic manipulation, and it is of significant practical value in scientific applications.</p>
<p class="indent">Readers who are not familiar with mathematical calculus may consider this problem as an abstract exercise in formula manipulation, defined by the following rules:</p>
<div class="equation"><a id="ch02eq-lev2sec8-11"></a><img src="../Images/ch02/338equ04.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-12"></a><img src="../Images/ch02/338equ05.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-13"></a><img src="../Images/ch02/338equ06.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-14"></a><img src="../Images/ch02/338equ07.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-15"></a><img src="../Images/ch02/338equ08.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-16"></a><img src="../Images/ch02/338equ09.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-17"></a><img src="../Images/ch02/338equ10.jpg"></div>
<div class="equation"><a id="page_339"></a><a id="ch02eq-lev2sec8-18"></a><img src="../Images/ch02/339equ01.jpg"></div>
<div class="equation"><a id="ch02eq-lev2sec8-19"></a><img src="../Images/ch02/339equ02.jpg"></div>
<p class="noindent">These rules allow us to evaluate the derivative <em>D</em>(<em>y</em>) for any formula <em>y</em> composed of the operators listed. The “−” sign in rule (<a href="../Text/ch02a.html#ch02eq-lev2sec8-14">14</a>) is a unary operator, which is different from the binary “−” in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-16">16</a>); we will use “neg” to stand for unary negation in the tree nodes below.</p>
<p class="indent">Unfortunately rules (<a href="../Text/ch02a.html#ch02eq-lev2sec8-11">11</a>)–(<a href="../Text/ch02a.html#ch02eq-lev2sec8-19">19</a>) don’t tell the whole story. If we apply them blindly to a rather simple formula like</p>
<p class="center"><em>y</em> = 3 ln(<em>x</em> + 1) − <em>a</em>/<em>x</em><sup>2</sup>,</p>
<p class="noindent">we get</p>
<div class="equation"><a id="ch02eq-lev2sec8-20"></a><img src="../Images/ch02/339equ03.jpg"></div>
<p class="noindent">which is correct but totally unsatisfactory. To avoid so many redundant operations in the answer, we must recognize the special cases of adding or multiplying by zero, multiplying by one, or raising to the first power. These simplifications reduce (<a href="../Text/ch02a.html#ch02eq-lev2sec8-20">20</a>) to</p>
<div class="equation"><a id="ch02eq-lev2sec8-21"></a><img src="../Images/ch02/339equ04.jpg"></div>
<p class="noindent">which is more acceptable but still not ideal. The concept of a really satisfactory answer is not well-defined, because different mathematicians will prefer formulas to be expressed in different ways; however, it is clear that (<a href="../Text/ch02a.html#ch02eq-lev2sec8-21">21</a>) is not as simple as it could be. In order to make substantial progress over formula (<a href="../Text/ch02a.html#ch02eq-lev2sec8-21">21</a>), it is necessary to develop algebraic simplification routines (see <a href="../Text/ch02a.html#ch02ex_2_8_17">exercise 17</a>), which would reduce (<a href="../Text/ch02a.html#ch02eq-lev2sec8-21">21</a>) to, for example,</p>
<div class="equation"><a id="ch02eq-lev2sec8-22"></a><img src="../Images/ch02/339equ05.jpg"></div>
<p class="noindent">We will content ourselves here with routines that can produce (<a href="../Text/ch02a.html#ch02eq-lev2sec8-21">21</a>), not (<a href="../Text/ch02a.html#ch02eq-lev2sec8-22">22</a>).</p>
<p class="indent">Our main interest in this algorithm is, as usual, in the details of how the process is carried out inside a computer. Many higher-level languages and special routines are available at most computer installations, with built-in facilities to simplify algebraic manipulations like these; but the purpose of the present example is to gain more experience in fundamental tree operations.</p>
<p class="indent">The idea behind the following algorithm is to traverse the tree in postorder, forming the derivative of each node as we go, until eventually the entire derivative has been calculated. Using postorder means that we will arrive at an operator node (like “+”) <em>after</em> its operands have been differentiated. Rules (<a href="../Text/ch02a.html#ch02eq-lev2sec8-11">11</a>) through (<a href="../Text/ch02a.html#ch02eq-lev2sec8-19">19</a>) imply that every subformula of the original formula will have to be differentiated, sooner or later, so we might as well do the differentiations in postorder.</p>
<p class="indent">By using a right-threaded tree, we avoid the need for a stack during the operation of the algorithm. On the other hand, a threaded tree representation has the disadvantage that we will need to make copies of subtrees; for example, in the rule for <em>D</em>(<em>u</em> ↑ <em>v</em>) we might need to copy <em>u</em> and <em>υ</em> three times each. If we <a id="page_340"></a>had chosen to use a List representation as in <a href="../Text/ch02c.html#ch02lev2sec11">Section 2.3.5</a> instead of a tree, we could have avoided such copying.</p>
<p class="noindent"><a id="ch02alg-lev2sec8-D"></a><strong>Algorithm D</strong> (<em>Differentiation</em>). If <code>Y</code> is the address of a list head that points to a formula represented as described above, and if <code>DY</code> is the address of the list head for an empty tree, this algorithm makes <code>NODE(DY)</code> point to a tree representing the analytic derivative of <code>Y</code> with respect to the variable “<code>X</code>”.</p>
<p class="indenthanging"><strong>D1.</strong> [Initialize.] Set <code>P</code> ← <code>Y$</code> (namely, the first node of the tree, in postorder, which is the first node of the corresponding binary tree in inorder).</p>
<p class="indenthanging"><strong>D2.</strong> [Differentiate.] Set <code>P1</code> ← <code>LLINK(P)</code>; and if <code>P1</code> ≠ <em>Λ</em>, also set <code>Q1</code> ← <code>RLINK(P1)</code>. Then perform the routine <code>DIFF[TYPE(P)]</code>, described below. (The routines <code>DIFF[0]</code>, <code>DIFF[1]</code>, etc., will form the derivative of the tree with root <code>P</code>, and will set pointer variable <code>Q</code> to the address of the root of the derivative. The variables <code>P1</code> and <code>Q1</code> are set up first, in order to simplify the specification of the <code>DIFF</code> routines.)</p>
<p class="indenthanging"><strong>D3.</strong> [Restore link.] If <code>TYPE(P)</code> denotes a binary operator, set <code>RLINK(P1) ← P2.</code> (See the next step for an explanation.)</p>
<p class="indenthanging"><strong>D4.</strong> [Advance to <code>P$</code>.] Set <code>P2</code> ← <code>P, P</code> ← <code>P$</code>. Now if <code>RTAG(P2)</code> = 0 (that is, if <code>NODE(P2)</code> has a sibling to the right), set <code>RLINK(P2)</code> ← <code>Q</code>. (This is the tricky part of the algorithm: We temporarily destroy the structure of tree <code>Y</code>, so that a link to the derivative of <code>P2</code> is saved for future use. The missing link will be restored later in step D3. See <a href="../Text/ch02a.html#ch02ex_2_8_21">exercise 21</a> for further discussion of this trick.)</p>
<p class="indenthanging"><strong>D5.</strong> [Done?] If <code>P</code> ≠ <code>Y</code>, return to step D2. Otherwise set <code>LLINK(DY)</code> ← <code>Q</code> and <code>RLINK(Q)</code> ← <code>DY, RTAG(Q)</code> ← 1. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">The procedure described in <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> is just the background routine for the differentiation operations that are performed by the processing routines <code>DIFF[0], DIFF[1]</code>, ..., called in step D2. In many ways, <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> is like the control routine for an interpretive system or machine simulator, as discussed in <a href="../Text/ch01c.html#ch01lev2sec17">Section 1.4.3</a>, but it traverses a tree instead of a simple sequence of instructions.</p>
<p class="indent">To complete <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> we must define the routines that do the actual differentiation. In the following discussion, the statement “<code>P</code> points to a tree” means that <code>NODE(P)</code> is the root of a tree stored as a right-threaded binary tree, although both <code>RLINK(P)</code> and <code>RTAG(P)</code> will be meaningless so far as this tree is concerned. We will make use of a <em>tree construction function</em> that makes new trees by joining smaller ones together: Let <em>x</em> denote some kind of node, either a constant, variable, or operator, and let <code>U</code> and <code>V</code> denote pointers to trees; then</p>
<p class="indenti"><code>TREE(</code><em>x</em><code>,U,V</code>) makes a new tree with <em>x</em> in its root node and with <code>U</code> and <code>V</code> the subtrees of the root: <code>W</code> <span class="ent">⇐</span> <code>AVAIL, INFO(W)</code> ← <em>x</em>, <code>LLINK(W)</code> ← <code>U</code>, <code>RLINK(U)</code> ← <code>V</code>, <code>RTAG(U)</code> ← 0, <code>RLINK(V)</code> ← <code>W</code>, <code>RTAG(V)</code> ← 1.</p>
<p class="indenti"><code>TREE(</code><em>x</em>,<code>U)</code> similarly makes a new tree with only one subtree: <code>W</code> <span class="ent">⇐</span> <code>AVAIL, INFO(W)</code> ← <em>x</em>, <code>LLINK(W)</code> ← <code>U</code>, <code>RLINK(U)</code> ← <code>W</code>, <code>RTAG(U)</code> ← 1.</p>
<p class="indenti"><code>TREE(</code><em>x</em><code>)</code> makes a new tree with <em>x</em> as a terminal root node: <code>W</code> <span class="ent">⇐</span> <code>AVAIL</code>, <code>INFO(W)</code> ← <em>x</em>, <code>LLINK(W)</code> ← <em>Λ</em>.</p>
<p class="noindent"><a id="page_341"></a>Furthermore <code>TYPE(W)</code> is set appropriately, depending on <em>x</em>. In all cases, the value of <code>TREE</code> is <code>W</code>, that is, a pointer to the tree just constructed. The reader should study these three definitions carefully, since they illustrate the binary tree representation of trees. Another function, <code>COPY(U)</code>, makes a copy of the tree pointed to by <code>U</code> and has as its value a pointer to the tree thereby created. The basic functions <code>TREE</code> and <code>COPY</code> make it easy to build up a tree for the derivative of a formula, step by step.</p>
<p class="noindent"><strong>Nullary operators</strong> (<em>constants and variables</em>). For these operations, <code>NODE(P)</code> is a terminal node, and the values of <code>P1</code>, <code>P2</code>, <code>Q1</code>, and <code>Q</code> before the operation are irrelevant.</p>
<p class="indent"><code>DIFF</code><code>[</code>0<code>]</code>: <code>(NODE(P)</code> is a constant.) Set <code>Q</code> ← <code>TREE(0)</code>.</p>
<p class="indent"><code>DIFF</code><code>[</code>1<code>]</code>: <code>(NODE(P)</code> is a variable.) If <code>INFO(P)</code> = “<code>X</code>”, set <code>Q</code> ← <code>TREE(1)</code>; otherwise set <code>Q</code> ← <code>TREE(0)</code>.</p>
<p class="noindent"><strong>Unary operators</strong> (<em>logarithm and negation</em>). For these operations, <code>NODE(P)</code> has one child, <em>U</em>, pointed to by <code>P1</code>, and <code>Q</code> points to <em>D</em>(<em>U</em>). The values of <code>P2</code> and <code>Q1</code> before the operation are irrelevant.</p>
<p class="indent"><code>DIFF[</code>2<code>]</code>: (<code>NODE(P)</code> is “ln”.) If <code>INFO(Q)</code> ≠ 0, set <code>Q</code> ← <code>TREE</code>(“/”,<code>Q,COPY(P1))</code>.</p>
<p class="indent"><code>DIFF[</code>3<code>]</code>: (<code>NODE(P)</code> is “neg”.) If <code>INFO(Q)</code> ≠ 0, set <code>Q</code> ← <code>TREE</code>(“neg”,<code>Q)</code>.</p>
<p class="noindent"><strong>Binary operators</strong> (<em>addition, subtraction, multiplication, division, exponentiation</em>). For these operations, <code>NODE(P)</code> has two children, <em>U</em> and <em>V</em>, pointed to respectively by <code>P1</code> and <code>P2</code>; <code>Q1</code> and <code>Q</code> point respectively to <em>D</em>(<em>U</em>), <em>D</em>(<em>V</em>).</p>
<p class="indent"><code>DIFF[</code>4<code>]</code>: (“+” operation.) If <code>INFO(Q1)</code> = 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>Q1</code>. Otherwise if <code>INFO(Q)</code> = 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>Q</code> and <code>Q</code> ← <code>Q1</code>; otherwise set <code>Q</code> ← <code>TREE</code>(“+”,<code>Q1,Q)</code>.</p>
<p class="indent"><code>DIFF[</code>5<code>]</code>: (“−” operation.) If <code>INFO(Q)</code> 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>Q</code> and <code>Q</code> ← <code>Q1</code>. Otherwise if <code>INFO(Q1</code>) = 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>Q1</code> and set <code>Q</code> ← <code>TREE</code>(“neg”,<code>Q</code>); otherwise set <code>Q</code> ← <code>TREE</code>(“−”,<code>Q1,Q)</code>.</p>
<p class="indent"><code>DIFF[</code>6<code>]</code>: (“×” operation.) If <code>INFO(Q1)</code> ≠ 0, set <code>Q1</code> ← <code>MULT(Q1,COPY(P2))</code>. Then if <code>INFO(Q)</code> ≠ 0, set <code>Q</code> ← <code>MULT(COPY(P1),Q)</code>. Then go to <code>DIFF[</code>4<code>]</code>.</p>
<p class="indent">Here <code>MULT(U,V)</code> is a new function that constructs a tree for <code>U</code> × <code>V</code> but also makes a test to see if <code>U</code> or <code>V</code> is equal to 1:</p>
<p class="indentii">if <code>INFO(U)</code> = 1 and <code>TYPE(U)</code> = 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>U</code> and <code>MULT(U,V)</code> ← <code>V</code>;</p>
<p class="indentii">if <code>INFO(V)</code> = 1 and <code>TYPE(V)</code> = 0, set <code>AVAIL</code> <span class="ent">⇐</span> <code>V</code> and <code>MULT(U,V)</code> ← <code>U</code>;</p>
<p class="indentiii">otherwise set <code>MULT(U,V)</code> ← <code>TREE(</code>“×”<code>,U,V)</code>.</p>
<p class="indentii"><code>DIFF[</code>7<code>]</code>: (“/” operation.) If <code>INFO(Q1</code>) ≠ 0, set</p>
<p class="center"><code>Q1</code> ← <code>TREE</code><code>(</code>“/”,<code>Q1,COPY(P2))</code>.</p>
<p class="noindent">Then if <code>INFO(Q)</code> ≠ 0, set</p>
<p class="center"><code>Q</code> ← <code>TREE(</code>“/”,<code>MULT(COPY(P1),Q),TREE(</code>“↑”,<code>COPY(P2),TREE(2)))</code>.</p>
<p class="noindent">Then go to <code>DIFF[</code>5<code>]</code>.</p>
<p class="center"><code>DIFF[</code>8<code>]</code>: (“↑” operation.) See <a href="../Text/ch02a.html#ch02ex_2_8_12">exercise 12</a>.</p>
<p class="indent"><a id="page_342"></a>We conclude this section by showing how all of the operations above are readily transformed into a computer program, starting “from scratch” with only <code>MIX</code> machine language as a basis.</p>
<p class="noindent"><a id="ch02a_pro_d"></a><strong>Program D</strong> (<em>Differentiation</em>). The following <code>MIXAL</code> program performs <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a>, with rI2 ≡ <code>P</code>, rI3 ≡ <code>P2</code>, rI4 ≡ <code>P1</code>, rI5 ≡ <code>Q</code>, rI6 ≡ <code>Q1</code>. The order of computations has been rearranged a little, for convenience.</p>
<div class="image"><img src="../Images/ch02/342pro01.jpg"></div>
<div class="image"><img src="../Images/ch02/342pro01a.jpg"></div>
<p class="noindent">The next part of the program contains the basic subroutines <code>TREE</code> and <code>COPY</code>. The former has three entrances <code>TREE0</code>, <code>TREE1</code>, and <code>TREE2</code>, according to the number of subtrees of the tree being constructed. Regardless of which entrance to the subroutine is used, rA will contain the address of a special constant indicating <a id="page_343"></a>what type of node forms the root of the tree being constructed; these special constants appear in lines 105–124.</p>
<div class="image"><img src="../Images/ch02/343pro01.jpg"></div>
<div class="image"><img src="../Images/ch02/343pro01a.jpg"></div>
<p class="noindent"><a id="page_344"></a>The remaining portion of the program corresponds to the differentiation routines <code>DIFF[0]</code>, <code>DIFF[1]</code>, ...; these routines are written to return control to step D3 after processing a binary operator, otherwise they return to step D4.</p>
<div class="image"><img src="../Images/ch02/344pro01.jpg"></div>
<div class="image"><img src="../Images/ch02/344pro01a.jpg"></div>
<div class="image"><a id="page_345"></a><img src="../Images/ch02/344pro01b.jpg"></div>
<div class="image"><img src="../Images/ch02/344pro01c.jpg"></div>
<p class="exercisesp"><a id="page_346"></a>The other two routines <code>DIV</code> and <code>PWR</code> are similar and they have been left as exercises (see <a href="../Text/ch02a.html#ch02ex_2_8_15">exercises 15</a> and <a href="../Text/ch02a.html#ch02ex_2_8_16">16</a>).</p>
<p class="ex-title">Exercises</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_1" href="../Text/app01b.html#ch02ex_2_8_1a">1</a>.</strong> [<em>20</em>] The text gives a formal definition of <em>B</em>(<em>F</em>), the binary tree corresponding to a forest <em>F</em>. Give a formal definition that reverses the process; in other words, define <em>F</em> (<em>B</em>), the forest corresponding to a binary tree <em>B</em>.</p>
<p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_2" href="../Text/app01b.html#ch02ex_2_8_2a">2</a>.</strong> [<em>20</em>] We defined Dewey decimal notation for forests in <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a>, and for binary trees in <a href="../Text/ch02a.html#ch02lev2sec7">exercise 2.3.1</a>–<a href="../Text/ch02a.html#page_331">5</a>. Thus the node “<em>J</em>” in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-1">1</a>) is represented by “2.2.1”, and in the equivalent binary tree (<a href="../Text/ch02a.html#ch02eq-lev2sec8-3">3</a>) it is represented by “11010”. If possible, give a rule that directly expresses the natural correspondence between trees and binary trees as a correspondence between the Dewey decimal notations.</p>
<p class="exercises"><strong><a id="ch02ex_2_8_3" href="../Text/app01b.html#ch02ex_2_8_3a">3</a>.</strong> [<em>22</em>] What is the relation between Dewey decimal notation for the nodes of a forest and the preorder and postorder of those nodes?</p>
<p class="exercises"><strong><a id="ch02ex_2_8_4" href="../Text/app01b.html#ch02ex_2_8_4a">4</a>.</strong> [<em>19</em>] Is the following statement true or false? “The terminal nodes of a tree occur in the same relative position in preorder and postorder.”</p>
<p class="exercises"><strong><a id="ch02ex_2_8_5" href="../Text/app01b.html#ch02ex_2_8_5a">5</a>.</strong> [<em>23</em>] Another correspondence between forests and binary trees could be defined by letting <code>RLINK(P)</code> point to the rightmost child of <code>NODE(P)</code>, and <code>LLINK(P)</code> to the nearest sibling on the left. Let <em>F</em> be a forest that corresponds in this way to a binary tree <em>B</em>. What order, on the nodes of <em>B</em>, corresponds to (a) preorder (b) postorder on <em>F</em> ?</p>
<p class="exercises"><strong><a id="ch02ex_2_8_6" href="../Text/app01b.html#ch02ex_2_8_6a">6</a>.</strong> [<em>25</em>] Let <em>T</em> be a nonempty binary tree in which each node has 0 or 2 children. If we regard <em>T</em> as an ordinary tree, it corresponds (via the natural correspondence) to <em>another</em> binary tree <em>T</em> ′. Is there any simple relation between preorder, inorder, and postorder of the nodes of <em>T</em> (as defined for binary trees) and the same three orders for the nodes of <em>T</em> ′?</p>
<p class="exercises"><strong><a id="ch02ex_2_8_7" href="../Text/app01b.html#ch02ex_2_8_7a">7</a>.</strong> [<em>M20</em>] A forest may be regarded as a partial ordering, if we say that each node precedes its descendants in the tree. Are the nodes topologically sorted (as defined in <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a>) when they are listed in (a) preorder? (b) postorder? (c) reverse preorder? (d) reverse postorder?</p>
<p class="exercises"><strong><a id="ch02ex_2_8_8" href="../Text/app01b.html#ch02ex_2_8_8a">8</a>.</strong> [<em>M20</em>] <a href="../Text/ch02a.html#ch02lev2sec7">Exercise 2.3.1</a>–<a href="../Text/ch02a.html#ch02ex_2_7_25">25</a> shows how an ordering between the information stored in the individual nodes of a binary tree may be extended to a linear ordering of all binary trees. The same construction leads to an ordering of all trees, under the natural correspondence. Reformulate the definition of that exercise, in terms of trees.</p>
<p class="exercises"><strong><a id="ch02ex_2_8_9" href="../Text/app01b.html#ch02ex_2_8_9a">9</a>.</strong> [<em>M21</em>] Show that the total number of nonterminal nodes in a forest has a simple relation to the total number of right links equal to <em>Λ</em> in the corresponding unthreaded binary tree.</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_10" href="../Text/app01b.html#ch02ex_2_8_10a">10</a>.</strong> [<em>M23</em>] Let <em>F</em> be a forest of trees whose nodes in preorder are <em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ..., <em>u</em><sub><em>n</em></sub>, and let <em>F</em> ′ be a forest whose nodes in preorder are <em>u</em>′<sub>1</sub>, <em>u</em>′<sub>2</sub>, ..., <em>u</em>′<sub><em>n</em>′</sub> . Let <em>d</em>(<em>u</em>) denote the degree (the number of children) of node <em>u</em>. In terms of these ideas, formulate and prove a theorem analogous to <a href="../Text/ch02a.html#ch02a_the_a">Theorem 2.3.1A</a>.</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_11" href="../Text/app01b.html#ch02ex_2_8_11a">11</a>.</strong> [<em>15</em>] Draw trees analogous to those shown in (<a href="../Text/ch02a.html#ch02eq-lev2sec8-7">7</a>), corresponding to the formula <em>y</em> = <em>e</em><sup>−<em>x</em><sup>2</sup></sup></p>
<p class="exercises1"><strong><a id="ch02ex_2_8_12" href="../Text/app01b.html#ch02ex_2_8_12a">12</a>.</strong> [<em>M21</em>] Give specifications for the routine <code>DIFF[</code>8<code>]</code> (the “↑” operation), which was omitted from the algorithm in the text.</p>
<p class="exercises3"><a id="page_347"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_13" href="../Text/app01b.html#ch02ex_2_8_13a">13</a>.</strong> [<em>26</em>] Write a <code>MIX</code> program for the <code>COPY</code> subroutine (which fits in the program of the text between lines 063–104). [<em>Hint:</em> Adapt <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm 2.3.1C</a> to the case of right-threaded binary trees, with suitable initial conditions.]</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_14" href="../Text/app01b.html#ch02ex_2_8_14a">14</a>.</strong> [<em>M21</em>] How long does it take the program of <a href="../Text/ch02a.html#ch02ex_2_8_13">exercise 13</a> to copy a tree with <em>n</em> nodes?</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_15" href="../Text/app01b.html#ch02ex_2_8_15a">15</a>.</strong> [<em>23</em>] Write a <code>MIX</code> program for the <code>DIV</code> routine, corresponding to <code>DIFF[</code>7<code>]</code> as specified in the text. (This routine should be added to the program in the text after line 217.)</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_16" href="../Text/app01b.html#ch02ex_2_8_16a">16</a>.</strong> [<em>24</em>] Write a <code>MIX</code> program for the <code>PWR</code> routine, corresponding to <code>DIFF[</code>8<code>]</code> as specified in <a href="../Text/ch02a.html#ch02ex_2_8_12">exercise 12</a>. (This routine should be added to the program in the text after the solution to <a href="../Text/ch02a.html#ch02ex_2_8_15">exercise 15</a>.)</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_17" href="../Text/app01b.html#ch02ex_2_8_17a">17</a>.</strong> [<em>M40</em>] Write a program to do algebraic simplification capable of reducing, for example, (<a href="../Text/ch02a.html#ch02eq-lev2sec8-20">20</a>) or (<a href="../Text/ch02a.html#ch02eq-lev2sec8-21">21</a>) to (<a href="../Text/ch02a.html#ch02eq-lev2sec8-22">22</a>). [<em>Hints:</em> Include a new field with each node, representing its coefficient (for summands) or its exponent (for factors in a product). Apply algebraic identities, like replacing ln(<em>u</em> ↑ <em>v</em>) by <em>v</em> ln <em>u</em>; remove the operations −, /, ↑, and neg when possible by using equivalent addition or multiplication operations. Make + and × into <em>n</em>-ary instead of binary operators; collect like terms by sorting their operands in tree order (<a href="../Text/ch02a.html#ch02ex_2_8_8">exercise 8</a>); some sums and products will now reduce to zero or unity, presenting perhaps further simplifications. Other adjustments, like replacing a sum of logarithms by the logarithm of a product, also suggest themselves.]</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span> <strong><a id="ch02ex_2_8_18" href="../Text/app01b.html#ch02ex_2_8_18a">18</a></strong>. [<em>25</em>] An oriented tree specified by <em>n</em> links <code>PARENT</code>[<em>j</em>] for 1 ≤ <em>j</em> ≤ <em>n</em> implicitly defines an ordered tree if the nodes in each family are ordered by their location. Design an efficient algorithm that constructs a doubly linked circular list containing the nodes of this ordered tree in preorder. For example, given</p>
<div class="image"><img src="../Images/ch02/347pro01.jpg"></div>
<p class="exercisesp">your algorithm should produce</p>
<div class="image"><img src="../Images/ch02/347pro02.jpg"></div>
<p class="exercisesp">and it should also report that the root node is 4.</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_19"></a>19.</strong> [<em>M35</em>] A <em>free lattice</em> is a mathematical system, which (for the purposes of this exercise) can be simply defined as the set of all formulas composed of variables and two abstract binary operators “<span class="ent">∨</span>” and “<span class="ent">∧</span>”. A relation “<em>X</em> <span class="ent">≽</span> <em>Y</em>” is defined between certain formulas <em>X</em> and <em>Y</em> in the free lattice by the following rules:</p>
<p class="indenti">i) <em>X</em> <span class="ent">∨</span> <em>Y</em> <span class="ent">≽</span> <em>W</em> <span class="ent">∧</span> <em>Z</em> if and only if <em>X</em> <span class="ent">∨</span> <em>Y</em> <span class="ent">≽</span> <em>W</em> or <em>X</em> <span class="ent">∨</span> <em>Y</em> <span class="ent">≽</span> <em>Z</em> or <em>X</em> <span class="ent">≽</span> <em>W</em> <span class="ent">∧</span> <em>Z</em> or <em>Y</em> <span class="ent">≽</span> <em>W</em> <span class="ent">∧</span> <em>Z</em>;</p>
<p class="indenti">ii) <em>X</em> <span class="ent">∧</span> <em>Y</em> <span class="ent">≽</span> <em>Z</em> if and only if <em>X</em> <span class="ent">≽</span> <em>Z</em> and <em>Y</em> <span class="ent">≽</span> <em>Z</em>;</p>
<p class="indenti">iii) <em>X</em> <span class="ent">≽</span> <em>Y</em> <span class="ent">∨</span> <em>Z</em> if and only if <em>X</em> <span class="ent">≽</span> <em>Y</em> and <em>X</em> <span class="ent">≽</span> <em>Z</em>;</p>
<p class="indenti">iv) <em>x</em> <span class="ent">≽</span> <em>Y</em> <span class="ent">∧</span> <em>Z</em> if and only if <em>x</em> <span class="ent">≽</span> <em>Y</em> or <em>x</em> <span class="ent">≽</span> <em>Z</em>, when <em>x</em> is a variable;</p>
<p class="indenti">v) <em>X</em> <span class="ent">∨</span> <em>Y</em> <span class="ent">≽</span> <em>z</em> if and only if <em>X</em> <span class="ent">≽</span> <em>z</em> or <em>Y</em> <span class="ent">≽</span> <em>z</em>, when <em>z</em> is a variable;</p>
<p class="indenti">vi) <em>x</em> <span class="ent">≽</span> <em>y</em> if and only if <em>x</em> = <em>y</em>, when <em>x</em> and <em>y</em> are variables.</p>
<p class="noindent">For example, we find <em>a</em> <span class="ent">∧</span> (<em>b</em> <span class="ent">∨</span> <em>c</em>) <span class="ent">≽</span> (<em>a</em> <span class="ent">∧</span> <em>b</em>) <span class="ent">∨</span> (<em>a</em> <span class="ent">∧</span> <em>c</em>) <span class="ent">⋡</span> <em>a</em> <span class="ent">∧</span> (<em>b</em> <span class="ent">∨</span> <em>c</em>).</p>
<p class="indent">Design an algorithm that tests whether or not <em>X</em> <span class="ent">≽</span> <em>Y</em>, given two formulas <em>X</em> and <em>Y</em> in the free lattice.</p>
<p class="exercises3"><a id="page_348"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_20" href="../Text/app01b.html#ch02ex_2_8_20a">20</a>.</strong> [<em>M22</em>] Prove that if <em>u</em> and <em>υ</em> are nodes of a forest, <em>u</em> is a proper ancestor of <em>v</em> if and only if <em>u</em> precedes <em>v</em> in preorder and <em>u</em> follows <em>v</em> in postorder.</p>
<p class="exercises1"><strong><a id="ch02ex_2_8_21" href="../Text/app01b.html#ch02ex_2_8_21a">21</a>.</strong> [<em>25</em>] <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> controls the differentiation activity for binary operators, unary operators, and nullary operators, thus for trees whose nodes have degree 2, 1, and 0; but it does not indicate explicitly how the control would be handled for ternary operators and nodes of higher degree. (For example, <a href="../Text/ch02a.html#ch02ex_2_8_17">exercise 17</a> suggests making addition and multiplication into operators with any number of operands.) Is it possible to extend <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> in a simple way so that it will handle operators of degree more than 2?</p>
<p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a id="ch02ex_2_8_22" href="../Text/app01b.html#ch02ex_2_8_22a">22</a>.</strong> [<em>M26</em>] If <em>T</em> and <em>T</em> ′ are trees, let us say <em>T can be embedded in T</em> ′, written <em>T</em> <span class="ent">⊆</span> <em>T</em> ′, if there is a one-to-one function <em>f</em> from the nodes of <em>T</em> into the nodes of <em>T</em> <sub>′</sub> such that <em>f</em> preserves both preorder and postorder. (In other words, <em>u</em> precedes <em>v</em> in preorder for <em>T</em> if and only if <em>f</em> (<em>u</em>) precedes <em>f</em> (<em>v</em>) in preorder for <em>T</em> ′, and the same holds for postorder. See <a href="../Text/ch02a.html#ch02fig25">Fig. 25</a>.)</p>
<div class="image"><a id="ch02fig25"></a><img src="../Images/ch02/02fig25.jpg"><p class="fig-caption"><strong>Fig. 25.</strong> One tree embedded in another (see <a href="../Text/ch02a.html#ch02ex_2_8_22">exercise 22</a>).</p></div>
<p class="indent">If <em>T</em> has more than one node, let <em>l</em>(<em>T</em>) be the leftmost subtree of root(<em>T</em>) and let <em>r</em>(<em>T</em>) be the rest of <em>T</em>, that is, <em>T</em> with <em>l</em>(<em>T</em>) deleted. Prove that <em>T</em> can be embedded in <em>T</em> ′ if (i) <em>T</em> has just one node, or (ii) both <em>T</em> and <em>T</em> ′ have more than one node and either <em>T</em> <span class="ent">⊆</span> <em>l</em>(<em>T</em> ′), or <em>T</em> <span class="ent">⊆</span> <em>r</em>(<em>T</em> ′), or (<em>l</em>(<em>T</em>) <span class="ent">⊆</span> <em>l</em>(<em>T</em> ′) and <em>r</em>(<em>T</em>) <span class="ent">⊆</span> <em>r</em>(<em>T</em> ′)). Does the converse hold?</p>
<div class="heading">
<h4 id="ch02lev2sec9">2.3.3. Other Representations of Trees</h4>
<p class="noindent">There are many ways to represent tree structures inside a computer besides the <code>LLINK-RLINK</code> (left child – right sibling) method given in the previous section. As usual, the proper choice of representation depends heavily on what kind of operations we want to perform on the trees. In this section we will consider a few of the tree representation methods that have proved to be especially useful.</p>
</div>
<p class="indent">First we can use <em>sequential</em> memory techniques. As in the case of linear lists, this mode of allocation is most suitable when we want a compact representation of a tree structure that is not going to be subject to radical dynamic changes in size or shape during program execution. There are many situations in which we need essentially constant tables of tree structures for reference within a program, and the desired form of these trees in memory depends on the way in which the tables are to be examined.</p>
<p class="indent">The most common sequential representation of trees (and forests) corresponds essentially to the omission of <code>LLINK</code> fields, by using consecutive addressing <a id="page_349"></a>instead. For example, let us look again at the forest</p>
<div class="equation"><a id="ch02eq-lev2sec9-1"></a><img src="../Images/ch02/349equ01.jpg"></div>
<p class="noindent">considered in the previous section, which has the tree diagrams</p>
<div class="equation"><a id="ch02eq-lev2sec9-2"></a><img src="../Images/ch02/349equ02.jpg"></div>
<p class="indent">The <em>preorder sequential representation</em> has the nodes appearing in preorder, with the fields <code>INFO</code>, <code>RLINK</code>, and <code>LTAG</code> in each node:</p>
<div class="equation"><a id="ch02eq-lev2sec9-3"></a><img src="../Images/ch02/349equ03.jpg"></div>
<p class="noindent">Here nonnull <code>RLINK</code>s have been indicated by arrows, and <code>LTAG</code> = 1 (for terminal nodes) is indicated by “<span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span>”. <code>LLINK</code> is unnecessary, since it would either be null or it would point to the next item in sequence. It is instructive to compare (<a href="../Text/ch02a.html#ch02eq-lev2sec9-1">1</a>) with (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>).</p>
<p class="indent">This representation has several interesting properties. In the first place, all subtrees of a node appear immediately after that node, so that all subtrees within the original forest appear in consecutive blocks. [Compare this with the “nested parentheses” in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-1">1</a>) and in <a href="../Text/ch02a.html#ch02fig20">Fig. 20</a>(b).] In the second place, notice that the <code>RLINK</code> arrows never cross each other in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>); this will be true in general, for in a binary tree all nodes between <code>X</code> and <code>RLINK(X)</code> in preorder lie in the left subtree of <code>X</code>, hence no outward arrows will emerge from that part of the tree. In the third place, we may observe that the <code>LTAG</code> field, which indicates whether a node is terminal or not, is redundant, since “<span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span>” occurs only at the end of the forest and just <em>preceding</em> every downward pointing arrow.</p>
<p class="indent">Indeed, these remarks show that the <code>RLINK</code> field itself is almost redundant; all we really need to represent the structure is <code>RTAG</code> and <code>LTAG</code>. Thus it is possible to deduce (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) from much less data:</p>
<div class="equation"><a id="ch02eq-lev2sec9-4"></a><img src="../Images/ch02/349equ04.jpg"></div>
<p class="noindent">As we scan (<a href="../Text/ch02a.html#ch02eq-lev2sec9-4">4</a>) from left to right, the positions with <code>RTAG</code> ≠ “<span class="middle"><img src="../Images/ch02/en0477_02.jpg"></span>” correspond to nonnull <code>RLINK</code>s that must be filled in. Each time we pass an item with <code>LTAG</code> = “<span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span>”, we should complete the most recent instance of an incomplete <code>RLINK</code>. (The locations of incomplete <code>RLINK</code>s can therefore be kept on a stack.) We have essentially proved <a href="../Text/ch02a.html#ch02a_the_a">Theorem 2.3.1A</a> again.</p>
<p class="indent">The fact that <code>RLINK</code> or <code>LTAG</code> is redundant in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) is of little or no help to us unless we are scanning the entire forest sequentially, since extra computation is required to deduce the missing information. Therefore we often need all of<a id="page_350"></a> the data in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>). However, there is evidently some wasted space, since more than half of the <code>RLINK</code> fields are equal to <em>Λ</em> for this particular forest. There are two common ways to make use of the wasted space:</p>
<p class="indent"><strong>1)</strong> Fill the <code>RLINK</code> of each node with the address following the subtree below that node. The field is now often called “<code>SCOPE</code>” instead of <code>RLINK</code>, since it indicates the right boundary of the “influence” (descendants) of each node. Instead of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>), we would have</p>
<div class="equation"><a id="ch02eq-lev2sec9-5"></a><img src="../Images/ch02/350equ01.jpg"></div>
<p class="noindent">The arrows still do not cross each other. Furthermore, <code>LTAG(X)</code> = “<span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span>” is characterized by the condition <code>SCOPE(X)</code> = <code>X</code> + <em>c</em>, where <em>c</em> is the number of words per node. One example of the use of this <code>SCOPE</code> idea appears in <a href="../Text/ch02c.html#ch02lev1sec4">exercise 2.4</a>–<a href="../Text/ch02c.html#ch02ex_1_4_12">12</a>.</p>
<p class="indent"><strong>2)</strong> Decrease the size of each node by removing the <code>RLINK</code> field, and add special “link” nodes just before nodes that formerly had a nonnull <code>RLINK</code>:</p>
<div class="equation"><a id="ch02eq-lev2sec9-6"></a><img src="../Images/ch02/350equ02.jpg"></div>
<p class="noindent">Here “<code>*</code>” indicates the special link nodes, whose <code>INFO</code> somehow characterizes them as links pointing as shown by the arrows. If the <code>INFO</code> and <code>RLINK</code> fields of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) occupy roughly the same amount of space, the net effect of the change to (<a href="../Text/ch02a.html#ch02eq-lev2sec9-6">6</a>) is to consume less memory, since the number of “<code>*</code>” nodes is always less than the number of non-“<code>*</code>” nodes. Representation (<a href="../Text/ch02a.html#ch02eq-lev2sec9-6">6</a>) is somewhat analogous to a sequence of instructions in a one-address computer like <code>MIX</code>, with the “<code>*</code>” nodes corresponding to conditional jump instructions.</p>
<p class="indent">Another sequential representation analogous to (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) may be devised by omitting <code>RLINK</code>s instead of <code>LLINK</code>s. In this case we list the nodes of the forest in a new order that may be called <em>family order</em> since the members of each family appear together. Family order for any forest may be defined recursively as follows:</p>
<p class="indent">Visit the root of the first tree.</p>
<p class="indent">Traverse the remaining trees (in family order).</p>
<p class="indent">Traverse the subtrees of the root of the first tree (in family order).</p>
<p class="noindent">(Compare this with the definitions of preorder and postorder in the previous section. Family order is identical with the reverse of postorder in the corresponding binary tree.)</p>
<p class="indent">The <em>family order sequential representation</em> of the trees (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) is</p>
<div class="equation"><a id="ch02eq-lev2sec9-7"></a><img src="../Images/ch02/350equ03.jpg"></div>
<p class="noindent">In this case the <code>RTAG</code> entries serve to delimit the families. Family order begins by listing the roots of all trees in the forest, then continues by listing individual families, successively choosing the family of the most recently appearing node whose family has not yet been listed. It follows that the <code>LLINK</code> arrows will <a id="page_351"></a>never cross; and the other properties of preorder representation carry over in a similar way.</p>
<p class="indent">Instead of using family order, we could also simply list the nodes from left to right, one level at a time. This is called “level order” [see G. Salton, <em>CACM</em> <strong>5</strong> (1962), 103–114], and the <em>level order sequential representation</em> of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) is</p>
<div class="equation"><a id="ch02eq-lev2sec9-8"></a><img src="../Images/ch02/351equ01.jpg"></div>
<p class="noindent">This is like (<a href="../Text/ch02a.html#ch02eq-lev2sec9-7">7</a>), but the families are chosen in first-in-first-out fashion rather than last-in-first-out. Either (<a href="../Text/ch02a.html#ch02eq-lev2sec9-7">7</a>) or (<a href="../Text/ch02a.html#ch02eq-lev2sec9-8">8</a>) may be regarded as a natural analog, for trees, of the sequential representation of linear lists.</p>
<p class="indent">The reader will easily see how to design algorithms that traverse and analyze trees represented sequentially as above, since the <code>LLINK</code> and <code>RLINK</code> information is essentially available just as though we had a fully linked tree structure.</p>
<p class="indent">Another sequential method, called <em>postorder with degrees</em>, is somewhat different from the techniques above. We list the nodes in postorder and give the degree of each node instead of links:</p>
<div class="equation"><a id="ch02eq-lev2sec9-9"></a><img src="../Images/ch02/351equ02.jpg"></div>
<p class="noindent">For a proof that this is sufficient to characterize the tree structure, see <a href="../Text/ch02a.html#ch02lev2sec8">exercise 2.3.2</a>–<a href="../Text/ch02a.html#ch02ex_2_8_10">10</a>. This order is useful for the “bottom-up” evaluation of functions defined on the nodes of a tree, as in the following algorithm.</p>
<p class="noindent"><a id="ch02alg-lev2sec9-F"></a><strong>Algorithm F</strong> (<em>Evaluate a locally defined function in a tree</em>). Suppose <em>f</em> is a function of the nodes of a tree, such that the value of <em>f</em> at a node <em>x</em> depends only on <em>x</em> and the values of <em>f</em> on the children of <em>x</em>. The following algorithm, using an auxiliary stack, evaluates <em>f</em> at each node of a nonempty forest.</p>
<p class="indenthanging"><strong>F1.</strong> [Initialize.] Set the stack empty, and let <code>P</code> point to the first node of the forest in postorder.</p>
<p class="indenthanging"><strong>F2.</strong> [Evaluate <em>f</em>.] Set <em>d</em> ← <code>DEGREE(P)</code>. (The first time this step is reached, <em>d</em> will be zero. In general, when we get to this point, it will always be true that the top <em>d</em> items of the stack are <em>f</em> (<em>x</em><sub><em>d</em></sub>), ..., <em>f</em> (<em>x</em><sub>1</sub>) — from the top of the stack downward — where <em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>d</em></sub> are the children of <code>NODE(P)</code> from left to right.) Evaluate <em>f</em> (<code>NODE(P)</code>), using the values of <em>f</em> (<em>x</em><sub><em>d</em></sub>), ..., <em>f</em> (<em>x</em><sub>1</sub>) found on the stack.</p>
<p class="indenthanging"><strong>F3.</strong> [Update the stack.] Remove the top <em>d</em> items of the stack; then put the value <em>f</em> (<code>NODE(P)</code>) on top of the stack.</p>
<p class="indenthanging"><strong>F4.</strong> [Advance.] If <code>P</code> is the last node in postorder, terminate the algorithm. (The stack will then contain <em>f</em> (root(<em>T</em><sub><em>m</em></sub>)), ..., <em>f</em> (root(<em>T</em><sub>1</sub>)), from top to bottom, where <em>T</em><sub>1</sub>, ..., <em>T</em><sub><em>m</em></sub> are the trees of the given forest.) Otherwise set <code>P</code> to its successor in postorder (this would be simply <code>P</code> ← <code>P</code> + <em>c</em> in the representation (<a href="../Text/ch02a.html#ch02eq-lev2sec9-9">9</a>)), and return to step F2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent"><a id="page_352"></a>The validity of <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> follows by induction on the size of the trees processed (see <a href="../Text/ch02b.html#ch02ex_2_9_16">exercise 16</a>). This algorithm bears a striking similarity to the differentiation procedure of the previous section (<a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm 2.3.2D</a>), which evaluates a function of a closely related type; see <a href="../Text/ch02b.html#ch02ex_2_9_3">exercise 3</a>. The same idea is used in many interpretive routines in connection with the evaluation of arithmetic expressions in postfix notation; we will return to this topic in Chapter 8. See also <a href="../Text/ch02b.html#ch02ex_2_9_17">exercise 17</a>, which gives another important procedure similar to <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a>.</p>
<p class="indent">Thus we have seen various sequential representations of trees and forests. There are also a number of <em>linked</em> forms of representation, which we shall now consider.</p>
<p class="indent">The first idea is related to the transformation that takes (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) into (<a href="../Text/ch02a.html#ch02eq-lev2sec9-6">6</a>): We remove the <code>INFO</code> fields from all nonterminal nodes and put this information as a new terminal node below the previous node. For example, the trees (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) would become</p>
<div class="equation"><a id="ch02eq-lev2sec9-10"></a><img src="../Images/ch02/352equ01.jpg"></div>
<p class="noindent">This new form shows that we may assume (without loss of generality) that all <code>INFO</code> in a tree structure appears in its terminal nodes. Therefore in the natural binary tree representation of <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>, the <code>LLINK</code> and <code>INFO</code> fields are mutually exclusive and they can share the same field in each node. A node might have the fields</p>
<div class="image"><img src="../Images/ch02/e352_01.jpg"></div>
<p class="noindent">where the sign <code>LTAG</code> tells whether the second field is a link or not. (Compare this representation with, for example, the two-word format of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-10">10</a>) in <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>.) By cutting <code>INFO</code> down from 5 bytes to 3, we can fit each node into one word. However, notice that there are now 15 nodes instead of 10; the forest (<a href="../Text/ch02a.html#ch02eq-lev2sec9-10">10</a>) takes 15 words of memory while (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) takes 20, yet the latter has 50 bytes of <code>INFO</code> compared to 30 in the other. There is no real gain in memory space in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-10">10</a>) unless the excess <code>INFO</code> space was going to waste; the <code>LLINK</code>s replaced in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-10">10</a>) are removed at the expense of about the same number of new <code>RLINK</code>s in the added nodes. Precise details of the differences between the two representations are discussed in <a href="../Text/ch02b.html#ch02ex_2_9_4">exercise 4</a>.</p>
<p class="indent">In the standard binary tree representation of a tree, the <code>LLINK</code> field might be more accurately called the <code>LCHILD</code> field, since it points from a parent node to its leftmost child. The leftmost child is usually the “youngest” of the children in the tree, since it is easier to insert a node at the left of a family than at the right; so the abbreviation <code>LCHILD</code> may also be thought of as the “last child” or “least child.”</p>
<p class="indent"><a id="page_353"></a>Many applications of tree structures require rather frequent references upward in the tree as well as downward. A threaded tree gives us the ability to go upward, but not with great speed; we can sometimes do better if we have a third link, <code>PARENT</code>, in each node. This leads to a <em>triply linked tree</em>, where each node has <code>LCHILD</code>, <code>RLINK</code>, and <code>PARENT</code> links. <a href="../Text/ch02a.html#ch02fig26">Figure 26</a> shows a triply linked tree representation of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>). For an example of the use of triply linked trees, see <a href="../Text/ch02c.html#ch02lev1sec4">Section 2.4</a>.</p>
<div class="image"><a id="ch02fig26"></a><img src="../Images/ch02/02fig26.jpg"><p class="fig-caption"><strong>Fig. 26.</strong> A triply linked tree.</p></div>
<p class="indent">It is clear that the <code>PARENT</code> link all by itself is enough to specify any <em>oriented</em> tree (or forest) completely. For we can draw the diagram of the tree if we know all the upward links. Every node except the root has just one parent, but there may be several children; so it is simpler to give upward links than downward ones. Why then haven’t we considered upward links much earlier in our discussion? The answer, of course, is that upward links by themselves are hardly adequate in most situations, since it is very difficult to tell quickly if a node is terminal or not, or to locate any of its children, etc. There is, however, a very important application in which upward links are sufficient by themselves: We now turn to a brief study of an elegant algorithm for dealing with equivalence relations, due to M. J. Fischer and B. A. Galler.</p>
<p class="indent">An <em>equivalence relation</em> “≡” is a relation between the elements of a set of objects <em>S</em> satisfying the following three properties for any objects <em>x</em>, <em>y</em>, and <em>z</em> (not necessarily distinct) in <em>S</em>:</p>
<p class="indenti">i) If <em>x</em> ≡ <em>y</em> and <em>y</em> ≡ <em>z</em>, then <em>x</em> ≡ <em>z</em>. (Transitivity.)</p>
<p class="indenti">ii) If <em>x</em> ≡ <em>y</em>, then <em>y</em> ≡ <em>x</em>. (Symmetry.)</p>
<p class="indenti">iii) <em>x</em> ≡ <em>x</em>. (Reflexivity.)</p>
<p class="noindent">(Compare this with the definition of a partial ordering relation in <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a>; equivalence relations are quite different from partial orderings, in spite of the fact that two of the three defining properties are the same.) Examples of equivalence relations are the relation “=”, the relation of congruence (modulo <em>m</em>) for integers, the relation of similarity between trees as defined in <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a>, etc.</p>
<p class="indent"><a id="page_354"></a>The equivalence problem is to read in pairs of equivalent elements and to determine later whether two particular elements can be proved equivalent or not on the basis of the given pairs. For example, suppose that <em>S</em> is the set {1, 2, 3, 4, 5, 6, 7, 8, 9} and suppose that we are given the pairs</p>
<div class="equation"><a id="ch02eq-lev2sec9-11"></a><img src="../Images/ch02/354equ01.jpg"></div>
<p class="noindent">It follows that, for example, 2 ≡ 6, since 2 ≡ 7 ≡ 3 ≡ 9 ≡ 8 ≡ 6. But we cannot show that 1 ≡ 6. In fact, the pairs (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>) divide <em>S</em> into two classes</p>
<div class="equation"><a id="ch02eq-lev2sec9-12"></a><img src="../Images/ch02/354equ02.jpg"></div>
<p class="noindent">such that two elements are equivalent if and only if they belong to the same class. It is not difficult to prove that <em>any</em> equivalence relation partitions its set <em>S</em> into disjoint classes (called the <em>equivalence classes</em>), such that two elements are equivalent if and only if they belong to the same class.</p>
<p class="indent">Therefore a solution to the equivalence problem is a matter of keeping track of equivalence classes like (<a href="../Text/ch02a.html#ch02eq-lev2sec9-12">12</a>). We may start with each element alone in its class, thus:</p>
<div class="equation"><a id="ch02eq-lev2sec9-13"></a><img src="../Images/ch02/354equ03.jpg"></div>
<p class="noindent">Now if we are given the relation 1 ≡ 5, we put {1, 5} together in a class. After processing the first three relations 1 ≡ 5, 6 ≡ 8, and 7 ≡ 2, we will have changed (<a href="../Text/ch02a.html#ch02eq-lev2sec9-13">13</a>) to</p>
<div class="equation"><a id="ch02eq-lev2sec9-14"></a><img src="../Images/ch02/354equ04.jpg"></div>
<p class="noindent">Now the pair 9 ≡ 8 puts {6, 8, 9} together, etc.</p>
<p class="indent">The problem is to find a good way to represent situations like (<a href="../Text/ch02a.html#ch02eq-lev2sec9-12">12</a>), (<a href="../Text/ch02a.html#ch02eq-lev2sec9-13">13</a>), and (<a href="../Text/ch02a.html#ch02eq-lev2sec9-14">14</a>) within a computer so that we can efficiently perform the operations of merging classes together and of testing whether two given elements are in the same class. The algorithm below uses oriented tree structures for this purpose: The elements of <em>S</em> become nodes of an oriented forest; and two nodes are equivalent, as a consequence of the equivalent pairs read so far, <em>if and only if they belong to the same tree</em>. This test is easy to make, since two elements are in the same tree if and only if they are below the same root element. Furthermore, it is easy to merge two oriented trees together, by simply attaching one as a new subtree of the other’s root.</p>
<p class="noindent"><a id="ch02alg-lev2sec9-E"></a><strong>Algorithm E</strong> (<em>Process equivalence relations</em>). Let <em>S</em> be the set of numbers {1, 2, ..., <em>n</em>}, and let <code>PARENT[</code>1<code>]</code>, <code>PARENT[</code>2<code>]</code>, ..., <code>PARENT[</code><em>n</em><code>]</code> be integer variables. This algorithm inputs a set of relations such as (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>) and adjusts the <code>PARENT</code> table to represent a set of oriented trees, so that two elements are equivalent as a consequence of the given relations if and only if they belong to the same tree. (<em>Note:</em> In a more general situation, the elements of <em>S</em> would be symbolic names instead of simply the numbers from 1 to <em>n</em>; then a search routine, as in Chapter 6, would locate nodes corresponding to the elements of <em>S</em>, and <code>PARENT</code> would be a field in each node. The modifications for this more general case are straightforward.)</p>
<p class="indenthanging"><a id="page_355"></a><strong>E1.</strong> [Initialize.] Set <code>PARENT</code>[<em>k</em>] ← 0 for 1 ≤ <em>k</em> ≤ <em>n</em>. (This means that all trees initially consist of a root alone, as in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-13">13</a>).)</p>
<p class="indenthanging"><strong>E2.</strong> [Input new pair.] Get the next pair of equivalent elements “<em>j</em> ≡ <em>k</em>” from the input. If the input is exhausted, the algorithm terminates.</p>
<p class="indenthanging"><strong>E3.</strong> [Find roots.] If <code>PARENT[</code><em>j</em><code>]</code> &gt; 0, set <em>j</em> ← <code>PARENT[</code><em>j</em><code>]</code> and repeat this step. If <code>PARENT[</code><em>k</em><code>]</code> &gt; 0, set <em>k</em> ← <code>PARENT[</code><em>k</em><code>]</code> and repeat this step. (After this operation, <em>j</em> and <em>k</em> have moved up to the roots of two trees that are to be made equivalent. The input relation <em>j</em> ≡ <em>k</em> was redundant if and only if we now have <em>j</em> = <em>k</em>.)</p>
<p class="indenthanging"><strong>E4.</strong> [Merge trees.] If <em>j</em> ≠ <em>k</em>, set <code>PARENT[</code><em>j</em><code>]</code> ← <em>k</em>. Go back to step E2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">The reader should try this algorithm on the input (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>). After processing 1 ≡ 5, 6 ≡ 8, 7 ≡ 2, and 9 ≡ 8, we will have</p>
<div class="equation"><a id="ch02eq-lev2sec9-15"></a><img src="../Images/ch02/355equ01.jpg"></div>
<p class="noindent">which represents the trees</p>
<div class="equation"><a id="ch02eq-lev2sec9-16"></a><img src="../Images/ch02/355equ02.jpg"></div>
<p class="noindent">After this point, the remaining relations of (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>) are somewhat more interesting; see <a href="../Text/ch02b.html#ch02ex_2_9_9">exercise 9</a>.</p>
<p class="indent">This equivalence problem arises in many applications. We will discuss significant refinements of <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> in Section 7.4.1, when we study the connectivity of graphs. A more general version of the problem, which arises when a compiler processes “equivalence declarations” in languages like <code>FORTRAN</code>, is discussed in <a href="../Text/ch02b.html#ch02ex_2_9_11">exercise 11</a>.</p>
<p class="indent">There are still more ways to represent trees in computer memory. Recall that we discussed three principal methods for representing linear lists in <a href="../Text/ch02.html#ch02lev1sec2">Section 2.2</a>: the straight representation with terminal link <em>Λ</em>, the circularly linked lists, and the doubly linked lists. The representation of unthreaded binary trees described in <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a> corresponds to a straight representation in both <code>LLINK</code>s and <a id="page_356"></a><a id="page_357"></a><code>RLINK</code>s. It is possible to get eight other binary tree representations by independently using any of these three methods in the <code>LLINK</code> and <code>RLINK</code> directions. For example, <a href="../Text/ch02a.html#ch02fig27">Fig. 27</a> shows what we get if circular linking is used in both directions. If circular links are used throughout as in the figure, we have what is called a <em>ring structure</em>; ring structures have proved to be quite flexible in a number of applications. The proper choice of representation depends, as always, on the types of insertions, deletions, and traversals that are needed in the algorithms that manipulate these structures. A reader who has looked over the examples given so far in this chapter should have no difficulty understanding how to deal with any of these memory representations.</p>
<div class="image"><a id="ch02fig27"></a><img src="../Images/ch02/02fig27.jpg"><p class="fig-caption"><strong>Fig. 27.</strong> A ring structure.</p></div>
<p class="indent">We close this section with an example of modified doubly linked ring structures applied to a problem we have considered before: arithmetic on polynomials. <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm 2.2.4A</a> performs the addition of one polynomial to another, given that the two polynomials are expressed as circular lists; various other algorithms in that section give other operations on polynomials. However, the polynomials of <a href="../Text/ch02.html#ch02lev2sec4">Section 2.2.4</a> are restricted to at most three variables. When multi-variable polynomials are involved, it is usually more appropriate to use a tree structure instead of a linear list.</p>
<p class="indent">A polynomial either is a constant or has the form</p>
<div class="image"><img src="../Images/ch02/e357_01.jpg"></div>
<p class="noindent">where <em>x</em> is a variable, <em>n</em> &gt; 0, 0 = <em>e</em><sub>0</sub> &lt; <em>e</em><sub>1</sub> &lt; · · · &lt; <em>e</em><sub><em>n</em></sub>, and <em>g</em><sub>0</sub>, ..., <em>g</em><sub><em>n</em></sub> are polynomials involving only variables alphabetically less than <em>x</em>; <em>g</em><sub>1</sub>, ..., <em>g</em><sub><em>n</em></sub> are not zero. This recursive definition of polynomials lends itself to tree representation as indicated in <a href="../Text/ch02a.html#ch02fig28">Fig. 28</a>. Nodes have six fields, which in the case of <code>MIX</code> might fit in three words:</p>
<div class="equation"><a id="ch02eq-lev2sec9-17"></a><img src="../Images/ch02/357equ01.jpg"></div>
<div class="image"><a id="ch02fig28"></a><img src="../Images/ch02/02fig28.jpg"><p class="fig-caption"><strong>Fig. 28.</strong> Representation of polynomials using four-directional links. Shaded areas of nodes indicate information that is irrelevant in the context considered.</p></div>
<p class="noindent">Here <code>LEFT</code>, <code>RIGHT</code>, <code>UP</code>, and <code>DOWN</code> are links; <code>EXP</code> is an integer representing an exponent; and <code>CV</code> is either a constant (coefficient) or the alphabetic name of a variable. The root node has <code>UP</code> = <em>Λ</em>, <code>EXP</code> = 0, <code>LEFT</code> = <code>RIGHT</code> = <code>*</code> (self).</p>
<p class="indent">The following algorithm illustrates traversal, insertion, and deletion in such a four-way-linked tree, so it bears careful study.</p>
<p class="noindent"><a id="ch02alg-lev2sec9-A"></a><strong>Algorithm A</strong> (<em>Addition of polynomials</em>). This algorithm adds polynomial<code>(P)</code> to polynomial<code>(Q)</code>, assuming that <code>P</code> and <code>Q</code> are pointer variables that link to the roots of distinct polynomial trees having the form shown in <a href="../Text/ch02a.html#ch02fig28">Fig. 28</a>. At the conclusion of the algorithm, polynomial<code>(P)</code> will be unchanged, and polynomial<code>(Q)</code> will contain the sum.</p>
<p class="indenthanging"><strong>A1.</strong> [Test type of polynomial.] If <code>DOWN(P)</code> = <em>Λ</em> (that is, if <code>P</code> points to a constant), then set <code>Q</code> ← <code>DOWN(Q)</code> zero or more times until <code>DOWN(Q)</code> = <em>Λ</em> <a id="page_358"></a>and go to A3. If <code>DOWN(P)</code> ≠ <em>Λ</em>, then if <code>DOWN(Q)</code> = <em>Λ</em> or if <code>CV(Q)</code> &lt; <code>CV(P)</code>, go to A2. Otherwise if <code>CV(Q)</code> = <code>CV(P)</code>, set <code>P</code> ← <code>DOWN(P)</code>, <code>Q</code> ← <code>DOWN(Q)</code> and repeat this step; if <code>CV(Q)</code> &gt; <code>CV(P)</code>, set <code>Q</code> ← <code>DOWN(Q)</code> and repeat this step. (Step A1 either finds two matching terms of the polynomials or else determines that an insertion of a new variable must be made into the current part of polynomial<code>(Q)</code>.)</p>
<p class="indenthanging"><strong>A2.</strong> [Downward insertion.] Set <code>R</code> <span class="ent">⇐</span> <code>AVAIL</code>, S ← <code>DOWN(Q)</code>. If <code>S</code> ≠ <em>Λ</em>, set <code>UP(S)</code> ← <code>R</code>, <code>S</code> ← <code>RIGHT(S)</code> and if <code>EXP(S)</code> ≠ 0, repeat this operation until ultimately <code>EXP(S)</code> = 0. Set <code>UP(R)</code> ← Q, <code>DOWN(R)</code> ← <code>DOWN(Q)</code>, <code>LEFT(R)</code> ← <code>R</code>, <code>RIGHT(R)</code> ← <code>R</code>, <code>CV(R)</code> ← <code>CV(Q)</code> and <code>EXP(R)</code> ← 0. Finally, set <code>CV(Q)</code> ← <code>CV(P)</code> and <code>DOWN(Q)</code> ← <code>R</code>, and return to A1. (We have inserted a “dummy” zero polynomial just below <code>NODE(Q)</code>, to obtain a match with a corresponding polynomial found within <code>P</code>’s tree. The link manipulations done in this step are straightforward and may be derived easily using “before-and-after” diagrams, as explained in <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a>.)</p>
<p class="indenthanging"><strong>A3.</strong> [Match found.] (At this point, <code>P</code> and <code>Q</code> point to corresponding terms of the given polynomials, so addition is ready to proceed.) Set <code>CV(Q)</code> ← <code>CV(Q)</code> + <code>CV(P)</code>. If this sum is zero and if <code>EXP(Q)</code> ≠ 0, go to step A8. If <code>EXP(Q)</code> = 0, go to A7.</p>
<p class="indenthanging"><strong>A4.</strong> [Advance to left.] (After successfully adding a term, we look for the next term to add.) Set <code>P</code> ← <code>LEFT(P)</code>. If <code>EXP(P)</code> = 0, go to A6. Otherwise set <code>Q</code> ← <code>LEFT(Q)</code> one or more times until <code>EXP(Q)</code> ≤ <code>EXP(P)</code>. If then <code>EXP(Q)</code> = <code>EXP(P)</code>, return to step A1.</p>
<p class="indenthanging"><strong>A5.</strong> [Insert to right.] Set <code>R</code> <span class="ent">⇐</span> <code>AVAIL</code>. Set <code>UP(R)</code> ← <code>UP(Q)</code>, <code>DOWN(R)</code> ← <em>Λ</em>, <code>CV(R)</code> ← 0, <code>LEFT(R)</code> ← <code>Q</code>, <code>RIGHT(R)</code> ← <code>RIGHT(Q)</code>, <code>LEFT(RIGHT(R)</code>) ← <code>R</code>, <code>RIGHT(Q)</code> ← <code>R</code>, <code>EXP(R)</code> ← <code>EXP(P)</code>, and <code>Q</code> ← <code>R</code>. Return to step A1. (We needed to insert a new term in the current row, just to the right of <code>NODE(Q)</code>, in order to match a corresponding exponent in polynomial<code>(P)</code>. As in step A2, a “before-and-after” diagram makes the operations clear.)</p>
<p class="indenthanging"><strong>A6.</strong> [Return upward.] (A row of polynomial<code>(P)</code> has now been completely traversed.) Set <code>P</code> ← <code>UP(P)</code>.</p>
<p class="indenthanging"><strong>A7.</strong> [Move <code>Q</code> up to right level.] If <code>UP(P)</code> = <em>Λ</em>, go to A11; otherwise set <code>Q</code> ← <code>UP(Q)</code> zero or more times until <code>CV(UP(Q))</code> = <code>CV(UP(P))</code>. Return to step A4.</p>
<p class="indenthanging"><strong>A8.</strong> [Delete zero term.] Set <code>R</code> ← <code>Q</code>, <code>Q</code> ← <code>RIGHT(R)</code>, <code>S</code> ← <code>LEFT(R)</code>, <code>LEFT(Q)</code> ← <code>S</code>, <code>RIGHT(S)</code> ← <code>Q</code>, and <code>AVAIL</code> <span class="ent">⇐</span> <code>R</code>. (Cancellation occurred, so a row element of polynomial<code>(Q)</code> is deleted.) If now <code>EXP(LEFT(P))</code> = 0 and <code>Q</code> = <code>S</code>, go to A9; otherwise return to A4.</p>
<p class="indenthanging"><strong>A9.</strong> [Delete constant polynomial.] (Cancellation has caused a polynomial to reduce to a constant, so a row of polynomial(<code>Q)</code> is deleted.) Set <code>R</code> ← <code>Q</code>, <code>Q</code> ← <code>UP(Q)</code>, <code>DOWN(Q)</code> ← <code>DOWN(R)</code>, <code>CV(Q)</code> ← <code>CV(R)</code>, and <code>AVAIL</code> <span class="ent">⇐</span> <code>R</code>. Set <code>S</code> ← <code>DOWN(Q)</code>; if <code>S</code> ≠ <em>Λ</em>, set <code>UP(S)</code> ← <code>Q</code>, <code>S</code> ← <code>RIGHT(S)</code>, and if <code>EXP(S)</code> ≠ 0, repeat this operation until ultimately <code>EXP(S)</code> = 0.</p>
<p class="indenthanging1"><a id="page_359"></a><strong>A10.</strong> [Zero detected?] If <code>DOWN(Q)</code> = <em>Λ</em>, <code>CV(Q)</code> = 0, and <code>EXP(Q)</code> ≠ 0, set <code>P</code> ← <code>UP(P)</code> and go to A8; otherwise go to A6.</p>
<p class="indenthanging1"><strong>A11.</strong> [Terminate.] Set <code>Q</code> ← <code>UP(Q)</code> zero or more times until <code>UP(Q)</code> = <em>Λ</em> (thus bringing <code>Q</code> to the root of the tree). <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>
<p class="indent">This algorithm will actually run much faster than <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm 2.2.4A</a> if polynomial<code>(P)</code> has few terms and polynomial<code>(Q)</code> has many, since it is not necessary to pass over all of polynomial<code>(Q)</code> during the addition process. The reader will find it instructive to simulate <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a> by hand, adding the polynomial <em>xy</em> − <em>x</em><sup>2</sup> − <em>xyz</em> − <em>z</em><sup>3</sup> + 3<em>xz</em><sup>3</sup> to the polynomial shown in <a href="../Text/ch02a.html#ch02fig28">Fig. 28</a>. (This case does not demonstrate the efficiency of the algorithm, but it makes the algorithm go through all of its paces by showing the difficult situations that must be handled.) For further commentary on <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a>, see <a href="../Text/ch02b.html#ch02ex_2_9_12">exercises 12</a> and <a href="../Text/ch02b.html#ch02ex_2_9_13">13</a>.</p>
<p class="indent">No claim is being made here that the representation shown in <a href="../Text/ch02a.html#ch02fig28">Fig. 28</a> is the “best” for polynomials in several variables; in Chapter 8 we will consider another format for polynomial representation, together with arithmetic algorithms using an auxiliary stack, with significant advantages of conceptual simplicity when compared to <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a>. Our main interest in <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a> is the way it typifies manipulations on trees with many links.</p>
</body></html>