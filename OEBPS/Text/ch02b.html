<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$","$"]],
        displayMath: [["$$","$$"]],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  <title></title>
  <link href="../Styles/caps.css" rel="stylesheet" type="text/css">
</head>

<body>
  <p class="ex-title">Exercises</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_1a" id="ch02ex_2_9_1">1</a>.</strong> [<em>20</em>] If we had only <code>LTAG</code>, <code>INFO</code>, and <code>RTAG</code> fields (not <code>LLINK</code>) in a level order sequential representation like (<a href="../Text/ch02a.html#ch02eq-lev2sec9-8">8</a>), would it be possible to reconstruct the <code>LLINK</code>s? (In other words, are the <code>LLINK</code>s redundant in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-8">8</a>), as the <code>RLINK</code>s are in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>)?)</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_2a" id="ch02ex_2_9_2">2</a>.</strong> [<em>22</em>] (Burks, Warren, and Wright, <em>Math. Comp.</em> <strong>8</strong> (1954), 53–57.) The trees (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) stored in <em>preorder</em> with degrees would be</p>

  <div class="image"><img src="../Images/ch02/e359_01.jpg"></div>

  <p class="exercisesp">[compare with (<a href="../Text/ch02a.html#ch02eq-lev2sec9-9">9</a>), where postorder was used]. Design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> to evaluate a locally defined function of the nodes by going from right to left in this representation.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_3a" id="ch02ex_2_9_3">3</a>.</strong> [<em>24</em>] Modify <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm 2.3.2D</a> so that it follows the ideas of <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a>, placing the derivatives it computes as intermediate results on a stack, instead of recording their locations in an anomalous fashion as is done in step D3. (See <a href="../Text/ch02a.html#ch02lev2sec8">exercise 2.3.2</a>–<a href="../Text/ch02a.html#ch02ex_2_8_21">21</a>.) The stack may be maintained by using the <code>RLINK</code> field in the root of each derivative.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_4a" id="ch02ex_2_9_4">4</a>.</strong> [<em>18</em>] The trees (<a href="../Text/ch02a.html#ch02eq-lev2sec9-2">2</a>) contain 10 nodes, five of which are terminal. Representation of these trees in the normal binary-tree fashion involves 10 <code>LLINK</code> fields and 10 <code>RLINK</code> fields (one for each node). Representation of these trees in the form (<a href="../Text/ch02a.html#ch02eq-lev2sec9-10">10</a>), where <code>LLINK</code> and <code>INFO</code> share the same space in a node, requires 5 <code>LLINK</code>s and 15 <code>RLINK</code>s. There are 10 <code>INFO</code> fields in each case.</p>

  <p class="indent">Given a forest with <em>n</em> nodes, <em>m</em> of which are terminal, compare the total number of <code>LLINK</code>s and <code>RLINK</code>s that must be stored using these two methods of tree representation.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_5a" id="ch02ex_2_9_5">5</a>.</strong> [<em>16</em>] A triply linked tree, as shown in <a href="../Text/ch02a.html#ch02fig26">Fig. 26</a>, contains <code>PARENT</code>, <code>LCHILD</code>, and <code>RLINK</code> fields in each node, with liberal use of <em>Λ</em>-links when there is no appropriate node to mention in the <code>PARENT</code>, <code>LCHILD</code>, or <code>RLINK</code> field. Would it be a good idea to extend this <a id="page_360"></a>representation to a <em>threaded</em> tree, by putting “thread” links in place of the null <code>LCHILD</code> and <code>RLINK</code> entries, as we did in <a href="../Text/ch02a.html#ch02lev2sec7">Section 2.3.1</a>?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_6a" id="ch02ex_2_9_6">6</a>.</strong> [<em>24</em>] Suppose that the nodes of an <em>oriented</em> forest have three link fields, <code>PARENT</code>, <code>LCHILD</code>, and <code>RLINK</code>, but only the <code>PARENT</code> link has been set up to indicate the tree structure. The <code>LCHILD</code> field of each node is <em>Λ</em> and the <code>RLINK</code> fields are set as a linear list that simply links the nodes together in some order. The link variable <code>FIRST</code> points to the first node, and the last node has <code>RLINK</code> = <em>Λ</em>.</p>

  <p class="indent">Design an algorithm that goes through these nodes and fills in the <code>LCHILD</code> and <code>RLINK</code> fields compatible with the <code>PARENT</code> links, so that a triply linked tree representation like that in <a href="../Text/ch02a.html#ch02fig26">Fig. 26</a> is obtained. Also, reset <code>FIRST</code> so that it now points to the root of the first tree in this representation.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_7a" id="ch02ex_2_9_7">7</a>.</strong> [<em>15</em>] What classes would appear in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-12">12</a>) if the relation 9 ≡ 3 had not been given in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>)?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_8a" id="ch02ex_2_9_8">8</a>.</strong> [<em>15</em>] <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> sets up a tree structure that represents the given pairs of equivalent elements, but the text does not mention explicitly how the result of <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> can be used. Design an algorithm that answers the question, “Is <em>j</em> ≡ <em>k</em>?”, assuming that 1 ≤ <em>j</em> ≤ <em>n</em>, 1 ≤ <em>k</em> ≤ <em>n</em>, and that <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> has set up the <code>PARENT</code> table for some set of equivalences.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_2_9_9a" id="ch02ex_2_9_9">9</a>.</strong> [<em>20</em>] Give a table analogous to (<a href="../Text/ch02a.html#ch02eq-lev2sec9-15">15</a>) and a diagram analogous to (<a href="../Text/ch02a.html#ch02eq-lev2sec9-16">16</a>) that shows the trees present after <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> has processed all of the equivalences in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-11">11</a>) from left to right.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_10a" id="ch02ex_2_9_10">10</a>.</strong> [<em>28</em>] In the worst case, <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> may take order <em>n</em><sup>2</sup> steps to process <em>n</em> equivalences. Show how to modify the algorithm so that the worst case is not this bad.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_11a" id="ch02ex_2_9_11">11</a>.</strong> [<em>24</em>] (<em>Equivalence declarations</em>.) Several compiler languages, notably <code>FORTRAN</code>, provide a facility for overlapping the memory locations assigned to sequentially stored tables. The programmer gives the compiler a set of relations of the form <code>X</code><code>[</code><em>j</em><code>]</code> ≡ <code>Y[</code><em>k</em><code>]</code>, which means that variable <code>X[</code><em>j</em> + <em>s</em><code>]</code> is to be assigned to the same location as variable <code>Y[</code><em>k</em> + <em>s</em><code>]</code> for all <em>s</em>. Each variable is also given a range of allowable subscripts: “<code>ARRAY X[</code><em>l</em>:<em>u</em><code>]</code>” means that space is to be set aside in memory for the table entries <code>X[</code><em>l</em><code>]</code>, <code>X[</code><em>l</em> + 1<code>]</code>, ..., <code>X[</code><em>u</em><code>]</code>. For each equivalence class of variables, the compiler reserves as small a block of consecutive memory locations as possible, to contain all the table entries for the allowable subscript values of these variables.</p>

  <p class="indent">For example, suppose we have <code>ARRAY X[</code>0:10<code>]</code>, <code>ARRAY Y[</code>3:10<code>]</code>, <code>ARRAY A[</code>1:1<code>]</code>, and <code>ARRAY Z[</code>−2:0<code>]</code>, plus the equivalences <code>X[</code>7<code>]</code> ≡ <code>Y[</code>3<code>]</code>, <code>Z[</code>0<code>]</code> ≡ <code>A[</code>0<code>]</code>, and <code>Y[</code>1<code>]</code> ≡ <code>A[</code>8<code>]</code>. We must set aside 20 consecutive locations</p>

  <div class="image"><img src="../Images/ch02/e360_01.jpg"></div>

  <p class="noindent">for these variables. (The location following <code>A[</code>1<code>]</code> is not an allowable subscript value for any of the arrays, but it must be reserved anyway.)</p>

  <p class="indent">The object of this exercise is to modify <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a> so that it applies to the more general situation just described. Assume that we are writing a compiler for such a language, and the tables inside our compiler program itself have one node for each array, containing the fields <code>NAME</code>, <code>PARENT</code>, <code>DELTA</code>, <code>LBD</code>, and <code>UBD</code>. Assume that the compiler program has previously processed all the <code>ARRAY</code> declarations, so that if <a id="page_361"></a><code>ARRAY X[</code><em>l</em>:<em>u</em><code>]</code> has appeared and if <code>P</code> points to the node for <code>X</code>, then</p>

  <p class="center"><code>NAME(P)</code> = “<code>X</code>”, <code>PARENT(P)</code> = <em>Λ,</em> <code>DELTA(P)</code> = 0<em>,</em></p>

  <p class="center"><code>LBD(P)</code> = <em>l</em>, <code>UBD(P)</code> = <em>u.</em></p>

  <p class="noindent">The problem is to design an algorithm that processes the equivalence declarations, so that, after this algorithm has been performed,</p>

  <p class="uln-indent"><code>PARENT(P)</code> = <em>Λ</em> means that locations <code>X[</code><code>LBD(P)</code><code>]</code><em>, ...,</em> <code>X[</code><code>UBD(P)]</code> are to be reserved in memory for this equivalence class;</p>

  <p class="uln-indent"><code>PARENT(P)</code> = <code>Q</code> ≠ <em>Λ</em> means that location <code>X[</code><em>k</em><code>]</code> equals location <code>Y[</code><em>k</em> + <code>DELTA(P)]</code>, where <code>NAME(Q)</code> = “<code>Y</code>”.</p>

  <p class="noindent">For example, before the equivalences listed above we might have the nodes</p>

  <div class="image"><img src="../Images/ch02/361tab01.jpg"></div>

  <p class="noindent">After the equivalences are processed, the nodes might appear thus:</p>

  <div class="image"><img src="../Images/ch02/361tab02.jpg"></div>

  <p class="noindent">(“*” denotes irrelevant information.)</p>

  <p class="indent">Design an algorithm that makes this transformation. Assume that inputs to your algorithm have the form (<code>P</code><em>, j</em>, <code>Q</code>, <em>k</em>), denoting <code>X[</code> <em>j</em><code>]</code> ≡ <code>Y[</code><em>k</em><code>]</code>, where <code>NAME(P)</code> = “<code>X</code>” and <code>NAME(Q)</code> = “<code>Y</code>”. Be sure to check whether the equivalences are contradictory; for example, <code>X[</code>1<code>]</code> ≡ <code>Y[</code>2<code>]</code> contradicts <code>X[</code>2<code>]</code> ≡ <code>Y[</code>1<code>]</code>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_12a" id="ch02ex_2_9_12">12</a>.</strong> [<em>21</em>] At the beginning of <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a>, the variables <code>P</code> and <code>Q</code> point to the roots of two trees. Let <code>P</code><sub>0</sub> and <code>Q</code><sub>0</sub> denote the values of <code>P</code> and <code>Q</code> before execution of <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a>. (a) After the algorithm terminates, is <code>Q</code><sub>0</sub> always the address of the root of the sum of the two given polynomials? (b) After the algorithm terminates, have <code>P</code> and <code>Q</code> returned to their original values <code>P</code><sub>0</sub> and <code>Q</code><sub>0</sub> ?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_13a" id="ch02ex_2_9_13">13</a>.</strong> [<em>M29</em>] Give an informal proof that at the beginning of step A8 of <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a> we always have <code>EXP(P)</code> = <code>EXP(Q)</code> and <code>CV(UP(P))</code> = <code>CV(UP(Q))</code>. (This fact is important to the proper understanding of that algorithm.)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_14a" id="ch02ex_2_9_14">14</a>.</strong> [<em>40</em>] Give a formal proof (or disproof) of the validity of <a href="../Text/ch02a.html#ch02alg-lev2sec9-A">Algorithm A</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_15a" id="ch02ex_2_9_15">15</a>.</strong> [<em>40</em>] Design an algorithm to compute the product of two polynomials represented as in <a href="../Text/ch02a.html#ch02fig28">Fig. 28</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_16a" id="ch02ex_2_9_16">16</a>.</strong> [<em>M24</em>] Prove the validity of <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a>.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_17a" id="ch02ex_2_9_17">17</a>.</strong> [<em>25</em>] <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> evaluates a “bottom-up” locally defined function, namely, one that should be evaluated at the children of a node before it is evaluated at the node. A “top-down” locally defined function <em>f</em> is one in which the value of <em>f</em> at a node <em>x</em> depends only on <em>x</em> and the value of <em>f</em> at the <em>parent</em> of <em>x</em>. Using an auxiliary stack, design an algorithm analogous to <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> that evaluates a “top-down” function <em>f</em> at each node of a tree. (Like <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a>, your algorithm should work efficiently on trees that have been stored in <em>postorder</em> with degrees, as in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-9">9</a>).)</p>

  <p class="exercises3"><a id="page_362"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_2_9_18a" id="ch02ex_2_9_18">18</a>.</strong> [<em>28</em>] Design an algorithm that, given the two tables <code>INFO1[</code> <em>j</em><code>]</code> and <code>RLINK[</code> <em>j</em><code>]</code> for 1 ≤ <em>j</em> ≤ <em>n</em> corresponding to preorder sequential representation, forms tables <code>INFO2[</code><em>j</em><code>]</code> and <code>DEGREE[</code><em>j</em><code>]</code> for 1 ≤ <em>j</em> ≤ <em>n</em>, corresponding to postorder with degrees. For example, according to (<a href="../Text/ch02a.html#ch02eq-lev2sec9-3">3</a>) and (<a href="../Text/ch02a.html#ch02eq-lev2sec9-9">9</a>), your algorithm should transform</p>

  <div class="image"><img src="../Images/ch02/362tab01.jpg"></div>

  <p class="uln-indent">into</p>

  <div class="image"><img src="../Images/ch02/362tab02.jpg"></div>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_2_9_19a" id="ch02ex_2_9_19">19</a>.</strong> [<em>M27</em>] Instead of using <code>SCOPE</code> links in (<a href="../Text/ch02a.html#ch02eq-lev2sec9-5">5</a>), we could simply list the number of descendants of each node, in preorder:</p>

  <div class="image"><img src="../Images/ch02/362tab03.jpg"></div>

  <p class="exercisesp">Let <em>d</em><sub>1</sub><em>d</em><sub>2</sub> ... <em>d</em><sub><em>n</em></sub> be the sequence of descendant numbers of a forest, obtained in this way.</p>

  <p class="indenthangingA">a) Show that <em>k</em> +<em>d</em><sub><em>k</em></sub> ≤ <em>n</em> for 1 ≤ <em>k</em> ≤ <em>n</em>, and that <em>k</em> ≤ <em>j</em> ≤ <em>k</em> +<em>d</em><sub><em>k</em></sub> implies <em>j</em> +<em>d</em><sub><em>j</em></sub> ≤ <em>k</em> +<em>d</em><sub><em>k</em></sub>.</p>

  <p class="indenthangingA">b) Conversely, prove that if <em>d</em><sub>1</sub><em>d</em><sub>2</sub> ... <em>d</em><sub><em>n</em></sub> is a sequence of nonnegative integers satisfying the conditions of (a), it is the sequence of descendant numbers of a forest.</p>

  <p class="indenthangingA">c) Suppose <em>d</em><sub>1</sub><em>d</em><sub>2</sub> ... <em>d</em><sub><em>n</em></sub> and <em>d</em>′<sub>1</sub><em>d</em>′<sub>2</sub> ... <em>d</em>′<sub><em>n</em></sub> are the descendant number sequences for two forests. Prove that there is a third forest whose descendant numbers are</p>

  <p class="center">min(<em>d</em><sub>1</sub>, <em>d</em>′<sub>1</sub>) min(<em>d</em><sub>2</sub>, <em>d</em>′<sub>2</sub>) ... min(<em>d</em><sub><em>n</em></sub>, <em>d</em>′<sub><em>n</em></sub>).</p>

  <div class="heading">
    <h4 id="ch02lev2sec10">2.3.4. Basic Mathematical Properties of Trees</h4>

    <p class="noindent">Tree structures have been the object of extensive mathematical investigations for many years, long before the advent of computers, and many interesting facts have been discovered about them. In this section we will survey the mathematical theory of trees, which not only gives us more insight into the nature of tree structures but also has important applications to computer algorithms.</p>
  </div>

  <p class="indent">Nonmathematical readers are advised to skip to subsection <a href="../Text/ch02b.html#ch02lev3sec5">2.3.4.5</a>, which discusses several topics that arise frequently in the applications we shall study later.</p>

  <p class="indent">The material that follows comes mostly from a larger area of mathematics known as the theory of graphs. Unfortunately, there will probably never be a standard terminology in this field, and so the author has followed the usual practice of contemporary books on graph theory, namely to use words that are similar but not identical to the terms used in any <em>other</em> books on graph theory. An attempt has been made in the following subsections (and, indeed, throughout this book) to choose short, descriptive words for the important concepts, selected from those that are in reasonably common use and that do not sharply conflict with other common terminology. The nomenclature used here is also biased towards computer applications. Thus, an electrical engineer may prefer to call a “tree” what we call a “free tree”; but we want the shorter term “tree” to stand for the concept that is generally used in the computer literature and that is so much more important in computer applications. If we were to follow the terminology of some authors on graph theory, we would have to say “finite labeled rooted ordered tree” instead of just “tree,” and “topological bifurcating arborescence” instead of “binary tree”!</p>

  <div class="heading">
    <h5 id="ch02lev3sec1"><a id="page_363"></a>2.3.4.1. Free trees</h5>

    <p class="noindent">A <em>graph</em> is generally defined to be a set of points (called <em>vertices</em>) together with a set of lines (called <em>edges</em>) joining certain pairs of distinct vertices. There is at most one edge joining any pair of vertices. Two vertices are called <em>adjacent</em> if there is an edge joining them. If <em>V</em> and <em>V</em>′ are vertices and if <em>n</em> ≥ 0, we say that (<em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub>) is a <em>walk</em> of length <em>n</em> from <em>V</em> to <em>V</em>′ if <em>V</em> = <em>V</em><sub>0</sub>, <em>V</em><sub><em>k</em></sub> is adjacent to <em>V</em><sub><em>k</em>+1</sub> for 0 ≤ <em>k</em> &lt; <em>n</em>, and <em>V</em><sub><em>n</em></sub> = <em>V</em>′. The walk is a <em>path</em> if vertices <em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub> are distinct; it is a <em>cycle</em> if <em>V</em><sub>0</sub> through <em>V</em><sub><em>n</em> – 1</sub> are distinct, <em>V</em><sub><em>n</em></sub> = <em>V</em><sub>0</sub>, and <em>n</em> ≥ 3. Sometimes we are less precise, and refer to a cycle as “a path from a vertex to itself.” We often speak of a “simple path” to emphasize the fact that we’re talking about a path instead of an arbitrary walk. A graph is <em>connected</em> if there is a path between any two vertices of the graph.</p>
  </div>

  <p class="indent">These definitions are illustrated in <a href="../Text/ch02b.html#ch02fig29">Fig. 29</a>, which shows a connected graph with five vertices and six edges. Vertex <em>C</em> is adjacent to <em>A</em> but not to <em>B</em>; there are two paths of length two from <em>B</em> to <em>C</em>, namely (<em>B, A, C</em>) and (<em>B, D, C</em>). There are several cycles, including (<em>B, D, E, B</em>).</p>

  <div class="image">
    <a id="ch02fig29"></a><img src="../Images/ch02/02fig29.jpg">

    <p class="fig-caption"><strong>Fig. 29.</strong> A graph.</p>
  </div>

  <p class="indent">A <em>free tree</em> or “unrooted tree” (<a href="../Text/ch02b.html#ch02fig30">Fig. 30</a>) is defined to be a connected graph with no cycles. This definition applies to infinite graphs as well as to finite ones, although for computer applications we naturally are most concerned with finite trees. There are many equivalent ways to define a free tree; some of them appear in the following well-known theorem:</p>

  <p class="noindent"><a id="ch02b_the_a"></a><strong>Theorem A.</strong> <em>If G is a graph, the following statements are equivalent:</em></p>

  <p class="indenthangingA">a) <em>G is a free tree.</em></p>

  <p class="indenthangingA">b) <em>G is connected, but if any edge is deleted, the resulting graph is no longer connected.</em></p>

  <p class="indenthangingA">c) <em>If <em>V</em> and <em>V</em>′ are distinct vertices of <em>G</em>, there is exactly one simple path from <em>V</em> to <em>V</em>′.</em></p>

  <p class="noindent"><em>Furthermore, if G is finite, containing exactly n &gt; 0 vertices, the following statements are also equivalent to</em> (a), (b), <em>and</em> (c):</p>

  <p class="indenthangingA">d) <em>G contains no cycles and has n</em> − 1 <em>edges.</em></p>

  <p class="indenthangingA">e) <em>G is connected and has n</em> − 1 <em>edges.</em></p>

  <div class="image">
    <a id="ch02fig30"></a><img src="../Images/ch02/02fig30.jpg">

    <p class="fig-caption"><strong>Fig. 30.</strong> A free tree.</p>
  </div>

  <p class="noindent"><a id="page_364"></a><em>Proof.</em> (a) implies (b), for if the edge <em>V</em> −− <em>V</em>′ is deleted but <em>G</em> is still connected, there must be a simple path (<em>V</em>, <em>V</em><sub>1</sub>, ..., <em>V</em>′) of length two or more — see <a href="../Text/ch02b.html#ch02ex_3_1_2">exercise 2</a> — and then (<em>V</em>, <em>V</em><sub>1</sub>, ..., <em>V</em>′, <em>V</em>) would be a cycle in <em>G</em>.</p>

  <p class="indent">(b) implies (c), for there is at least one simple path from <em>V</em> to <em>V</em>′. And if there were two such paths (<em>V</em>, <em>V</em><sub>1</sub>, ..., <em>V</em>′) and <span class="middle"><img src="../Images/ch02/e364_01.jpg"></span>, we could find the smallest <em>k</em> for which <span class="middle"><img src="../Images/ch02/e364_02.jpg"></span>; deleting the edge <em>V</em><sub><em>k</em>−1</sub> −− <em>V</em><sub><em>k</em></sub> would not disconnect the graph, since there would still be a path <span class="middle"><img src="../Images/ch02/e364_03.jpg"></span> from <em>V</em><sub><em>k</em>−1</sub> to <em>V</em><sub><em>k</em></sub> that does not use the deleted edge.</p>

  <p class="indent">(c) implies (a), for if <em>G</em> contains a cycle (<em>V</em>, <em>V</em><sub>1</sub>, ..., <em>V</em>), there are two simple paths from <em>V</em> to <em>V</em><sub>1</sub>.</p>

  <p class="indent">To show that (d) and (e) are also equivalent to (a), (b), and (c), let us first prove an auxiliary result: If <em>G</em> is any finite graph that has no cycles and at least one edge, then there is at least one vertex that is adjacent to exactly one other vertex. This follows because we can find some vertex <em>V</em><sub>1</sub> and an adjacent vertex <em>V</em><sub>2</sub>; for <em>k</em> ≥ 2 either <em>V</em><sub><em>k</em></sub> is adjacent to <em>V</em><sub><em>k</em>−1</sub> and no other, or it is adjacent to a vertex that we may call <em>V</em><sub><em>k</em>+1</sub> ≠ <em>V</em><sub><em>k</em>−1</sub> . Since there are no cycles, <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ..., <em>V</em><sub><em>k</em>+1</sub> must be distinct vertices, so this process must ultimately terminate.</p>

  <p class="indent">Now assume that <em>G</em> is a free tree with <em>n</em> &gt; 1 vertices, and let <em>V</em><sub><em>n</em></sub> be a vertex that is adjacent to only one other vertex, namely <em>V</em><sub><em>n</em>−1</sub> . If we delete <em>V</em><sub><em>n</em></sub> and the edge <em>V</em><sub><em>n</em> −1</sub> — <em>V</em><sub><em>n</em></sub>, the remaining graph <em>G</em>′ is a free tree, since <em>V</em><sub><em>n</em></sub> appears in no simple path of <em>G</em> except as the first or the last element. This argument proves (by induction on <em>n</em>) that <em>G</em> has <em>n</em> − 1 edges; hence (a) implies (d).</p>

  <p class="indent">Assume that <em>G</em> satisfies (d) and let <em>V</em><sub><em>n</em></sub>, <em>V</em><sub><em>n</em> −1</sub>, <em>G</em>′ be as in the preceding paragraph. Then the graph <em>G</em> is connected, since <em>V</em><sub><em>n</em></sub> is connected to <em>V</em><sub><em>n</em> −1</sub>, which (by induction on <em>n</em>) is connected to all other vertices of <em>G</em>′. Thus (d) implies (e).</p>

  <p class="indent">Finally assume that <em>G</em> satisfies (e). If <em>G</em> contains a cycle, we can delete any edge appearing in that cycle and <em>G</em> would still be connected. We can therefore continue deleting edges in this way until we obtain a connected graph <em>G</em>′ with <em>n</em> − 1 − <em>k</em> edges and no cycles. But since (a) implies (d), we must have <em>k</em> = 0, that is, <em>G</em> = <em>G</em>′. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">The idea of a free tree can be applied directly to the analysis of computer algorithms. In <a href="../Text/ch01b.html#ch01lev2sec14">Section 1.3.3</a>, we discussed the application of Kirchhoff’s first law to the problem of counting the number of times each step of an algorithm is performed; we found that Kirchhoff’s law does not completely determine the number of times each step is executed, but it reduces the number of unknowns that must be specially interpreted. The theory of trees tells us how many independent unknowns will remain, and it gives us a systematic way to find them.</p>

  <p class="indent">It is easier to understand the method that follows if an example is studied, so we will work an example as the theory is being developed. <a href="../Text/ch02b.html#ch02fig31">Figure 31</a> shows an abstracted flow chart for <a href="../Text/ch01b.html#ch01b_pro_a">Program 1.3.3A</a>, which was subjected to a “Kirchhoff’s law” analysis in <a href="../Text/ch01b.html#ch01lev2sec14">Section 1.3.3</a>. Each box in <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> represents part of the computation, and the letter or number inside the box denotes the number of times that computation will be performed during one run of the program, using the notation of <a href="../Text/ch01b.html#ch01lev2sec14">Section 1.3.3</a>. An arrow between boxes represents a possible jump in the program. The arrows have been labeled <em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, ..., <em>e</em><sub>27</sub> . Our goal is to find all relations between the quantities <em>A, B, C, D, E, F, G, H, J, K, L, P, Q, R</em>, and <em>S</em> that are implied by Kirchhoff’s law, and at the same time we hope to gain some insight into the general problem. (<em>Note:</em> Some simplifications have already been made in <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a>; for example, the box between <em>C</em> and <em>E</em> has been labeled “1”, and this in fact is a consequence of Kirchhoff’s law.)</p>

  <div class="image">
    <a id="page_365"></a><a id="ch02fig31"></a><img src="../Images/ch02/02fig31.jpg">

    <p class="fig-caption"><strong>Fig. 31.</strong> Abstracted flow chart of <a href="../Text/ch01b.html#ch01b_pro_a">Program 1.3.3A</a>.</p>
  </div>

  <p class="indent">Let <em>E</em><sub><em>j</em></sub> denote the number of times branch <em>e</em><sub><em>j</em></sub> is taken during the execution of the program being studied; Kirchhoff’s law is</p>

  <div class="equation"><a id="ch02eq-lev3sec1-1"></a><img src="../Images/ch02/365equ01.jpg"></div>

  <p class="noindent">for example, in the case of the box marked <em>K</em> we have</p>

  <div class="equation"><a id="ch02eq-lev3sec1-2"></a><img src="../Images/ch02/365equ02.jpg"></div>

  <p class="noindent"><em>In the discussion that follows, we will regard E<sub>1</sub>, E<sub>2</sub>, ..., E<sub>27</sub> as the unknowns, instead of A, B, ..., S</em>.</p>

  <p class="indent">The flow chart in <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> may be abstracted further so that it becomes a graph <em>G</em> as in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>. The boxes have shrunk to vertices, and the arrows <em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, ... now represent edges of the graph. (A graph, strictly speaking, has no implied direction in its edges, and the direction of the arrows should be ignored when we refer to graph-theoretical properties of <em>G</em>. Our application to Kirchhoff’s law, however, makes use of the arrows, as we will see shortly.) For convenience an extra edge <em>e</em><sub>0</sub> has been drawn from the Stop vertex to the Start vertex, so that Kirchhoff’s law applies uniformly to all parts of the graph. <a href="../Text/ch02b.html#ch02fig32">Figure 32</a> also includes some other minor changes from <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a>: An extra vertex and edge have been added to divide <em>e</em><sub>13</sub> into two parts <span class="middle"><img src="../Images/ch02/e13a.jpg"></span> and <span class="middle"><img src="../Images/ch02/e13.jpg"></span>, so that the basic definition of a graph (no two edges join the same two vertices) is valid; <em>e</em><sub>19</sub> has also been split up in this way. A similar modification would have been made if we had any vertex with an arrow leading back to itself.</p>

  <div class="image">
    <a id="ch02fig32"></a><img src="../Images/ch02/02fig32.jpg">

    <p class="fig-caption"><strong>Fig. 32.</strong> Graph corresponding to <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a>, including a free subtree.</p>
  </div>

  <p class="indent">Some of the edges in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a> have been drawn much heavier than the others. These edges form a <em>free subtree</em> of the graph, connecting all the vertices. It is always possible to find a free subtree of the graphs arising from flow charts, because the graphs must be connected and, by part (b) of <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a>, if <em>G</em> is connected and not a free tree, we can delete some edge and still have the <a id="page_366"></a>resulting graph connected; this process can be iterated until we reach a free subtree. Another algorithm for finding a free subtree appears in <a href="../Text/ch02b.html#ch02ex_3_1_6">exercise 6</a>. We can in fact always discard the edge <em>e</em><sub>0</sub> (which went from the Stop to the Start vertex) first; thus we may assume that <em>e</em><sub>0</sub> does not appear in the subtree chosen.</p>

  <p class="indent">Let <em>G</em>′ be a free subtree of the graph <em>G</em> found in this way, and consider any edge <em>V</em> −− <em>V</em>′ of <em>G</em> that is <em>not</em> in <em>G</em>′. We may now note an important consequence of <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a>: <em>G</em>′ plus this new edge <em>V</em> −− <em>V</em>′ contains a cycle; and in fact there is <em>exactly one</em> cycle, having the form (<em>V</em>, <em>V</em>′, ..., <em>V</em>), since there is a unique simple path from <em>V</em>′ to <em>V</em> in <em>G</em>′. For example, if <em>G</em>′ is the free subtree shown in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>, and if we add the edge <em>e</em><sub>2</sub>, we obtain a cycle that goes along <em>e</em><sub>2</sub> and then (in the direction opposite to the arrows) along <em>e</em><sub>4</sub> and <em>e</em><sub>3</sub> . This cycle may be written algebraically as “<em>e</em><sub>2</sub> − <em>e</em><sub>4</sub> − <em>e</em><sub>3</sub>”, using plus signs and minus signs to indicate whether the cycle goes in the direction of the arrows or not.</p>

  <p class="indent">If we carry out this process for each edge not in the free subtree, we obtain the so-called <em>fundamental cycles</em>, which in the case of <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a> are</p>

  <div class="equation"><a id="ch02eq-lev3sec1-3"></a><img src="../Images/ch02/366equ01.jpg"></div>

  <p class="noindent"><a id="page_367"></a>Obviously an edge <em>e</em><sub><em>j</em></sub> that is not in the free subtree will appear in only one of the fundamental cycles, namely <em>C</em><sub><em>j</em></sub>.</p>

  <p class="indent">We are now approaching the climax of this construction. Each fundamental cycle represents a solution to Kirchhoff’s equations; for example, the solution corresponding to <em>C</em><sub>2</sub> is to let <em>E</em><sub>2</sub> = +1, <em>E</em><sub>4</sub> = −1, <em>E</em><sub>3</sub> = −1, and all other <em>E</em>’s = 0. It is clear that flow around a cycle in a graph always satisfies the condition (<a href="../Text/ch02b.html#ch02eq-lev3sec1-1">1</a>) of Kirchhoff’s law. Moreover, Kirchhoff’s equations are “homogeneous,” so the sum or difference of solutions to (<a href="../Text/ch02b.html#ch02eq-lev3sec1-1">1</a>) yields another solution. Therefore we may conclude that the values of <em>E</em><sub>0</sub>, <em>E</em><sub>2</sub>, <em>E</em><sub>5</sub>, ..., <em>E</em><sub>25</sub> are <em>independent</em> in the following sense:</p>

  <div class="equation"><a id="ch02eq-lev3sec1-4"></a><img src="../Images/ch02/367equ01.jpg"></div>

  <p class="noindent">Such a solution is found by going <em>x</em><sub>0</sub> times around the cycle <em>C</em><sub>0</sub>, <em>x</em><sub>2</sub> times around cycle <em>C</em><sub>2</sub>, etc. Furthermore, we find that the values of the remaining variables <em>E</em><sub>1</sub>, <em>E</em><sub>3</sub>, <em>E</em><sub>4</sub>, ... are completely <em>dependent</em> on the values <em>E</em><sub>0</sub>, <em>E</em><sub>2</sub>, ..., <em>E</em><sub>25</sub>:</p>

  <div class="equation"><a id="ch02eq-lev3sec1-5"></a><img src="../Images/ch02/367equ02.jpg"></div>

  <p class="noindent">For if there are two solutions to Kirchhoff’s equations such that <em>E</em><sub>0</sub> = <em>x</em><sub>0</sub>, ..., <em>E</em><sub>25</sub> = <em>x</em><sub>25</sub>, we can subtract one from the other and we thereby obtain a solution in which <em>E</em><sub>0</sub> = <em>E</em><sub>2</sub> = <em>E</em><sub>5</sub> = · · · = <em>E</em><sub>25</sub> = 0. But now <em>all E</em><sub><em>j</em></sub> must be zero, for it is easy to see that a nonzero solution to Kirchhoff’s equations is impossible when the graph is a free tree (see <a href="../Text/ch02b.html#ch02ex_3_1_4">exercise 4</a>). Therefore the two assumed solutions must be identical. We have now proved that all solutions of Kirchhoff’s equations may be obtained as sums of multiples of the fundamental cycles.</p>

  <p class="indent">When these remarks are applied to the graph in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>, we obtain the following general solution of Kirchhoff’s equations in terms of the independent variables <em>E</em><sub>0</sub>, <em>E</em><sub>2</sub>, ..., <em>E</em><sub>25</sub>:</p>

  <div class="equation"><a id="ch02eq-lev3sec1-6"></a><img src="../Images/ch02/367equ03.jpg"></div>

  <p class="noindent">To obtain these equations, we merely list, for each edge <em>e</em><sub>j</sub> in the subtree, all <em>E</em><sub><em>k</em></sub> for which <em>e</em><sub><em>j</em></sub> appears in cycle <em>C</em><sub><em>k</em></sub>, with the appropriate sign. [Thus, the matrix of coefficients in (<a href="../Text/ch02b.html#ch02eq-lev3sec1-6">6</a>) is just the transpose of the matrix of coefficients in (<a href="../Text/ch02b.html#ch02eq-lev3sec1-3">3</a>).]</p>

  <p class="indent"><a id="page_368"></a>Strictly speaking, <em>C</em><sub>0</sub> should not be called a fundamental cycle, since it involves the special edge <em>e</em><sub>0</sub>. We may call <em>C</em><sub>0</sub> minus the edge <em>e</em><sub>0</sub> a <em>fundamental path from Start to Stop</em>. Our boundary condition, that the Start and Stop boxes in the flow chart are performed exactly once, is equivalent to the relation</p>

  <div class="equation"><a id="ch02eq-lev3sec1-7"></a><img src="../Images/ch02/368equ01.jpg"></div>

  <p class="indent">The preceding discussion shows how to obtain all solutions to Kirchhoff’s law; the same method may be applied (as Kirchhoff himself applied it) to electrical circuits instead of program flow charts. It is natural to ask at this point whether Kirchhoff’s law is the strongest possible set of equations that can be given for the case of program flow charts, or whether more can be said: Any execution of a computer program that goes from Start to Stop gives us a set of values <em>E</em><sub>1</sub>, <em>E</em><sub>2</sub>, ..., <em>E</em><sub>27</sub> for the number of times each edge is traversed, and these values obey Kirchhoff’s law; but are there solutions to Kirchhoff’s equations that do not correspond to any computer program execution? (In this question, we do not assume that we know anything about the given computer program, except its flow chart.) If there are solutions that meet Kirchhoff’s conditions but do not correspond to actual program execution, we can give stronger conditions than Kirchhoff’s law. For the case of electrical circuits Kirchhoff himself gave a second law [<em>Ann. Physik und Chemie</em> <strong>64</strong> (1845), 497–514]: The sum of the voltage drops around a fundamental cycle must be zero. This second law does not apply to our problem.</p>

  <p class="indent">There is indeed an obvious further condition that the <em>E</em>’s must satisfy, if they are to correspond to some actual walk in the flow chart from Start to Stop; they must be integers, and in fact they must be <em>nonnegative integers</em>. This is not a trivial condition, since we cannot simply assign any arbitrary nonnegative integer values to the independent variables <em>E</em><sub>2</sub>, <em>E</em><sub>5</sub>, ..., <em>E</em><sub>25</sub>; for example, if we take <em>E</em><sub>2</sub> = 2 and <em>E</em><sub>8</sub> = 0, we find from (<a href="../Text/ch02b.html#ch02eq-lev3sec1-6">6</a>) and (<a href="../Text/ch02b.html#ch02eq-lev3sec1-7">7</a>) that <em>E</em><sub>3</sub> = −1. (Thus, no execution of the flow chart in <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> will take branch <em>e</em><sub>2</sub> twice without taking branch <em>e</em><sub>8</sub> at least once.) The condition that all the <em>E</em>’s be nonnegative integers is not enough either; for example, consider the solution in which <span class="middle"><img src="../Images/ch02/e370_04.jpg"></span> = 1, <em>E</em><sub>2</sub> = <em>E</em><sub>5</sub> = · · · = <em>E</em><sub>17</sub> = <em>E</em><sub>20</sub> = <em>E</em><sub>21</sub> = <em>E</em><sub>25</sub> = 0; there is no way to get to <em>e</em><sub>18</sub> except via <em>e</em><sub>15</sub>. The following condition is a necessary and sufficient condition that answers the problem raised in the previous paragraph: Let <em>E</em><sub>2</sub>, <em>E</em><sub>5</sub>, ..., <em>E</em><sub>25</sub> be any given values, and determine <em>E</em><sub>1</sub><em>, E</em><sub>3</sub><em>, ..., E</em><sub>27</sub> according to (<a href="../Text/ch02b.html#ch02eq-lev3sec1-6">6</a>), (<a href="../Text/ch02b.html#ch02eq-lev3sec1-7">7</a>). Assume that all the <em>E</em>’s are nonnegative integers, and assume that the graph whose edges are those <em>e</em><sub><em>j</em></sub> for which <em>E</em><sub><em>j</em></sub> &gt; 0, and whose vertices are those that touch such <em>e</em><sub><em>j</em></sub>, is <em>connected</em>. Then there is a walk from Start to Stop in which edge <em>e</em><sub><em>j</em></sub> is traversed exactly <em>E</em><sub><em>j</em></sub> times. This fact is proved in the next section (see <a href="../Text/ch02b.html#ch02ex_3_2_24">exercise 2.3.4.2–24</a>).</p>

  <p class="indent">Let us now summarize the preceding discussion:</p>

  <p class="noindent"><a id="ch02b_the_k"></a><strong>Theorem K.</strong> <em>If a flow chart (such as <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a>) contains n boxes (including Start and Stop) and m arrows, it is possible to find m − n +</em> 1 <em>fundamental cycles and a fundamental path from Start to Stop, such that any walk from Start to Stop is equivalent (in terms of the number of times each edge is traversed)</em> <a id="page_369"></a><em>to one traversal of the fundamental path plus a uniquely determined number of traversals of each of the fundamental cycles</em>. (The fundamental path and fundamental cycles may include some edges that are to be traversed in a direction <em>opposite</em> that shown by the arrow on the edge; we conventionally say that such edges are being traversed −1 times.)</p>

  <p class="indent"><em>Conversely, for any traversal of the fundamental path and the fundamental cycles in which the total number of times each edge is traversed is nonnegative, and in which the vertices and edges corresponding to a positive number of traversals form a connected graph, there is at least one equivalent walk from Start to Stop</em>. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">The fundamental cycles are found by picking a free subtree as in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>; if we choose a different subtree we get, in general, a different set of fundamental cycles. The fact that there are <em>m</em> − <em>n</em> + 1 fundamental cycles follows from <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a>. The modifications we made to get from <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> to <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>, after adding <em>e</em><sub>0</sub>, do not change the value of <em>m</em> − <em>n</em> + 1, although they may increase both <em>m</em> and <em>n</em>; the construction could have been generalized so as to avoid these trivial modifications entirely (see <a href="../Text/ch02b.html#ch02ex_3_1_9">exercise 9</a>).</p>

  <p class="indent"><a href="../Text/ch02b.html#ch02b_the_k">Theorem K</a> is encouraging because it says that Kirchhoff’s law (which consists of <em>n</em> equations in the <em>m</em> unknowns <em>E</em><sub>1</sub>, <em>E</em><sub>2</sub>, ..., <em>E</em><sub><em>m</em></sub>) has just one “redundancy”: These <em>n</em> equations allow us to eliminate <em>n</em> − 1 unknowns. However, the unknown variables throughout this discussion have been the number of times the <em>edges</em> have been traversed, not the number of times each <em>box</em> of the flow chart has been entered. <a href="../Text/ch02b.html#ch02ex_3_1_8">Exercise 8</a> shows how to construct another graph whose edges correspond to the boxes of the flow chart, so that the theory above can be used to deduce the true number of redundancies between the variables of interest.</p>

  <p class="indent">Applications of <a href="../Text/ch02b.html#ch02b_the_k">Theorem K</a> to software for measuring the performance of programs in high-level languages are discussed by Thomas Ball and James R. Larus in <em>ACM Trans. Prog. Languages and Systems</em> <strong>16</strong> (1994), 1319–1360.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_1_1a" id="ch02ex_3_1_1">1</a>.</strong> [<em>14</em>] List all cycles from <em>B</em> to <em>B</em> that are present in the graph of <a href="../Text/ch02b.html#ch02fig29">Fig. 29</a>.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_1_2a" id="ch02ex_3_1_2">2</a>.</strong> [<em>M20</em>] Prove that if <em>V</em> and <em>V</em>′ are vertices of a graph and if there is a walk from <em>V</em> to <em>V</em>′, then there is a (simple) path from <em>V</em> to <em>V</em>′.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_1_3a" id="ch02ex_3_1_3">3</a>.</strong> [<em>15</em>] What walk from Start to Stop is equivalent (in the sense of <a href="../Text/ch02b.html#ch02b_the_k">Theorem K</a>) to one traversal of the fundamental path plus one traversal of cycle <em>C</em><sub>2</sub> in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_1_4a" id="ch02ex_3_1_4">4</a>.</strong> [<em>M20</em>] Let <em>G</em>′ be a finite free tree in which arrows have been drawn on its edges <em>e</em><sub>1</sub>, ..., <em>e</em><sub><em>n</em>−1</sub>; let <em>E</em><sub>1</sub>, ..., <em>E</em><sub><em>n</em>−1</sub> be numbers satisfying Kirchhoff’s law (<a href="../Text/ch02b.html#ch02eq-lev3sec1-1">1</a>) in <em>G</em>′. Show that <em>E</em><sub>1</sub> = · · · = <em>E</em><sub><em>n</em>−1</sub> = 0.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_1_5a" id="ch02ex_3_1_5">5</a>.</strong> [<em>20</em>] Using Eqs. (<a href="../Text/ch02b.html#ch02eq-lev3sec1-6">6</a>), express the quantities <em>A, B, ..., S</em> that appear inside the boxes of <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> in terms of the independent variables <em>E</em><sub>2</sub>, <em>E</em><sub>5</sub>, ..., <em>E</em><sub>25</sub>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_1_6a" id="ch02ex_3_1_6">6</a>.</strong> [<em>M27</em>] Suppose a graph has <em>n</em> vertices <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub> and <em>m</em> edges <em>e</em><sub>1</sub>, ..., <em>e</em><sub><em>m</em></sub> . Each edge <em>e</em> is represented by a pair of integers (<em>a, b</em>) if it joins <em>V</em><sub><em>a</em></sub> to <em>V</em><sub><em>b</em></sub> . Design an algorithm that takes the input pairs (<em>a</em><sub>1</sub>, <em>b</em><sub>1</sub>), ..., (<em>a</em><sub><em>m</em></sub>, <em>b</em><sub><em>m</em></sub>) and prints out a subset of edges that forms a free tree; the algorithm reports failure if this is impossible. Strive for an efficient algorithm.</p>

  <p class="exercises"><a id="page_370"></a><strong><a href="../Text/app01b.html#ch02ex_3_1_7a" id="ch02ex_3_1_7">7</a>.</strong> [<em>22</em>] Carry out the construction in the text for the flow chart</p>

  <div class="image"><img src="../Images/ch02/370fig01.jpg"></div>

  <p class="exercisesp">using the free subtree consisting of edges <em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, <em>e</em><sub>3</sub>, <em>e</em><sub>4</sub>, <em>e</em><sub>9</sub> . What are the fundamental cycles? Express <em>E</em><sub>1</sub>, <em>E</em><sub>2</sub>, <em>E</em><sub>3</sub>, <em>E</em><sub>4</sub>, <em>E</em><sub>9</sub> in terms of <em>E</em><sub>5</sub>, <em>E</em><sub>6</sub>, <em>E</em><sub>7</sub>, and <em>E</em><sub>8</sub>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_1_8a" id="ch02ex_3_1_8">8</a>.</strong> [<em>M25</em>] When applying Kirchhoff’s first law to program flow charts, we usually are interested only in the <em>vertex flows</em> (the number of times each box of the flow chart is performed), not the edge flows analyzed in the text. For example, in the graph of <a href="../Text/ch02b.html#ch02ex_3_1_7">exercise 7</a>, the vertex flows are <em>A</em> = <em>E</em><sub>2</sub> + <em>E</em><sub>4</sub>, <em>B</em> = <em>E</em><sub>5</sub>, <em>C</em> = <em>E</em><sub>3</sub> + <em>E</em><sub>7</sub> + <em>E</em><sub>8</sub>, <em>D</em> = <em>E</em><sub>6</sub> + <em>E</em><sub>9</sub>.</p>

  <p class="indent">If we group some vertices together, treating them as one “supervertex,” we can combine edge flows that correspond to the same vertex flow. For example, edges <em>e</em><sub>2</sub> and <em>e</em><sub>4</sub> can be combined in the flow chart above if we also put <em>B</em> with <em>D</em>:</p>

  <div class="image"><img src="../Images/ch02/370fig02.jpg"></div>

  <p class="noindent">(Here <em>e</em><sub>0</sub> has also been added from Stop to Start, as in the text.) Continuing this procedure, we can combine <em>e</em><sub>3</sub> + <em>e</em><sub>7</sub>, then (<em>e</em><sub>3</sub> + <em>e</em><sub>7</sub>) + <em>e</em><sub>8</sub>, then <em>e</em><sub>6</sub> + <em>e</em><sub>9</sub>, until we obtain the <em>reduced flow chart</em> having edges <em>s</em> = <em>e</em><sub>1</sub>, <em>a</em> = <em>e</em><sub>2</sub> + <em>e</em><sub>4</sub>, <em>b</em> = <em>e</em><sub>5</sub>, <em>c</em> = <em>e</em><sub>3</sub> + <em>e</em><sub>7</sub> + <em>e</em><sub>8</sub>, <em>d</em> = <em>e</em><sub>6</sub> + <em>e</em><sub>9</sub>, <em>t</em> = <em>e</em><sub>0</sub>, precisely one edge for each vertex in the original flow chart:</p>

  <div class="image"><img src="../Images/ch02/370fig03.jpg"></div>

  <p class="indent">By construction, Kirchhoff’s law holds in this reduced flow chart. The new edge flows are the vertex flows of the original; hence the analysis in the text, applied to the reduced flow chart, shows how the original vertex flows depend on each other.</p>

  <p class="indent">Prove that this reduction process can be reversed, in the sense that any set of flows {<em>a, b, ...</em>} satisfying Kirchhoff’s law in the reduced flow chart can be “split up” into a set of edge flows {<em>e</em><sub>0</sub>, <em>e</em><sub>1</sub>, ...} in the original flow chart. These flows <em>e</em><sub><em>j</em></sub> satisfy Kirchhoff’s law and combine to yield the given flows {<em>a</em>, <em>b</em>, ...}; some of them might, however, be negative. (Although the reduction procedure has been illustrated here for only one particular flow chart, your proof should be valid in general.)</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_1_9a" id="ch02ex_3_1_9">9</a>.</strong> [<em>M22</em>] Edges <em>e</em><sub>13</sub> and <em>e</em><sub>19</sub> were split into two parts in <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>, since a graph is not supposed to have two edges joining the same two vertices. However, if we look at the final result of the construction, this splitting into two parts seems quite artificial since <span class="middle"><img src="../Images/ch02/e370_01.jpg"></span> and <span class="middle"><img src="../Images/ch02/e370_02.jpg"></span> are two of the relations found in (<a href="../Text/ch02b.html#ch02eq-lev3sec1-6">6</a>), while <span class="middle"><img src="../Images/ch02/e370_03.jpg"></span> and <span class="middle"><img src="../Images/ch02/e370_04.jpg"></span> are two of the independent variables. Explain how the construction could be generalized so that an artificial splitting of edges may be avoided.</p>

  <p class="exercises1"><a id="page_371"></a><strong><a href="../Text/app01b.html#ch02ex_3_1_10a" id="ch02ex_3_1_10">10</a>.</strong> [<em>16</em>] An electrical engineer, designing the circuitry for a computer, has <em>n</em> terminals <em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, ..., <em>T</em><sub><em>n</em></sub> that should be at essentially the same voltage at all times. To achieve this, the engineer can solder wires between any pairs of terminals; the idea is to make enough wire connections so that there is a path through the wires from any terminal to any other. Show that the minimum number of wires needed to connect all the terminals is <em>n</em> − 1, and <em>n</em> − 1 wires achieve the desired connection if and only if they form a free tree (with terminals and wires standing for vertices and edges).</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_1_11a" id="ch02ex_3_1_11">11</a>.</strong> [<em>M27</em>] (R. C. Prim, <em>Bell System Tech. J.</em> <strong>36</strong> (1957), 1389–1401.) Consider the wire connection problem of <a href="../Text/ch02b.html#ch02ex_3_1_10">exercise 10</a> with the additional proviso that a cost <em>c</em>(<em>i, j</em>) is given for each <em>i</em> &lt; <em>j</em>, denoting the expense of wiring terminal <em>T</em><sub><em>i</em></sub> to terminal <em>T</em><sub><em>j</em></sub> . Show that the following algorithm gives a connection tree of minimum cost: “If <em>n</em> = 1, do nothing. Otherwise, renumber terminals {1<em>, ..., n</em> − 1} and the associated costs so that <em>c</em>(<em>n</em> − 1<em>, n</em>) = min<sub>1 ≤ <em>i</em>&lt;<em>n</em></sub><em>c</em>(<em>i, n</em>); connect terminal <em>T</em><sub><em>n</em> − 1</sub> to <em>T</em><sub><em>n</em></sub>; then change <em>c</em>(<em>j, n</em> − 1) to min(<em>c</em>(<em>j, n</em> − 1)<em>, c</em>(<em>j, n</em>)) for 1 ≤ <em>j &lt; n</em> − 1, and repeat the algorithm for <em>n</em> − 1 terminals <em>T</em><sub>1</sub>, ..., <em>T</em><sub><em>n</em> − 1</sub> using these new costs. (The algorithm is to be repeated with the understanding that whenever a connection is subsequently requested between the terminals now called <em>T</em><sub><em>j</em></sub> and <em>T</em><sub><em>n</em> − 1</sub>, the connection is actually made between terminals now called <em>T</em><sub><em>j</em></sub> and <em>T</em><sub><em>n</em></sub> if it is cheaper; thus <em>T</em><sub><em>n</em> − 1</sub> and <em>T</em><sub><em>n</em></sub> are being regarded as though they were one terminal in the remainder of the algorithm.)” This algorithm may also be stated as follows: “Choose a particular terminal to start with; then repeatedly make the cheapest possible connection from an unchosen terminal to a chosen one, until all have been chosen.”</p>

  <p class="indent">For example, consider <a href="../Text/ch02b.html#ch02fig33">Fig. 33</a>(a), which shows nine terminals on a grid; let the cost of connecting two terminals be the wire length, namely the distance between them. (The reader may wish to try to find a minimal cost tree by hand, using intuition instead of the suggested algorithm.) The algorithm would first connect <em>T</em><sub>8</sub> to <em>T</em><sub>9</sub>, then <em>T</em><sub>6</sub> to <em>T</em><sub>8</sub>, <em>T</em><sub>5</sub> to <em>T</em><sub>6</sub>, <em>T</em><sub>2</sub> to <em>T</em><sub>6</sub>, <em>T</em><sub>1</sub> to <em>T</em><sub>2</sub>, <em>T</em><sub>3</sub> to <em>T</em><sub>1</sub>, <em>T</em><sub>7</sub> to <em>T</em><sub>3</sub>, and finally <em>T</em><sub>4</sub> to either <em>T</em><sub>2</sub> or <em>T</em><sub>6</sub> . A minimum cost tree (wire length <span class="middle"><img src="../Images/ch02/e371_01.jpg"></span>) is shown in <a href="../Text/ch02b.html#ch02fig33">Fig. 33</a>(b).</p>

  <div class="image">
    <a id="ch02fig33"></a><img src="../Images/ch02/02fig33.jpg">

    <p class="fig-caption"><strong>Fig. 33.</strong> Free tree of minimum cost. (See <a href="../Text/ch02b.html#ch02ex_3_1_11">exercise 11</a>.)</p>
  </div>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_1_12a" id="ch02ex_3_1_12">12</a>.</strong> [<em>29</em>] The algorithm of <a href="../Text/ch02b.html#ch02ex_3_1_11">exercise 11</a> is not stated in a fashion suitable for direct computer implementation. Reformulate that algorithm, specifying in more detail the operations that are to be done, in such a way that a computer program can carry out the process with reasonable efficiency.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_1_13a" id="ch02ex_3_1_13">13</a>.</strong> [<em>M24</em>] Consider a graph with <em>n</em> vertices and <em>m</em> edges, in the notation of <a href="../Text/ch02b.html#ch02ex_3_1_6">exercise 6</a>. Show that it is possible to write any permutation of the integers {1, 2<em>, ..., n</em>} as a product of transpositions (<em>a</em><sub><em>k1</em></sub><em>b</em><sub><em>k1</em></sub>) (<em>a</em><sub><em>k2</em></sub><em>b</em><sub><em>k2</em></sub>) ... (<em>a</em><sub><em>k</em><sub><em>t</em></sub></sub><em>b</em><sub><em>k</em><sub><em>t</em></sub></sub>) if and only if the graph is connected. (Hence there are sets of <em>n</em> − 1 transpositions that generate all permutations on <em>n</em> elements, but no set of <em>n</em> − 2 will do so.)</p>

  <div class="heading">
    <h5 id="ch02lev3sec2"><a id="page_372"></a>2.3.4.2. Oriented trees</h5>

    <p class="noindent">In the previous section, we saw that an abstracted flow chart may be regarded as a graph, if we ignore the direction of the arrows on its edges; the graph-theoretic ideas of cycle, free subtree, etc., were shown to be relevant in the study of flow charts. There is a good deal more that can be said when the direction of each edge is given more significance, and in this case we have what is called a “directed graph” or “digraph.”</p>
  </div>

  <p class="indent">Let us define a <em>directed graph</em> formally as a set of vertices and a set of <em>arcs</em>, each arc leading from a vertex <em>V</em> to a vertex <em>V</em>′. If <em>e</em> is an arc from <em>V</em> to <em>V</em>′ we say <em>V</em> is the <em>initial</em> vertex of <em>e</em>, and <em>V</em>′ is the <em>final</em> vertex, and we write <em>V</em> = init(<em>e</em>), <em>V</em>′ = fin(<em>e</em>). The case that init(<em>e</em>) = fin(<em>e</em>) is not excluded (although it was excluded from the definition of edge in an ordinary graph), and several different arcs may have the same initial and final vertices. The <em>out-degree</em> of a vertex <em>V</em> is the number of arcs leading out from it, namely the number of arcs <em>e</em> such that init(<em>e</em>) = <em>V</em>; similarly, the <em>in-degree</em> of <em>V</em> is defined to be the number of arcs with fin(<em>e</em>) = <em>V</em>.</p>

  <p class="indent">The concepts of paths and cycles are defined for directed graphs in a manner similar to the corresponding definitions for ordinary graphs, but some important new technicalities must be considered. If <em>e</em><sub>1</sub>, <em>e<sub>2</sub>, ..., <em>e</em><sub><em>n</em></sub></em> are arcs (with <em>n</em> ≥ 1), we say that (<em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, ..., <em>e</em><sub><em>n</em></sub>) is an <em>oriented walk</em> of length <em>n</em> from <em>V</em> to <em>V</em>′ if <em>V</em> = init(<em>e</em><sub>1</sub>), <em>V</em>′ = fin(<em>e</em><sub>n</sub>), and fin(<em>e</em><sub>k</sub>) = init(<em>e</em><sub>k+1</sub>) for 1 ≤ <em>k &lt; n</em>. An oriented walk (e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub>) is called <em>simple</em> if init(<em>e</em><sub>1</sub>), ..., init(<em>e</em><sub><em>n</em></sub>) are distinct and fin(<em>e</em><sub>1</sub>), ..., fin(<em>e</em><sub><em>n</em></sub>) are distinct; such a walk is an <em>oriented cycle</em> if fin(<em>e</em><sub><em>n</em></sub>) = init(<em>e</em><sub>1</sub>), otherwise it’s an <em>oriented path</em>. (An oriented cycle can have length 1 or 2, but such short cycles were excluded from our definition of “cycle” in the previous section. Can the reader see why this makes sense?)</p>

  <p class="indent">As examples of these straightforward definitions, we may refer to <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> in the previous section. The box labeled “<em>J</em>” is a vertex with in-degree 2 (because of the arcs <em>e</em><sub>16</sub>, <em>e</em><sub>21</sub>) and out-degree 1. The sequence (<em>e</em><sub>17</sub>, <em>e</em><sub>19</sub>, <em>e</em><sub>18</sub>, <em>e</em><sub>22</sub>) is an oriented walk of length 4 from <em>J</em> to <em>P</em>; this walk is not simple since, for example, init(<em>e</em><sub>19</sub>) = <em>L</em> = init(<em>e</em><sub>22</sub>). The diagram contains no oriented cycles of length 1, but (<em>e</em><sub>18</sub>, <em>e</em><sub>19</sub>) is an oriented cycle of length 2.</p>

  <p class="indent">A directed graph is said to be <em>strongly connected</em> if there is an oriented path from <em>V</em> to <em>V</em>′ for any two vertices <em>V</em> ≠ <em>V</em>′. It is said to be <em>rooted</em> if there is at least one <em>root</em>, that is, at least one vertex <em>R</em> such that there is an oriented path from <em>V</em> to <em>R</em> for all <em>V</em> ≠ <em>R</em>. “Strongly connected” always implies “rooted,” but the converse does not hold. A flow chart such as <a href="../Text/ch02b.html#ch02fig31">Fig. 31</a> in the previous section is an example of a rooted digraph, with <em>R</em> the Stop vertex; with the additional arc from Stop to Start (<a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>) it becomes strongly connected.</p>

  <p class="indent">Every directed graph <em>G</em> corresponds in an obvious manner to an ordinary graph <em>G</em><sub>0</sub>, if we ignore orientations and discard duplicate edges or loops. Formally speaking, <em>G</em><sub>0</sub> has an edge from <em>V</em> to <em>V</em>′ if and only if <em>V</em> ≠ <em>V</em>′ and <em>G</em> has an arc from <em>V</em> to <em>V</em>′ or from <em>V</em>′ to <em>V</em> . We can speak of (unoriented) <em>paths</em> and <em>cycles</em> in <em>G</em> with the understanding that these are paths and cycles of <em>G</em><sub>0</sub>; we can say that <em>G</em> is <em>connected</em> — this is a much weaker property than “strongly connected,” even weaker than “rooted” — if the corresponding graph <em>G</em><sub>0</sub> is connected.</p>

  <p class="indent"><a id="page_373"></a>An <em>oriented tree</em> (see <a href="../Text/ch02b.html#ch02fig34">Fig. 34</a>), sometimes called a “rooted tree” by other authors, is a directed graph with a specified vertex <em>R</em> such that:</p>

  <p class="indenthangingA">a) Each vertex <em>V</em> ≠ <em>R</em> is the initial vertex of exactly one arc, denoted by <em>e</em>[<em>V</em>].</p>

  <p class="indenthangingA">b) <em>R</em> is the initial vertex of no arc;</p>

  <p class="indenthangingA">c) <em>R</em> is a root in the sense defined above (that is, for each vertex <em>V</em> ≠ <em>R</em> there is a <em>unique</em> oriented path from <em>V</em> to <em>R</em>).</p>

  <div class="image">
    <a id="ch02fig34"></a><img src="../Images/ch02/02fig34.jpg">

    <p class="fig-caption"><strong>Fig. 34.</strong> An oriented tree.</p>
  </div>

  <p class="indent">It follows immediately that for each vertex <em>V</em> ≠ <em>R</em> there is a <em>unique</em> oriented path from <em>V</em> to <em>R</em>; and hence there are no oriented cycles.</p>

  <p class="indent">Our previous definition of “oriented tree” (at the beginning of <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a>) is easily seen to be compatible with the new definition just given, when there are finitely many vertices. The vertices correspond to nodes, and the arc <em>e</em>[<em>V</em>] is the link from <em>V</em> to <code>PARENT[</code><em>V</em><code>]</code>.</p>

  <p class="indent">The (undirected) graph corresponding to an oriented tree is connected, because of property (c). Furthermore, it has no cycles. For if (<em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub>) is an undirected cycle with <em>n</em> ≥ 3, and if the edge between <em>V</em><sub>0</sub> and <em>V</em><sub>1</sub> is <em>e</em>[<em>V</em><sub>1</sub> ], then the edge between <em>V</em><sub>1</sub> and <em>V</em><sub>2</sub> must be <em>e</em>[<em>V</em><sub>2</sub> ], and similarly the edge between <em>V</em><sub><em>k</em> − 1</sub> and <em>V</em><sub><em>k</em></sub> must be <em>e</em>[<em>V</em><sub><em>k</em></sub>] for 1 ≤ <em>k</em> ≤ <em>n</em>, contradicting the absence of oriented cycles. If the edge between <em>V</em><sub>0</sub> and <em>V</em><sub>1</sub> is not <em>e</em>[<em>V</em><sub>1</sub>], it must be <em>e</em>[<em>V</em><sub>0</sub> ], and the same argument applies to the cycle</p>

  <p class="center">(<em>V</em><sub>1</sub>, <em>V</em><sub>0</sub>, <em>V</em><sub><em>n</em> − 1</sub>, ..., <em>V</em><sub>1</sub>),</p>

  <p class="noindent">because <em>V</em><sub><em>n</em></sub> = <em>V</em><sub>0</sub> . Therefore <em>an oriented tree is a free tree when the direction of the arcs is neglected</em>.</p>

  <p class="indent">Conversely, it is important to note that we can reverse the process just described. If we start with any nonempty free tree, such as that in <a href="../Text/ch02b.html#ch02fig30">Fig. 30</a>, we can choose <em>any</em> vertex as the root <em>R</em>, and assign directions to the edges. The intuitive idea is to “pick up” the graph at vertex <em>R</em> and shake it; then assign upward-pointing arrows. More formally, the rule is this:</p>

  <p class="uln-indent">Change the edge <em>V</em> −− <em>V</em>′ to an arc from <em>V</em> to <em>V</em>′ if and only if the simple path from <em>V</em> to <em>R</em> leads through <em>V</em>′, that is, if it has the form (<em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub>), where <em>n</em> &gt; 0, <em>V</em><sub>0</sub> = <em>V</em>, <em>V</em><sub>1</sub> = <em>V</em>′, <em>V</em><sub><em>n</em></sub> = <em>R</em>.</p>

  <p class="noindent">To verify that such a construction is valid, we need to prove that each edge <em>V</em> −− <em>V</em>′ is assigned the direction <em>V</em> ← <em>V</em>′ or the direction <em>V</em> → <em>V</em>′; and this is easy to prove, for if (<em>V</em>, <em>V</em><sub>1</sub>, ..., <em>R</em>) and (<em>V</em>′, <span class="middle"><img src="../Images/ch02/373fig01.jpg"></span>, ..., <em>R</em>) are simple paths, there is a cycle unless <em>V</em> = <span class="middle"><img src="../Images/ch02/373fig01.jpg"></span> or <em>V</em><sub>1</sub> = <em>V</em>′. This construction demonstrates that the directions of the arcs in an oriented tree are completely determined if we know which vertex is the root, so they need not be shown in diagrams when the root is explicitly indicated.</p>

  <p class="indent"><a id="page_374"></a>We now see the relation between three types of trees: the (ordered) tree, which is of principal importance in computer programs, as defined at the beginning of <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a>; the oriented tree (or unordered tree); and the free tree. Both of the latter two types arise in the study of computer algorithms, but not as often as the first type. <em>The essential distinction between these types of tree structure is merely the amount of information that is taken to be relevant.</em> For example, <a href="../Text/ch02b.html#ch02fig35">Fig. 35</a> shows three trees that are distinct if they are considered as ordered trees (with root at the top). As oriented trees, the first and second are identical, since the left-to-right order of subtrees is immaterial; as free trees, all three graphs in <a href="../Text/ch02b.html#ch02fig35">Fig. 35</a> are identical, since the root is immaterial.</p>

  <div class="image">
    <a id="ch02fig35"></a><img src="../Images/ch02/02fig35.jpg">

    <p class="fig-caption"><strong>Fig. 35.</strong> Three tree structures.</p>
  </div>

  <p class="indent">An <em>Eulerian trail</em> in a directed graph is an oriented walk (<em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, ..., <em>e</em><sub><em>m</em></sub>) such that <em>every</em> arc in the directed graph occurs exactly once, and fin(<em>e</em><sub><em>m</em></sub>) = init(<em>e</em><sub>1</sub>). This is a “complete traversal” of the arcs of the digraph. (Eulerian trails get their name from Leonhard Euler’s famous discussion in 1736 of the impossibility of traversing each of the seven bridges in the city of Königsberg exactly once during a Sunday stroll. He treated the analogous problem for undirected graphs. Eulerian trails should be distinguished from “Hamiltonian cycles,” which are oriented cycles that encounter each <em>vertex</em> exactly once; see Chapter 7.)</p>

  <p class="indent">A directed graph is said to be <em>balanced</em> (see <a href="../Text/ch02b.html#ch02fig36">Fig. 36</a>) if every vertex <em>V</em> has the same in-degree as its out-degree, that is, if there are just as many edges with <em>V</em> as their initial vertex as there are with <em>V</em> as their final vertex. This condition is closely related to Kirchhoff’s law (see <a href="../Text/ch02b.html#ch02ex_3_2_24">exercise 24</a>). If a directed graph has an Eulerian trail, it must obviously be connected and balanced — unless it has <em>isolated vertices</em>, which are vertices with in-degree and out-degree both equal to zero.</p>

  <div class="image">
    <a id="ch02fig36"></a><img src="../Images/ch02/02fig36.jpg">

    <p class="fig-caption"><strong>Fig. 36.</strong> A balanced directed graph.</p>
  </div>

  <p class="indent">So far in this section we’ve looked at quite a few definitions (directed graph, arc, initial vertex, final vertex, out-degree, in-degree, oriented walk, oriented path, oriented cycle, oriented tree, Eulerian trail, isolated vertex, and the properties of being strongly connected, rooted, and balanced), but there has been a scarcity of important results connecting these concepts. Now we are ready for meatier material. The first basic result is a theorem due to I. J. Good [<em>J. London Math. Soc.</em> <strong>21</strong> (1947), 167–169], who showed that Eulerian trails are always possible unless they are obviously impossible:</p>

  <p class="noindent"><a id="page_375"></a><a id="ch02b_the_g"></a><strong>Theorem G.</strong> <em>A finite, directed graph with no isolated vertices possesses an Eulerian trail if and only if it is connected and balanced.</em></p>

  <p class="noindent"><em>Proof.</em> Assume that <em>G</em> is balanced, and let</p>

  <p class="center"><em>P</em> = (<em>e</em><sub>1</sub><em>, ..., e</em><sub><em>m</em></sub>)</p>

  <p class="noindent">be an oriented walk of longest possible length that uses no arc twice. Then if <em>V</em> = fin(<em>e</em><sub><em>m</em></sub>), and if <em>k</em> is the out-degree of <em>V</em>, all <em>k</em> arcs <em>e</em> with init(<em>e</em>) = <em>V</em> must already appear in <em>P</em>; otherwise we could add <em>e</em> and get a longer walk. But if init(<em>e</em><sub><em>j</em></sub>) = <em>V</em> and <em>j</em> &gt; 1, then fin(<em>e</em><sub><em>j</em>−1</sub>) = <em>V</em>. Hence, since <em>G</em> is balanced, we must have</p>

  <p class="center">init(<em>e</em><sub>1</sub>) = <em>V</em> = fin(<em>e</em><sub><em>m</em></sub>)<em>,</em></p>

  <p class="noindent">otherwise the in-degree of <em>V</em> would be at least <em>k</em> + 1.</p>

  <p class="indent">Now by the cyclic permutation of <em>P</em> it follows that any arc <em>e</em> not in the walk has neither initial nor final vertex in common with any arc in the walk. So if <em>P</em> is not an Eulerian trail, <em>G</em> is not connected. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">There is an important connection between Eulerian trails and oriented trees:</p>

  <p class="noindent"><a id="ch02b_lem_E"></a><strong>Lemma E.</strong> <em>Let</em> (<em>e</em><sub>1</sub><em>, ..., e</em><sub><em>m</em></sub>) <em>be an Eulerian trail of a directed graph G having no isolated vertices. Let R</em> = fin(<em>e</em><sub><em>m</em></sub>) = init(<em>e</em><sub>1</sub>)<em>. For each vertex V</em> ≠ <em>R let e</em>[<em>V</em>] <em>be the last exit from V in the trail; that is,</em></p>

  <div class="equation"><a id="ch02eq-lev3sec2-1"></a><img src="../Images/ch02/375equ01.jpg"></div>

  <p class="noindent"><em>Then the vertices of G with the arcs e</em>[<em>V</em>] <em>form an oriented tree with root R .</em></p>

  <p class="noindent"><em>Proof.</em> Properties (a) and (b) of the definition of oriented tree are evidently satisfied. By <a href="../Text/ch02b.html#ch02ex_3_2_7">exercise 7</a> we need only show that there are no oriented cycles among the <em>e</em>[<em>V</em> ]; but this is immediate, since if fin(<em>e</em>[<em>V</em> ]) = <em>V <sup>′</sup></em> = init(<em>e</em>[<em>V <sup>′</sup></em>]), where <em>e</em>[<em>V</em>] = <em>e</em><sub><em>j</em></sub> and <em>e</em>[<em>V <sup>′</sup></em>] = <em>e</em><sub><em>j</em></sub>′, then <em>j &lt; j</em> ′. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">This lemma can perhaps be better understood if we turn things around and consider the “first entrances” to each vertex; the first entrances form an unordered tree with all arcs pointing <em>away</em> from <em>R</em>. <a href="../Text/ch02b.html#ch02b_lem_E">Lemma E</a> has a surprising and important converse, proved by T. van Aardenne-Ehrenfest and N. G. de Bruijn [<em>Simon Stevin</em> <strong>28</strong> (1951), 203–217]:</p>

  <p class="noindent"><a id="page_376"></a><a id="ch02b_the_d"></a><strong>Theorem D.</strong> <em>Let G be a finite, balanced, directed graph, and let G′ be an oriented tree consisting of the vertices of G plus some of the arcs of G . Let R be the root of G ′ and let e</em>[<em>V</em> ]<em>be the arc of G′ with initial vertex V . Let e</em><sub>1</sub><em>be any arc of G with</em> init(<em>e</em><sub>1</sub>) = <em>R . Then P</em> = (<em>e</em><sub>1</sub><em>, e</em><sub>2</sub><em>, ..., e</em><sub><em>m</em></sub>) <em>is an Eulerian trail if it is an oriented walk for which</em></p>

  <p class="indenti">i) <em>no arc is used more than once; that is, e</em><sub><em>j</em></sub>≠ <em>e</em><sub><em>k</em></sub><em>when j</em> ≠ <em>k</em>.</p>

  <p class="indenti">ii) <em>e</em>[<em>V</em>] <em>is not used in P unless it is the only choice consistent with rule</em> (i)<em>; that is, if e</em><sub><em>j</em></sub> = <em>e</em>[<em>V</em>] <em>and if e is an arc with</em> init(<em>e</em>) = <em>V, then e</em> = <em>e</em><sub><em>k</em></sub><em>for some k ≤ j</em>.</p>

  <p class="indenti">iii) <em>P terminates only when it cannot be continued by rule</em> (i)<em>; that is, if</em> init(<em>e</em>) = fin(<em>e</em><sub><em>m</em></sub>)<em>, then e</em> = <em>e</em><sub><em>k</em></sub><em>for some k .</em></p>

  <p class="noindent"><em>Proof.</em> By (iii) and the argument in the proof of <a href="../Text/ch02b.html#ch02b_the_g">Theorem G</a>, we must have fin(<em>e</em><sub><em>m</em></sub>) = init(<em>e</em><sub>1</sub>) = <em>R</em>. Now if <em>e</em> is an arc not appearing in <em>P</em>, let <em>V</em> = fin(<em>e</em>). Since <em>G</em> is balanced, it follows that <em>V</em> is the initial vertex of some arc not in <em>P</em>; and if <em>V</em> ≠ <em>R</em>, condition (ii) tells us that <em>e</em>[<em>V</em>] is not in <em>P</em> . Now use the same argument with <em>e</em> = <em>e</em>[<em>V</em>], and we ultimately find that <em>R</em> is the initial vertex of some arc not in the walk, contradicting (iii). <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">The essence of <a href="../Text/ch02b.html#ch02b_the_d">Theorem D</a> is that it shows us a simple way to construct an Eulerian trail in a balanced directed graph, given any oriented subtree of the graph. (See the example in <a href="../Text/ch02b.html#ch02ex_3_2_14">exercise 14</a>.) In fact, <a href="../Text/ch02b.html#ch02b_the_d">Theorem D</a> allows us to count the exact number of Eulerian trails in a directed graph; this result and many other important consequences of the ideas developed in this section appear in the exercises that follow.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_1a" id="ch02ex_3_2_1">1</a>.</strong> [<em>M20</em>] Prove that if <em>V</em> and <em>V<sup>′</sup></em> are vertices of a directed graph and if there is an oriented walk from <em>V</em> to <em>V<sup>′</sup></em>, then there is a simple oriented path from <em>V</em> to <em>V<sup>′</sup></em>.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_2a" id="ch02ex_3_2_2">2</a>.</strong> [<em>15</em>] Which of the ten “fundamental cycles” listed in (<a href="../Text/ch02b.html#ch02eq-lev3sec1-3">3</a>) of <a href="../Text/ch02b.html#ch02lev3sec1">Section 2.3.4.1</a> are <em>oriented</em> cycles in the directed graph (<a href="../Text/ch02b.html#ch02fig32">Fig. 32</a>) of that section?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_3a" id="ch02ex_3_2_3">3</a>.</strong> [<em>16</em>] Draw the diagram for a directed graph that is connected but not rooted.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_4a" id="ch02ex_3_2_4">4</a>.</strong> [<em>M20</em>] The concept of <em>topological sorting</em> can be defined for any finite directed graph <em>G</em> as a linear arrangement of the vertices <em>V</em><sub>1</sub><em>V</em><sub>2</sub><em>... V</em><sub><em>n</em></sub> such that init(<em>e</em>) precedes fin(<em>e</em>) in the ordering for all arcs <em>e</em> of <em>G</em>. (See <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a>, <a href="../Text/ch02.html#ch02fig06">Figs. 6</a> and <a href="../Text/ch02.html#ch02fig07">7</a>.) Not all finite directed graphs can be topologically sorted; which ones can be? (Use the terminology of this section to give the answer.)</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_5a" id="ch02ex_3_2_5">5</a>.</strong> [<em>M16</em>] Let <em>G</em> be a directed graph that contains an oriented walk (<em>e</em><sub>1</sub><em>, ..., e</em><sub><em>n</em></sub>) with fin(<em>e</em><sub><em>n</em></sub>) = init(<em>e</em><sub>1</sub>). Give a proof that <em>G</em> is not an oriented tree, using the terminology defined in this section.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_6a" id="ch02ex_3_2_6">6</a>.</strong> [<em>M21</em>] True or false: A directed graph that is rooted and contains no cycles and no oriented cycles is an oriented tree.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_7a" id="ch02ex_3_2_7">7</a>.</strong> [<em>M22</em>] True or false: A directed graph satisfying properties (a) and (b) of the definition of oriented tree, and having no oriented cycles, is an oriented tree.</p>

  <p class="exercises"><a id="page_377"></a><strong>8.</strong> [<em>HM40</em>] Study the properties of <em>automorphism groups</em> of oriented trees, namely the groups consisting of all permutations π of the vertices and arcs for which we have init(<em>e</em>π) = init(<em>e</em>)π, fin(<em>e</em>π) = fin(<em>e</em>)π.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_2_9a" id="ch02ex_3_2_9">9</a>.</strong> [<em>18</em>] By assigning directions to the edges, draw the oriented tree corresponding to the free tree in <a href="../Text/ch02b.html#ch02fig30">Fig. 30</a> on page <a href="../Text/ch02b.html#page_363">363</a>, with <em>G</em> as the root.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_10a" id="ch02ex_3_2_10">10</a>.</strong> [<em>22</em>] An oriented tree with vertices <em>V</em><sub>1</sub><em>, ..., V</em><sub><em>n</em></sub> can be represented inside a computer by using a table <em>P</em> [1]<em>, ..., P</em> [<em>n</em>] as follows: If <em>V</em><sub><em>j</em></sub> is the root, <em>P</em> [<em>j</em>] = 0; otherwise <em>P</em> [<em>j</em>] = <em>k</em>, if the arc <em>e</em>[<em>V</em><sub><em>j</em></sub>] goes from <em>V</em><sub><em>j</em></sub> to <em>V</em><sub><em>k</em></sub>. (Thus <em>P</em> [1]<em>, ..., P</em> [<em>n</em>] is the same as the “parent” table used in <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm 2.3.3E</a>.)</p>

  <p class="indent">The text shows how a free tree can be converted into an oriented tree by choosing any desired vertex to be the root. Consequently, it is possible to start with an oriented tree that has root <em>R</em>, then to convert this into a free tree by neglecting the orientation of the arcs, and finally to assign new orientations, obtaining an oriented tree with any specified vertex as the root. Design an algorithm that performs this transformation: Starting with a table <em>P</em> [1]<em>, ..., P</em> [<em>n</em>], representing an oriented tree, and given an integer <em>j</em>, 1 <em>≤ j ≤ n</em>, design the algorithm to transform the <em>P</em> table so that it represents the same free tree but with <em>V</em><sub><em>j</em></sub> as the root.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_11a" id="ch02ex_3_2_11">11</a>.</strong> [<em>28</em>] Using the assumptions of <a href="../Text/ch02b.html#ch02lev3sec1">exercise 2.3.4.1</a>–<a href="../Text/ch02b.html#ch02ex_3_1_6">6</a>, but with (<em>a</em><sub><em>k</em></sub><em>, b</em><sub><em>k</em></sub>) representing an arc from <em>V</em><sub><em>a<sub>k</sub></em></sub> to <em>V</em><sub><em>b<sub>k</sub></em></sub>, design an algorithm that not only prints out a free subtree as in that algorithm, but also prints out the fundamental cycles. [<em>Hint:</em> The algorithm given in the solution to <a href="../Text/ch02b.html#ch02lev3sec1">exercise 2.3.4.1</a>–<a href="../Text/ch02b.html#ch02ex_3_1_6">6</a> can be combined with the algorithm in the preceding exercise.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_12a" id="ch02ex_3_2_12">12</a>.</strong> [<em>M10</em>] In the correspondence between oriented trees as defined here and oriented trees as defined at the beginning of <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a>, is the <em>degree</em> of a tree node equal to the <em>in-degree</em> or the <em>out-degree</em> of the corresponding vertex?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_13a" id="ch02ex_3_2_13">13</a>.</strong> [<em>M24</em>] Prove that if <em>R</em> is a root of a (possibly infinite) directed graph <em>G</em>, then <em>G</em> contains an oriented subtree with the same vertices as <em>G</em> and with root <em>R</em>. (As a consequence, it is always possible to choose the free subtree in flow charts like <a href="../Text/ch02b.html#ch02fig32">Fig. 32</a> of <a href="../Text/ch02b.html#ch02lev3sec1">Section 2.3.4.1</a> so that it is actually an <em>oriented</em> subtree; this would be the case in that diagram if we had selected <span class="middle"><img src="../Images/ch02/e377_01.jpg"></span>, <span class="middle"><img src="../Images/ch02/e377_02.jpg"></span>, <em>e</em><sub>20</sub>, and <em>e</em><sub>17</sub> instead of <span class="middle"><img src="../Images/ch02/e377_03.jpg"></span>, <span class="middle"><img src="../Images/ch02/e377_04.jpg"></span>, <em>e</em><sub>23</sub>, and <em>e</em><sub>15</sub>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_14a" id="ch02ex_3_2_14">14</a>.</strong> [<em>21</em>] Let <em>G</em> be the balanced digraph shown in <a href="../Text/ch02b.html#ch02fig36">Fig. 36</a>, and let <em>G</em>′ be the oriented subtree with vertices <em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub> and arcs <em>e</em><sub>01</sub>, <em>e</em><sub>21</sub>. Find all oriented walks <em>P</em> that meet the conditions of <a href="../Text/ch02b.html#ch02b_the_d">Theorem D</a>, starting with arc <em>e</em><sub>12</sub>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_15a" id="ch02ex_3_2_15">15</a>.</strong> [<em>M20</em>] True or false: A directed graph that is connected and balanced is strongly connected.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_16a" id="ch02ex_3_2_16">16</a>.</strong> [<em>M24</em>] In a popular solitaire game called “clock,” the 52 cards of an ordinary deck of playing cards are dealt face down into 13 piles of four each; 12 piles are arranged in a circle like the 12 hours of a clock and the thirteenth pile goes in the center. The solitaire game now proceeds by turning up the top card of the center pile, and then if its face value is <em>k</em>, by placing it next to the <em>k</em>th pile. (The numbers 1<em>,</em> 2<em>, ...,</em> 13 are equivalent to A<em>,</em> 2<em>, ...,</em> 10<em>,</em> J<em>,</em> Q<em>,</em> K.) Play continues by turning up the top card of the <em>k</em>th pile and putting it next to <em>its</em> pile, etc., until we reach a point where we cannot continue since there are no more cards to turn up on the designated pile. (The player has no choice in the game, since the rules completely specify what to do.) The game is won if all cards are face up when play terminates. [<em>Reference:</em> E. D. Cheney,<em>Patience</em> (Boston: Lee &amp; Shepard, 1870), 62–65; the game was called “Travellers’ Patience” in <a id="page_378"></a>England, according to M. Whitmore Jones,<em>Games of Patience</em> (London: L. Upcott Gill, 1900), Chapter 7.]</p>

  <p class="indent">Show that the game will be won if and only if the following directed graph is an oriented tree: The vertices are <em>V</em><sub>1</sub><em>, V</em><sub>2</sub><em>, ..., V</em><sub>13</sub>; the arcs are <em>e</em><sub>1</sub><em>, e</em><sub>2</sub><em>, ..., e</em><sub>12</sub>, where <em>e</em><sub><em>j</em></sub> goes from <em>V</em><sub><em>j</em></sub> to <em>V</em><sub><em>k</em></sub> if <em>k</em> is the <em>bottom</em> card in pile <em>j</em> after the deal.</p>

  <p class="indent">(In particular, if the bottom card of pile <em>j</em> is a “<em>j</em>”, for <em>j</em> ≠ 13, it is easy to see that the game is certainly lost, since this card could never be turned up. The result proved in this exercise gives a much faster way to play the game!)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_17a" id="ch02ex_3_2_17">17</a>.</strong> [<em>M32</em>] What is the probability of winning the solitaire game of clock (described in <a href="../Text/ch02b.html#ch02ex_3_2_16">exercise 16</a>), assuming the deck is randomly shuffled? What is the probability that exactly <em>k</em> cards are still face down when the game is over?</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_18a" id="ch02ex_3_2_18">18</a>.</strong> [<em>M30</em>] Let <em>G</em> be a graph with <em>n</em> + 1 vertices <em>V</em><sub>0</sub><em>, V</em><sub>1</sub><em>, ..., V</em><sub><em>n</em></sub> and <em>m</em> edges <em>e</em><sub>1</sub><em>, ..., e</em><sub><em>m</em></sub>. Make <em>G</em> into a directed graph by assigning an arbitrary orientation to each edge; then construct the <em>m</em> × (<em>n</em> + 1) matrix <em>A</em> with</p>

  <div class="image"><img src="../Images/ch02/e378_01.jpg"></div>

  <p class="exercisesp">Let <em>A</em><sub>0</sub> be the <em>m × n</em> matrix <em>A</em> with column 0 deleted.</p>

  <p class="indenthangingA">a) If <em>m</em> = <em>n</em>, show that the determinant of <em>A</em><sub>0</sub> is equal to 0 if <em>G</em> is not a free tree, and equal to ±1 if <em>G is</em> a free tree.</p>

  <p class="indenthangingA">b) Show that for general <em>m</em> the determinant of <span class="middle"><img src="../Images/ch02/e378_02.jpg"></span> is the number of free subtrees of <em>G</em> (namely the number of ways to choose <em>n</em> of the <em>m</em> edges so that the resulting graph is a free tree). [<em>Hint:</em> Use (a) and the result of <a href="../Text/ch01.html#ch01lev2sec3">exercise 1.2.3</a>–<a href="../Text/ch01.html#ch01ex_2_3_46">46</a>.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_19a" id="ch02ex_3_2_19">19</a>.</strong> [<em>M31</em>] (<em>The matrix tree theorem.</em>) Let <em>G</em> be a directed graph with <em>n</em> + 1 vertices <em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub>. Let <em>A</em> be the (<em>n</em> + 1) × (<em>n</em> + 1) matrix with</p>

  <div class="image"><img src="../Images/ch02/e378_03.jpg"></div>

  <p class="exercisesp">(It follows that <em>a</em><sub><em>i</em> 0</sub> + <em>a</em><sub><em>i</em> 1</sub> + <em>·</em> · · + <em>a</em><sub><em>in</em></sub> = 0 for 0 <em>≤ i ≤ n</em>.) Let <em>A</em><sub>0</sub> be the same matrix with row 0 and column 0 deleted. For example, if <em>G</em> is the directed graph of <a href="../Text/ch02b.html#ch02fig36">Fig. 36</a>, we have</p>

  <div class="image"><img src="../Images/ch02/e378_04.jpg"></div>

  <p class="indenthangingA">a) Show that if <em>a</em><sub>00</sub> = 0 and <em>a</em><sub><em>jj</em></sub> = 1 for 1 <em>≤ j ≤ n</em>, and if <em>G</em> contains no arcs from a vertex to itself, then det <em>A</em><sub>0</sub> = [<em>G</em> is an oriented tree with root <em>V</em><sub>0</sub>].</p>

  <p class="indenthangingA">b) Show that in general, det <em>A</em><sub>0</sub> is the number of oriented subtrees of <em>G</em> rooted at <em>V</em><sub>0</sub>(namely the number of ways to select <em>n</em> of the arcs of <em>G</em> so that the resulting directed graph is an oriented tree, with <em>V</em><sub>0</sub> as the root). [<em>Hint:</em> Use induction on the number of arcs.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_20a" id="ch02ex_3_2_20">20</a>.</strong> [<em>M21</em>] If <em>G</em> is an undirected graph on <em>n</em> + 1 vertices <em>V</em><sub>0</sub><em>, ..., V</em><sub><em>n</em></sub>, let <em>B</em> be the <em>n × n</em> matrix defined as follows for 1 <em>≤ i, j ≤ n</em>:</p>

  <div class="image"><img src="../Images/ch02/e378_05.jpg"></div>

  <p class="exercisesp"><a id="page_379"></a>For example, if <em>G</em> is the graph of <a href="../Text/ch02b.html#ch02fig29">Fig. 29</a> on page <a href="../Text/ch02b.html#page_363">363</a>, with (<em>V</em><sub>0</sub><em>, V</em><sub>1</sub><em>, V</em><sub>2</sub><em>, V</em><sub>3</sub><em>, V</em><sub>4</sub>) = (<em>A, B, C, D, E</em>), we find that</p>

  <div class="image"><img src="../Images/ch02/e379_01.jpg"></div>

  <p class="exercisesp">Show that the number of free subtrees of <em>G</em> is det <em>B</em>. [<em>Hint:</em> Use <a href="../Text/ch02b.html#ch02ex_3_2_18">exercise 18</a> or 19.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_21a" id="ch02ex_3_2_21">21</a>.</strong> [<em>HM38</em>] (T. van Aardenne-Ehrenfest and N. G. de Bruijn.) <a href="../Text/ch02b.html#ch02fig36">Figure 36</a> is an example of a directed graph that is not only balanced, it is <em>regular</em>, which means that every vertex has the same in-degree and out-degree as every other vertex. Let <em>G</em> be a regular digraph with <em>n</em> vertices <em>V</em><sub>0</sub><em>, V</em><sub>1</sub><em>, ..., V</em><sub><em>n</em></sub><em><sub>−</sub></em><sub>1</sub>, in which every vertex has in-degree and out-degree equal to <em>m</em>. (Hence there are <em>mn</em> arcs in all.) Let <em>G*</em> be the digraph with <em>mn</em> vertices corresponding to the arcs of <em>G</em>; let a vertex of <em>G*</em> corresponding to an arc from <em>V</em><sub><em>j</em></sub> to <em>V</em><sub><em>k</em></sub> in <em>G</em> be denoted by <em>V</em><sub><em>jk</em></sub>. An arc goes from <em>V</em><sub><em>jk</em></sub> to <em>V</em><sub><em>j</em>′ <em>k</em>′</sub> in <em>G*</em> if and only if <em>k</em> = <em>j</em>′. For example, if <em>G</em> is the directed graph of <a href="../Text/ch02b.html#ch02fig36">Fig. 36</a>, <em>G*</em> is shown in <a href="../Text/ch02b.html#ch02fig37">Fig. 37</a>. An Eulerian trail in <em>G</em> is a Hamiltonian cycle in <em>G*</em> and conversely.</p>

  <div class="image">
    <a id="ch02fig37"></a><img src="../Images/ch02/02fig37.jpg">

    <p class="fig-caption"><strong>Fig. 37.</strong> Arc digraph corresponding to <a href="../Text/ch02b.html#ch02fig36">Fig. 36</a>. (See <a href="../Text/ch02b.html#ch02ex_3_2_21">exercise 21</a>.)</p>
  </div>

  <p class="indent">Prove that the number of oriented subtrees of <em>G*</em> is <em>m</em><sup>(<em>m</em> −1)<em>n</em></sup> times the number of oriented subtrees of <em>G</em>. [<em>Hint:</em> Use <a href="../Text/ch02b.html#ch02ex_3_2_19">exercise 19</a>.]</p>

  <p class="exercises3"><a id="page_380"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_22a" id="ch02ex_3_2_22">22</a>.</strong> [<em>M26</em>] Let <em>G</em> be a balanced, directed graph with vertices <em>V</em><sub>1</sub><em>, V</em><sub>2</sub><em>, ..., V</em><sub><em>n</em></sub> and no isolated vertices. Let <em>σ</em><sub><em>j</em></sub> be the out-degree of <em>V</em><sub><em>j</em></sub>. Show that the number of Eulerian trails of <em>G</em> is</p>

  <div class="image"><img src="../Images/ch02/e380_01.jpg"></div>

  <p class="exercisesp">where <em>T</em> is the number of oriented subtrees of <em>G</em> with root <em>V</em><sub>1</sub>. [<em>Note:</em> The factor (<em>σ</em><sub>1</sub> + <em>·</em> · · + <em>σ</em><sub><em>n</em></sub>), which is the number of arcs of <em>G</em>, may be omitted if the Eulerian trail (<em>e</em><sub>1</sub><em>, ..., e</em><sub><em>m</em></sub>) is regarded as equal to (<em>e</em><sub><em>k</em></sub><em>, ..., e</em><sub><em>m</em></sub><em>, e</em><sub>1</sub><em>, ..., e</em><sub><em>k</em></sub><em><sub>−</sub></em><sub>1</sub>).]</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_23a" id="ch02ex_3_2_23">23</a>.</strong> [<em>M33</em>] (N. G. de Bruijn.) For each sequence of nonnegative integers <em>x</em><sub>1</sub><em>, ..., x</em><sub><em>k</em></sub> less than <em>m</em>, let <em>f</em>(<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>k</em></sub>) be a nonnegative integer less than <em>m</em>. Define an infinite sequence as follows: <em>X</em><sub>1</sub> = <em>X</em><sub>2</sub> = <em>·</em> · · = <em>X</em><sub><em>k</em></sub> = 0; <em>X</em><sub><em>n</em> + <em>k</em> +1</sub> = <em>f</em>(<em>X</em><sub><em>n</em> + <em>k</em></sub><em>, ..., X</em><sub><em>n</em> +1</sub>) when <em>n</em> ≥ 0. For how many of the <em>m<sup>m<sup>k</sup></sup></em> possible functions <em>f</em> is this sequence periodic with a period of the maximum length <em>m<sup>k</sup></em>? [<em>Hint:</em> Construct a directed graph with vertices (<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>k</em></sub><em><sub>−</sub></em><sub>1</sub>) for all 0 <em>≤ x</em><sub><em>j</em></sub><em>&lt; m</em>, and with arcs from (<em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ..., x</em><sub><em>k</em></sub><em><sub>−</sub></em><sub>1</sub>) to (<em>x</em><sub>2</sub><em>, ..., x</em><sub><em>k</em></sub><em><sub>−</sub></em><sub>1</sub><em>, x</em><sub><em>k</em></sub>); apply <a href="../Text/ch02b.html#ch02ex_3_2_21">exercises 21</a> and <a href="../Text/ch02b.html#ch02ex_3_2_22">22</a>.]</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_24a" id="ch02ex_3_2_24">24</a>.</strong> [<em>M20</em>] Let <em>G</em> be a connected digraph with arcs <em>e</em><sub>0</sub><em>, e</em><sub>1</sub><em>, ..., e</em><sub><em>m</em></sub>. Let <em>E</em><sub>0</sub><em>, E</em><sub>1</sub><em>, ..., E</em><sub><em>m</em></sub> be a set of positive integers that satisfy Kirchhoff’s law for <em>G</em>; that is, for each vertex <em>V</em>,</p>

  <div class="image"><img src="../Images/ch02/e380_02.jpg"></div>

  <p class="exercisesp">Assume further that <em>E</em><sub>0</sub> = 1. Prove that there is an oriented walk in <em>G</em> from fin(<em>e</em><sub>0</sub>) to init(<em>e</em><sub>0</sub>) such that edge <em>e</em><sub><em>j</em></sub> appears exactly <em>E</em><sub><em>j</em></sub> times, for 1 <em>≤ j ≤ m</em>, while edge <em>e</em><sub>0</sub> does not appear. [<em>Hint:</em> Apply <a href="../Text/ch02b.html#ch02b_the_g">Theorem G</a> to a suitable directed graph.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_25a" id="ch02ex_3_2_25">25</a>.</strong> [<em>26</em>] Design a computer representation for directed graphs that generalizes the right-threaded binary tree representation of a tree. Use two link fields <code>ALINK</code>, <code>BLINK</code> and two one-bit fields <code>ATAG</code>, <code>BTAG</code>; and design the representation so that: (i) there is one node for each <em>arc</em> of the directed graph (<em>not</em> for each vertex); (ii) if the directed graph is an oriented tree with root <em>R</em>, and if we add an arc from <em>R</em> to a new vertex <em>H</em>, then the representation of this directed graph is essentially the same as a right-threaded representation of this oriented tree (with some order imposed on the children in each family), in the sense that <code>ALINK</code>, <code>BLINK</code>, <code>BTAG</code> are respectively the same as <code>LLINK</code>, <code>RLINK</code>, <code>RTAG</code> in <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>; and (iii) the representation is symmetric in the sense that interchanging <code>ALINK</code>, <code>ATAG</code>, with <code>BLINK</code>, <code>BTAG</code> is equivalent to changing the direction on all the arcs of the directed graph.</p>

  <p class="exercises1"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span> <strong><a id="ch02ex_3_2_26"></a>26.</strong> [<em>HM39</em>] (<em>Analysis of a random algorithm.</em>) Let <em>G</em> be a directed graph on the vertices <em>V</em><sub>1</sub><em>, V</em><sub>2</sub><em>, ..., V</em><sub><em>n</em></sub>. Assume that <em>G</em> represents the flow chart for an algorithm, where <em>V</em><sub>1</sub> is the Start vertex and <em>V</em><sub><em>n</em></sub> is the Stop vertex. (Therefore <em>V</em><sub><em>n</em></sub> is a root of <em>G</em>.) Suppose each arc <em>e</em> of <em>G</em> has been assigned a probability <em>p</em>(<em>e</em>), where the probabilities satisfy the conditions</p>

  <div class="image"><img src="../Images/ch02/e380_03.jpg"></div>

  <p class="exercisesp">Consider a random walk, which starts at <em>V</em><sub>1</sub> and subsequently chooses branch <em>e</em> of <em>G</em> with probability <em>p</em>(<em>e</em>), until <em>V</em><sub><em>n</em></sub> is reached; the choice of branch taken at each step is to be independent of all previous choices.</p>

  <p class="exercises1N"><a id="page_381"></a>For example, consider the graph of <a href="../Text/ch02b.html#ch02lev3sec1">exercise 2.3.4.1</a>–<a href="../Text/ch02b.html#ch02ex_3_1_7">7</a>, and assign the respective probabilities <span class="middle"><img src="../Images/ch02/e381_01.jpg"></span> to arcs <em>e</em><sub>1</sub><em>, e</em><sub>2</sub><em>, ..., e</em><sub>9</sub>. Then the walk “Start–<em>A</em>– <em>B</em>–<em>C</em>–<em>A</em>–<em>D</em>–<em>B</em>–<em>C</em>–Stop” is chosen with probability <span class="middle"><img src="../Images/ch02/e381_02.jpg"></span>.</p>

  <p class="exercises1N">Such random walks are called <em>Markov chains</em>, after the Russian mathematician Andrei A. Markov, who first made extensive studies of stochastic processes of this kind. The situation serves as a model for certain algorithms, although our requirement that each choice must be independent of the others is a very strong assumption. The purpose of this exercise is to analyze the computation time for algorithms of this kind.</p>

  <p class="exercises1N">The analysis is facilitated by considering the <em>n × n</em> matrix <em>A</em> = (<em>a</em><sub><em>ij</em></sub>), where <em>a</em><sub><em>ij</em></sub> = <em>∑p</em>(<em>e</em>) summed over all arcs <em>e</em> that go from <em>V</em><sub><em>i</em></sub> to <em>V</em><sub><em>j</em></sub>. If there is no such arc, <em>a</em><sub><em>ij</em></sub> = 0. The matrix <em>A</em> for the example considered above is</p>

  <div class="image"><img src="../Images/ch02/e381_03.jpg"></div>

  <p class="exercisesp">It follows easily that (<em>A<sup>k</sup></em>)<sub><em>ij</em></sub> is the probability that a walk starting at <em>V</em><sub><em>i</em></sub> will be at <em>V</em><sub><em>j</em></sub> after <em>k</em> steps.</p>

  <p class="exercises1N">Prove the following facts, for an arbitrary directed graph <em>G</em> of the stated type:</p>

  <p class="indenthangingA">a) The matrix (<em>I − A</em>) is nonsingular. [<em>Hint:</em> Show that there is no nonzero vector <em>x</em> with <em>xA<sup>n</sup></em> = <em>x</em>.]</p>

  <p class="indenthangingA">b) The average number of times that vertex <em>V</em><sub><em>j</em></sub> appears in the walk is</p>

  <div class="image"><img src="../Images/ch02/e381_05.jpg"></div>

  <p class="indenthangingP">[Thus in the example considered we find that the vertices <em>A</em>, <em>B</em>, <em>C</em>, <em>D</em> are traversed respectively <span class="middle"><img src="../Images/ch02/e381_06.jpg"></span> times, on the average.]</p>

  <p class="indenthangingA">c) The probability that <em>V</em><sub><em>j</em></sub> occurs in the walk is</p>

  <p class="center"><em>a</em><sub><em>j</em></sub> = cofactor<sub><em>j</em>1</sub>(<em>I − A</em>)<em>/</em>cofactor<sub><em>jj</em></sub>(<em>I − A</em>);</p>

  <p class="indenthangingP">furthermore, <em>a</em><sub><em>n</em></sub> = 1, so the walk terminates in a finite number of steps with probability one.</p>

  <p class="indenthangingA">d) The probability that a random walk starting at <em>V</em><sub><em>j</em></sub> will never return to <em>V</em><sub><em>j</em></sub> is <em>b</em><sub><em>j</em></sub> = det (<em>I − A</em>)<em>/</em>cofactor<sub><em>jj</em></sub>(<em>I − A</em>).</p>

  <p class="indenthangingA">e) The probability that <em>V</em><sub><em>j</em></sub> occurs exactly <em>k</em> times in the walk is <em>a</em><sub><em>j</em></sub>(1 <em>− b</em><sub><em>j</em></sub>)<em><sup>k</sup></em> − <sup>1</sup><em>b</em><sub><em>j</em></sub>, for <em>k</em> ≥ 1, 1 <em>≤ j ≤ n</em>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_2_27a" id="ch02ex_3_2_27">27</a>.</strong> [<em>M30</em>] (<em>Steady states.</em>) Let <em>G</em> be a directed graph on vertices <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>n</em></sub>, whose arcs have been assigned probabilities <em>p</em>(<em>e</em>) as in <a href="../Text/ch02b.html#ch02ex_3_2_26">exercise 26</a>. Instead of having Start and Stop vertices, however, assume that <em>G</em> is strongly connected; thus each vertex <em>V</em><sub><em>j</em></sub> is a root, and we assume that the probabilities <em>p</em>(<em>e</em>) are positive and satisfy ∑<sub>init(<em>e</em>)</sub>= <em>V<sub>j</sub> p</em>(<em>e</em>) = 1 for all <em>j</em>. A random process of the kind described in <a href="../Text/ch02b.html#ch02ex_3_2_26">exercise 26</a> is said to have a “steady state” (<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>n</em></sub>) if</p>

  <div class="image"><img src="../Images/ch02/e381_07.jpg"></div>

  <p class="exercisesp"><a id="page_382"></a>Let <em>t</em><sub><em>j</em></sub> be the sum, over all oriented subtrees <em>T</em><sub><em>j</em></sub> of <em>G</em> that are rooted at <em>V</em><sub><em>j</em></sub>, of the products <em>∏<sub>e</sub></em> <sub><span class="ent">∊</span></sub><sub><em>Tj</em></sub><em>p</em>(<em>e</em>). Prove that (<em>t</em><sub>1</sub><em>, ..., t</em><sub><em>n</em></sub>) is a steady state of the random process.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_2_28a" id="ch02ex_3_2_28">28</a>.</strong> [<em>M35</em>] Consider the (<em>m</em> + <em>n</em>) × (<em>m</em> + <em>n</em>) determinant illustrated here for <em>m</em> = 2 and <em>n</em> = 3:</p>

  <div class="image"><img src="../Images/ch02/e382_01.jpg"></div>

  <p class="exercisesp">Show that when this determinant is expanded as a polynomial in the <em>a</em>’s and <em>b</em>’s, each nonzero term has coefficient +1. How many terms appear in the expansion? Give a rule, related to oriented trees, that characterizes exactly which terms are present.</p>

  <div class="heading">
    <h5 id="ch02lev3sec3">*2.3.4.3. The “infinity lemma”</h5>

    <p class="noindent">Until now we have concentrated mainly on trees that have only finitely many vertices (nodes), but the definitions we have given for free trees and oriented trees apply to infinite graphs as well. Infinite <em>ordered</em> trees can be defined in several ways; we can, for example, extend the concept of “Dewey decimal notation” to infinite collections of numbers, as in <a href="../Text/ch02a.html#ch02lev1sec3">exercise 2.3</a>–<a href="../Text/ch02a.html#ch02ex_1_3_14">14</a>. Even in the study of computer algorithms there is occasionally a need to know the properties of infinite trees — for example, to prove by contradiction that a certain tree is <em>not</em> infinite. One of the most fundamental properties of infinite trees, first stated in its full generality by D. Kőnig, is the following:</p>
  </div>

  <p class="noindent"><strong><a id="ch02theor-k"></a>Theorem K</strong> (<em>The “infinity lemma</em>”). <em>Every infinite oriented tree in which every vertex has finite degree has an infinite path to the root, that is, an infinite sequence of vertices V</em><sub>0</sub><em>, V</em><sub>1</sub><em>, V</em><sub>2</sub><em>, ... in which V</em><sub>0</sub><em>is the root and</em> fin(<em>e</em>[<em>V</em><sub><em>j</em> +1</sub>]) = <em>V</em><sub><em>j</em></sub><em>for all j</em> ≥ 0.</p>

  <p class="noindent"><em>Proof.</em> We define the path by starting with <em>V</em><sub>0</sub>, the root of the oriented tree. Assume that <em>j</em> ≥ 0 and that <em>V</em><sub><em>j</em></sub> has been chosen having infinitely many descendants. The degree of <em>V</em><sub><em>j</em></sub> is finite by hypothesis, so <em>V</em><sub><em>j</em></sub> has finitely many children <em>U</em><sub>1</sub><em>, ..., U</em><sub><em>n</em></sub>. At least one of these children must possess infinitely many descendants, so we take <em>V</em><sub><em>j</em> +1</sub> to be such a child of <em>V</em><sub><em>j</em></sub>.</p>

  <p class="indent">Now <em>V</em><sub>0</sub>, <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ... is an infinite path to the root. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">Students of calculus may recognize that the argument used here is essentially like that used to prove the classical Bolzano–Weierstrass theorem, “A bounded infinite set of real numbers has an accumulation point.” One way of stating <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a>, as Kőnig observed, is this: “If the human race never dies out, somebody now living has a line of descendants that will never die out.”</p>

  <p class="indent">Most people think that <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a> is completely obvious when they first encounter it, but after more thought and a consideration of further examples they realize that there is something profound about it. Although the degree of each node of the tree is finite, we have not assumed that the degrees are <em>bounded</em> (less than some number <em>N</em> for all vertices), so there may be nodes with higher and higher degrees. It is at least conceivable that everyone’s descendants will ultimately die out although there will be some families that go on a million <a id="page_383"></a>generations, others a billion, and so on. In fact, H. W. Watson once published a “proof” that under certain laws of biological probability carried out indefinitely, there will be infinitely many people born in the future but each family line will die out with probability one. His paper [<em>J. Anthropological Inst. Gt. Britain and Ireland</em> <strong>4</strong> (1874), 138–144] contains important and far-reaching theorems in spite of the minor slip that caused him to make this statement, and it is significant that he did not find his conclusions to be logically inconsistent.</p>

  <p class="indent">The contrapositive of <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a> is directly applicable to computer algorithms: <em>If we have an algorithm that periodically divides itself up into finitely many subalgorithms, and if each chain of subalgorithms ultimately terminates, then the algorithm itself terminates.</em></p>

  <p class="indent">Phrased yet another way, suppose we have a set <em>S</em>, finite or infinite, such that each element of <em>S</em> is a sequence (<em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ..., x</em><sub><em>n</em></sub>) of positive integers of finite length <em>n</em> ≥ 0. If we impose the conditions that</p>

  <p class="indenti">i) if (<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>n</em></sub>) is in <em>S</em>, so is (<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>k</em></sub>) for 0<em>≤ k ≤ n</em>;</p>

  <p class="indenti">ii) if (<em>x</em><sub>1</sub><em>, ..., x</em><sub><em>n</em></sub>) is in <em>S</em>, only finitely many <em>x</em><sub><em>n</em> +1</sub> exist for which (<em>x</em><sub>1</sub><em>, ...</em>, <em>x</em><sub><em>n</em></sub><em>, x</em><sub><em>n</em> +1</sub>) is also in <em>S</em>;</p>

  <p class="indenti">iii) there is no infinite sequence (<em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ...</em>) all of whose initial subsequences (<em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ..., x</em><sub><em>n</em></sub>) lie in <em>S</em>;</p>

  <p class="noindent">then <em>S</em> is essentially an oriented tree, specified essentially in a Dewey decimal notation, and <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a> tells us that <em>S</em> is <em>finite</em>.</p>

  <p class="indent">One of the most convincing examples of the potency of <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a> arises in connection with a family of interesting tiling problems introduced by Hao Wang. A <em>tetrad type</em> is a square divided into four parts, each part having a specified number in it, such as</p>

  <div class="equation"><a id="ch02eq-lev3sec3-1"></a><img src="../Images/ch02/383equ01.jpg"></div>

  <p class="noindent">The problem of <em>tiling the plane</em> is to take a finite set of tetrad types, with an infinite supply of tetrads of each type, and to show how to place one in each square of an infinite plane (without rotating or reflecting the tetrad types) in such a way that two tetrads are adjacent only if they have equal numbers where they touch. For example, we can tile the plane using the six tetrad types</p>

  <div class="equation"><a id="ch02eq-lev3sec3-2"></a><img src="../Images/ch02/383equ02.jpg"></div>

  <p class="noindent">in essentially only one way, by repeating the rectangle</p>

  <div class="equation"><a id="ch02eq-lev3sec3-3"></a><img src="../Images/ch02/383equ03.jpg"></div>

  <p class="noindent"><a id="page_384"></a>over and over. The reader may easily verify that there is no way to tile the plane with the three tetrad types</p>

  <div class="equation"><a id="ch02eq-lev3sec3-4"></a><img src="../Images/ch02/384equ01.jpg"></div>

  <p class="indent">Wang’s observation [<em>Scientific American</em> <strong>213</strong>, 5 (November 1965), 98–106] is that<em>if it is possible to tile the upper right quadrant of the plane, it is possible to tile the whole plane</em>. This is certainly unexpected, because a method for tiling the upper right quadrant involves a “boundary” along the <em>x</em> and <em>y</em> axes, and it would seem to give no hint as to how to tile the upper <em>left</em> quadrant of the plane (since tetrad types may not be rotated or reflected). We cannot get rid of the boundary merely by shifting the upper-quadrant solution down and to the left, since it does not make sense to shift the solution by more than a finite amount. But Wang’s proof runs as follows: The existence of an upper-right-quadrant solution implies that there is a way to tile a 2<em>n</em> × 2<em>n</em> square, for all <em>n</em>. The set of all solutions to the problem of tiling squares with an even number of cells on each side forms an oriented tree, if the children of each 2<em>n</em> × 2<em>n</em> solution <em>x</em> are the possible (2<em>n</em> + 2)× (2<em>n</em> + 2) solutions that can be obtained by bordering <em>x</em>. The root of this oriented tree is the 0× 0 solution; its children are the 2× 2 solutions, etc. Each node has only finitely many children, since the problem of tiling the plane assumes that only finitely many tetrad types are given; hence by the infinity lemma there is an infinite path to the root. This means that there is a way to tile the whole plane (although we may be at a loss to find it)!</p>

  <p class="indent">For later developments in tetrad tiling, see the beautiful book<em>Tilings and Patterns</em> by B. Grünbaum and G. C. Shephard (Freeman, 1987), Chapter 11.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_3_1a" id="ch02ex_3_3_1">1</a>.</strong> [<em>M10</em>] The text refers to a set <em>S</em> containing finite sequences of positive integers, and states that this set is “essentially an oriented tree.” What is the root of this oriented tree, and what are the arcs?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_3_2a" id="ch02ex_3_3_2">2</a>.</strong> [<em>20</em>] Show that if rotation of tetrad types is allowed, it is always possible to tile the plane.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_3_3a" id="ch02ex_3_3_3">3</a>.</strong> [<em>M23</em>] If it is possible to tile the upper right quadrant of the plane when given an <em>infinite</em> set of tetrad types, is it always possible to tile the whole plane?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_3_4a" id="ch02ex_3_3_4">4</a>.</strong> [<em>M25</em>] (H. Wang.) The six tetrad types (<a href="../Text/ch02b.html#ch02eq-lev3sec3-2">2</a>) lead to a toroidal solution to the tiling problem, that is, a solution in which some rectangular pattern — namely (<a href="../Text/ch02b.html#ch02eq-lev3sec3-3">3</a>) — is replicated throughout the entire plane.</p>

  <p class="indent">Assume without proof that whenever it is possible to tile the plane with a finite set of tetrad types, there is a toroidal solution using those tetrad types. Use this assumption together with the infinity lemma to design an algorithm that, given the specifications of any finite set of tetrad types, determines in a finite number of steps whether or not there exists a way to tile the plane with these types.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_3_5a" id="ch02ex_3_3_5">5</a>.</strong> [<em>M40</em>] Show that using the following 92 tetrad types it is possible to tile the plane, but that there is no toroidal solution in the sense of <a href="../Text/ch02b.html#ch02ex_3_3_4">exercise 4</a>.</p>

  <p class="indent"><a id="page_385"></a>To simplify the specification of the 92 types, let us first introduce some notation. Define the following “basic codes”:</p>

  <div class="image"><img src="../Images/ch02/e385_01.jpg"></div>

  <p class="noindent">The tetrad types are now</p>

  <div class="image"><img src="../Images/ch02/e385_02.jpg"></div>

  <p class="noindent">These abbreviations mean that the basic codes are to be put together component by component and sorted into alphabetic order in each component; thus</p>

  <p class="center"><em>βY{B,U,Q}{P,T}</em></p>

  <p class="noindent">stands for six types <em>βYBP</em>, <em>βYUP</em>, <em>βYQP</em>, <em>βYBT</em>, <em>βYUT</em>, <em>βYQT</em>. The type <em>βYQT</em> is</p>

  <p class="center">(3<em>,</em>4<em>,</em>2<em>,</em>1)(<em>Y,Y, ,</em> ) (<em>Q,Q, ,</em> ) ( <em>, ,T,T</em>) = (3<em>QY,</em> 4<em>QY,</em> 2<em>T,</em> 1<em>T</em>)</p>

  <p class="noindent">after multiplying corresponding components and sorting into order. This is intended to correspond to the tetrad type shown on the right, where we use strings of symbols instead of numbers in the four quarters of the type. Two tetrad types can be placed next to each other only if they have the same string of symbols at the place they touch.</p>

  <div class="image"><img src="../Images/ch02/e385_03.jpg"></div>

  <p class="indent">A <em>β</em>-tetrad is one that has a <em>β</em> in its specification as given above. To get started on the solution to this exercise, note that any <em>β</em>-tetrad must have an α-tetrad to its left and to its right, and a <em>δ</em>-tetrad above and below. An <em>αa</em>-tetrad must have <em>βKB</em> or <em>βKU</em> or <em>βKQ</em> to its right, and then must come an <em>αb</em>-tetrad, etc.</p>

  <p class="indent">(This construction is a simplified version of a similar one given by Robert Berger, who went on to prove that the general problem in <a href="../Text/ch02b.html#ch02ex_3_3_4">exercise 4</a>, without the invalid assumption, cannot be solved. See<em>Memoirs Amer. Math. Soc.</em> <strong>66</strong> (1966).)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_3_6a" id="ch02ex_3_3_6">6</a>.</strong> [<em>M23</em>] (Otto Schreier.) In a famous paper [<em>Nieuw Archief voor Wiskunde</em> (<a href="../Text/ch02b.html#ch02eq-lev3sec3-2">2</a>) <strong>15</strong> (1927), 212–216], B. L. van der Waerden proved the following theorem:</p>

  <p class="uln-indent1"><em>If k and m are positive integers, and if we have k sets S</em><sub>1</sub><em>, ..., S</em><sub><em>k</em></sub> <em>of positive integers with every positive integer included in at least one of these sets, then at least one of the sets S</em><sub><em>j</em></sub> <em>contains an arithmetic progression of length m .</em></p>

  <p class="noindent">(The latter statement means there exist integers <em>a</em> and <em>δ</em> &gt; 0 such that <em>a</em> + <em>δ</em>, <em>a</em> + 2<em>δ</em>, ..., <em>a</em> + <em>mδ</em> are all in <em>S</em><sub><em>j</em></sub>.) If possible, use this result and the infinity lemma to prove the following stronger statement:</p>

  <p class="uln-indent1"><em>If k and m are positive integers, there is a number N such that if we have k sets S</em><sub>1</sub><em>, ..., S</em><sub><em>k</em></sub> <em>of integers with every integer between 1 and N included in at least one of these sets, then at least one of the sets S</em><sub><em>j</em></sub> <em>contains an arithmetic progression of length m.</em></p>

  <p class="exercises2"><a id="page_386"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_3_7a" id="ch02ex_3_3_7">7</a>.</strong> [<em>M30</em>] If possible, use van der Waerden’s theorem of <a href="../Text/ch02b.html#ch02ex_3_3_6">exercise 6</a> and the infinity lemma to prove the following stronger statement:</p>

  <p class="uln-indent"><em>If k is a positive integer, and if we have k sets S</em><sub>1</sub><em>, ..., S</em><sub><em>k</em></sub> <em>of integers with every positive integer included in at least one of these sets, then at least one of the sets S</em><sub><em>j</em></sub> <em>contains an infinitely long arithmetic progression.</em></p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_3_8a" id="ch02ex_3_3_8">8</a>.</strong> [<em>M39</em>] (J. B. Kruskal.) If <em>T</em> and <em>T<sup>′</sup></em> are (finite, ordered) trees, let the notation <em>T</em> <span class="ent">⊆</span> <em>T<sup>′</sup></em> signify that <em>T</em> can be embedded in <em>T<sup>′</sup></em>, as in <a href="../Text/ch02a.html#ch02lev2sec8">exercise 2.3.2</a>–<a href="../Text/ch02a.html#ch02ex_2_8_22">22</a>. Prove that if <em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, <em>T</em><sub>3</sub>, ... is any infinite sequence of trees, there exist integers <em>j &lt; k</em> such that <em>T</em><sub><em>j</em></sub><span class="ent">⊆</span> <em>T</em><sub><em>k</em></sub>. (In other words, it is impossible to construct an infinite sequence of trees in which no tree contains any of the earlier trees of the sequence. This fact can be used to prove that certain algorithms must terminate.)</p>

  <div class="heading">
    <h5 id="ch02lev3sec4">*2.3.4.4. Enumeration of trees</h5>

    <p class="noindent">Some of the most instructive applications of the mathematical theory of trees to the analysis of algorithms are connected with formulas for counting how many different trees there are of various kinds. For example, if we want to know how many different oriented trees can be constructed having four indistinguishable vertices, we find that there are just 4 possibilities:</p>
  </div>

  <div class="equation"><a id="ch02eq-lev3sec4-1"></a><img src="../Images/ch02/386equ01.jpg"></div>

  <p class="indent">For our first enumeration problem, let us determine the number <em>a</em><sub><em>n</em></sub> of structurally different oriented trees with <em>n</em> vertices. Obviously, <em>a</em><sub>1</sub> = 1. If <em>n</em> &gt; 1, the tree has a root and various subtrees; suppose there are <em>j</em><sub>1</sub> subtrees with 1 vertex, <em>j</em><sub>2</sub> with 2 vertices, etc. Then we may choose <em>j</em><sub><em>k</em></sub> of the <em>a</em><sub><em>k</em></sub> possible <em>k</em>-vertex trees in</p>

  <div class="image"><img src="../Images/ch02/e386_01.jpg"></div>

  <p class="noindent">ways, since repetitions are allowed (<a href="../Text/ch01a.html#ch01lev2sec6">exercise 1.2.6</a>–<a href="../Text/ch01a.html#ch01ex_2_6_60">60</a>), and so we see that</p>

  <div class="equation"><a id="ch02eq-lev3sec4-2"></a><img src="../Images/ch02/386equ02.jpg"></div>

  <p class="noindent">If we consider the generating function <em>A</em>(<em>z</em>) = <em>∑<sub>n</sub> a</em><sub><em>n</em></sub><em>z<sup>n</sup></em>, with <em>a</em><sub>0</sub> = 0, we find that the identity</p>

  <div class="image"><img src="../Images/ch02/e386_02.jpg"></div>

  <p class="noindent">together with (<a href="../Text/ch02b.html#ch02eq-lev3sec4-2">2</a>) implies</p>

  <div class="equation"><a id="ch02eq-lev3sec4-3"></a><img src="../Images/ch02/386equ03.jpg"></div>

  <p class="noindent">This is not an especially nice form for <em>A</em>(<em>z</em>), since it involves an infinite product and the coefficients <em>a</em><sub>1</sub><em>, a</em><sub>2</sub><em>, ...</em> appear on the right-hand side. A somewhat more aesthetic way to represent <em>A</em>(<em>z</em>) is given in <a href="../Text/ch02b.html#ch02ex_3_4_1">exercise 1</a>; it leads to a reasonably <a id="page_387"></a>efficient formula for calculating the values <em>a</em><sub><em>n</em></sub> (see <a href="../Text/ch02b.html#ch02ex_3_4_2">exercise 2</a>) and, in fact, it also can be used to deduce the asymptotic behavior of <em>a</em><sub><em>n</em></sub> for large <em>n</em> (see <a href="../Text/ch02b.html#ch02ex_3_4_4">exercise 4</a>). We find that</p>

  <div class="equation"><a id="ch02eq-lev3sec4-4"></a><img src="../Images/ch02/387equ01.jpg"></div>

  <p class="indent">Now that we have essentially found the number of oriented trees, it is quite interesting to determine the number of structurally different <em>free trees</em> with <em>n</em> vertices. There are just two distinct free trees with four vertices, namely</p>

  <div class="equation"><a id="ch02eq-lev3sec4-5"></a><img src="../Images/ch02/387equ02.jpg"></div>

  <p class="noindent">because the first two and last two oriented trees of (<a href="../Text/ch02b.html#ch02eq-lev3sec4-1">1</a>) become identical when the orientation is dropped.</p>

  <p class="indent">We have seen that it is possible to select any vertex <em>X</em> of a free tree and to assign directions to the edges in a unique way so that it becomes an oriented tree with <em>X</em> as root. Once this has been done, for a given vertex <em>X</em>, suppose there are <em>k</em> subtrees of the root <em>X</em>, with <em>s</em><sub>1</sub><em>, s</em><sub>2</sub><em>, ..., s</em><sub><em>k</em></sub> vertices in these respective subtrees. Clearly, <em>k</em> is the number of arcs touching <em>X</em>, and <em>s</em><sub>1</sub> + <em>s</em><sub>2</sub> +<em>·</em> · · + <em>s</em><sub><em>k</em></sub> = <em>n</em> − 1. In these circumstances we say that the <em>weight</em> of <em>X</em> is max(<em>s</em><sub>1</sub><em>, s</em><sub>2</sub><em>, ..., s</em><sub><em>k</em></sub>). Thus in the tree</p>

  <div class="equation"><a id="ch02eq-lev3sec4-6"></a><img src="../Images/ch02/387equ03.jpg"></div>

  <p class="noindent">the vertex <em>D</em> has weight 3 (each of the subtrees leading from <em>D</em> has three of the nine remaining vertices), and vertex <em>E</em> has weight max(7<em>,</em> 2) = 7. A vertex with minimum weight is called a <em>centroid</em> of the free tree.</p>

  <p class="indent">Let <em>X</em> and <em>s</em><sub>1</sub><em>, s</em><sub>2</sub><em>, ..., s</em><sub><em>k</em></sub> be as above, and let <em>Y</em><sub>1</sub><em>, Y</em><sub>2</sub><em>, ..., Y</em><sub><em>k</em></sub> be the roots of the subtrees emanating from <em>X</em>. If <em>Y</em> is any node in the <em>Y</em><sub>1</sub> subtree, its weight must be at least <em>n − s</em><sub>1</sub> = 1+<em>s</em><sub>2</sub> +<em>·</em> · ·+<em>s</em><sub><em>k</em></sub>, since when <em>Y</em> is the assumed root there are at least <em>n − s</em><sub>1</sub> vertices in its subtree containing <em>X</em>. Thus if <em>Y</em> is a centroid we have</p>

  <p class="center">weight (<em>X</em>) = max (<em>s</em><sub>1</sub><em>, s</em><sub>2</sub><em>, ..., s</em><sub><em>k</em></sub>)≥ weight (<em>Y</em>) ≥ 1 + <em>s</em><sub>2</sub> +<em>·</em> · · + <em>s</em><sub><em>k</em></sub><em>,</em></p>

  <p class="noindent">and this is possible only if <em>s</em><sub>1</sub><em>&gt; s</em><sub>2</sub> +<em>·</em> · · + <em>s</em><sub><em>k</em></sub>. A similar result may be derived if we replace <em>Y</em><sub>1</sub> by <em>Y</em><sub><em>j</em></sub> in this discussion. So <em>at most one of the subtrees at a vertex can contain a centroid.</em></p>

  <p class="indent">This is a strong condition, for it implies that <em>there are at most two centroids in a free tree, and if two centroids exist, they are adjacent</em>. (See <a href="../Text/ch02b.html#ch02ex_3_4_9">exercise 9</a>.)</p>

  <p class="indent">Conversely, if <em>s</em><sub>1</sub><em>&gt; s</em><sub>2</sub> +<em>·</em> · · + <em>s</em><sub><em>k</em></sub>, there <em>is</em> a centroid in the <em>Y</em><sub>1</sub> subtree, since</p>

  <p class="center">weight (<em>Y</em><sub>1</sub>) ≤ max (<em>s</em><sub>1</sub>− 1<em>,</em> 1 + <em>s</em><sub>2</sub> +<em>·</em> · · + <em>s</em><sub><em>k</em></sub>) <em>≤ s</em><sub>1</sub> = weight (<em>X</em>)<em>,</em></p>

  <p class="noindent"><a id="page_388"></a>and the weight of all nodes in the <em>Y</em><sub>2</sub><em>, ..., Y</em><sub><em>k</em></sub> subtrees is at least <em>s</em><sub>1</sub> + 1. We have proved that <em>the vertex X is the only centroid of a free tree if and only if</em></p>

  <div class="equation"><a id="ch02eq-lev3sec4-7"></a><img src="../Images/ch02/388equ01.jpg"></div>

  <p class="indent">Therefore the number of free trees with <em>n</em> vertices, having only one centroid, is the number of oriented trees with <em>n</em> vertices minus the number of such oriented trees violating condition (<a href="../Text/ch02b.html#ch02eq-lev3sec4-7">7</a>); the latter consist essentially of an oriented tree with <em>s</em><sub><em>j</em></sub> vertices and another oriented tree with <em>n − s</em><sub><em>j</em></sub><em>≤ s</em><sub><em>j</em></sub> vertices. The number with one centroid therefore comes to</p>

  <div class="equation"><a id="ch02eq-lev3sec4-8"></a><img src="../Images/ch02/388equ02.jpg"></div>

  <p class="noindent">A free tree with two centroids has an even number of vertices, and the weight of each centroid is <em>n/</em>2 (see <a href="../Text/ch02b.html#ch02ex_3_4_10">exercise 10</a>). So if <em>n</em> = 2<em>m</em>, the number of bicentroidal free trees is the number of choices of 2 things out of <em>a</em><sub><em>m</em></sub> with repetition, namely</p>

  <div class="image"><img src="../Images/ch02/e388_01.jpg"></div>

  <p class="noindent">To get the total number of free trees, we therefore add <span class="middle"><img src="../Images/ch02/e388_02.jpg"></span> to (<a href="../Text/ch02b.html#ch02eq-lev3sec4-8">8</a>) when <em>n</em> is even. The form of Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-8">8</a>) suggests a simple generating function, and indeed, we find without difficulty that <em>the generating function for the number of structurally different free trees is</em></p>

  <div class="equation"><a id="ch02eq-lev3sec4-9"></a><img src="../Images/ch02/388equ03.jpg"></div>

  <p class="noindent">This simple relation between <em>F</em> (<em>z</em>) and <em>A</em>(<em>z</em>) is due primarily to C. Jordan, who considered the problem in 1869.</p>

  <p class="indent">Now let us turn to the question of enumerating <em>ordered trees</em>, which are our principal concern with respect to computer programming algorithms. There are five structurally different ordered trees with four vertices:</p>

  <div class="equation"><a id="ch02eq-lev3sec4-10"></a><img src="../Images/ch02/388equ04.jpg"></div>

  <p class="noindent">The first two are identical as oriented trees, so only one of them appeared in (<a href="../Text/ch02b.html#ch02eq-lev3sec4-1">1</a>) above.</p>

  <p class="indent">Before we examine the number of different ordered tree structures, let us first consider the case of <em>binary trees</em>, since this is closer to the actual computer representation and it is easier to study. Let <em>b</em><sub><em>n</em></sub> be the number of different binary trees with <em>n</em> nodes. From the definition of binary tree it is apparent that <em>b</em><sub>0</sub> = 1, and for <em>n</em> &gt; 0 the number of possibilities is the number of ways to put a binary <a id="page_389"></a>tree with <em>k</em> nodes to the left of the root and another with <em>n</em> − 1<em>− k</em> nodes to the right. So</p>

  <div class="equation"><a id="ch02eq-lev3sec4-11"></a><img src="../Images/ch02/389equ01.jpg"></div>

  <p class="noindent">From this relation it is clear that the generating function</p>

  <p class="center"><em>B</em>(<em>z</em>) = <em>b</em><sub>0</sub> + <em>b</em><sub>1</sub><em>z</em> + <em>b</em><sub>2</sub><em>z</em><sup>2</sup> + ...</p>

  <p class="noindent">satisfies the equation</p>

  <div class="equation"><a id="ch02eq-lev3sec4-12"></a><img src="../Images/ch02/389equ02.jpg"></div>

  <p class="noindent">Solving this quadratic equation and using the fact that <em>B</em>(0) = 1, we obtain</p>

  <div class="equation"><a id="ch02eq-lev3sec4-13"></a><img src="../Images/ch02/389equ03.jpg"></div>

  <p class="noindent">(See <a href="../Text/ch01a.html#ch01lev2sec6">exercise 1.2.6</a>–<a href="../Text/ch01a.html#ch01ex_2_6_47">47</a>.) The desired answer is therefore</p>

  <div class="equation"><a id="ch02eq-lev3sec4-14"></a><img src="../Images/ch02/389equ04.jpg"></div>

  <p class="noindent">By Stirling’s formula, this is asymptotically <span class="middle"><img src="../Images/ch02/e389_01.jpg"></span>. Some important generalizations of Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-14">14</a>) appear in <a href="../Text/ch02b.html#ch02ex_3_4_11">exercises 11</a> and <a href="../Text/ch02b.html#ch02ex_3_4_32">32</a>.</p>

  <p class="indent">Returning to our question about ordered trees with <em>n</em> nodes, we can see that this is essentially the same question as the number of binary trees, since we have a natural correspondence between binary trees and forests, and a tree minus its root is a forest. Hence<em>the number of (ordered) trees with n vertices is b</em><sub><em>n</em>−1</sub><em>, the number of binary trees with n</em> − 1<em>vertices.</em></p>

  <p class="indent">The enumerations performed above assume that the vertices are indistinguishable points. If we label the vertices 1, 2, 3, 4 in (<a href="../Text/ch02b.html#ch02eq-lev3sec4-1">1</a>) and insist that 1 is to be the root, we now get 16 different oriented trees:</p>

  <div class="equation"><a id="ch02eq-lev3sec4-15"></a><img src="../Images/ch02/389equ05.jpg"></div>

  <p class="noindent"><a id="page_390"></a>The question of enumeration for labeled trees is clearly quite different from the one solved above. In this case it can be rephrased as follows: “Consider drawing three lines, pointing from each of the vertices 2, 3, and 4 to another vertex; there are three choices of lines emanating from each vertex, so there are 3<sup>3</sup> = 27 possibilities in all. How many of these 27 ways will yield oriented trees with 1 as the root?” The answer, as we have seen, is 16. A similar reformulation of the same problem, this time for the case of <em>n</em> vertices, is the following: “Let <em>f</em> (<em>x</em>) be an integer-valued function such that <em>f</em> (1) = 1 and 1 <em>≤ f</em> (<em>x</em>) <em>≤ n</em> for all integers 1 <em>≤ x ≤ n</em>. We call <em>f</em> a <em>tree mapping</em> if <em>f</em><sup>[<em>n</em>]</sup>(<em>x</em>), that is, <em>f</em>(<em>f</em> (<em>·</em> · · (<em>f</em> (<em>x</em>))<em>·</em> · ·)) iterated <em>n</em> times, equals 1, for all <em>x</em>. How many tree mappings are there?” This problem comes up, for example, in connection with random number generation. We will find, rather surprisingly, that on the average exactly one out of every <em>n</em> such functions <em>f</em> is a tree mapping.</p>

  <p class="indent">The solution to this enumeration problem can readily be derived using the general formulas for counting subtrees of graphs that have been developed in previous sections (see <a href="../Text/ch02b.html#ch02ex_3_4_12">exercise 12</a>). But there is a much more informative way to solve the problem, one that gives us a new and compact manner to represent oriented tree structure.</p>

  <p class="indent">Suppose that we’ve been given an oriented tree with vertices {1<em>,</em> 2<em>, ..., n</em>} and with <em>n</em> − 1 arcs, where the arcs go from <em>j</em> to <em>f</em> (<em>j</em>) for all <em>j</em> except the root. There is at least one terminal (leaf) vertex; let <em>V</em><sub>1</sub> be the smallest number of a leaf. If <em>n</em> &gt; 1, write down <em>f</em> (<em>V</em><sub>1</sub>) and delete both <em>V</em><sub>1</sub> and the arc <em>V</em><sub>1</sub><em>→ f</em> (<em>V</em><sub>1</sub>) from the tree; then let <em>V</em><sub>2</sub> be the smallest number whose vertex is terminal in the resulting tree. If <em>n</em> &gt; 2, write down <em>f</em> (<em>V</em><sub>2</sub>) and delete both <em>V</em><sub>2</sub> and the arc <em>V</em><sub>2</sub><em>→ f</em> (<em>V</em><sub>2</sub>) from the tree; and proceed in this way until all vertices have been deleted except the root. The resulting sequence of <em>n</em> − 1 numbers,</p>

  <div class="equation"><a id="ch02eq-lev3sec4-16"></a><img src="../Images/ch02/390equ01.jpg"></div>

  <p class="noindent">is called the <em>canonical representation</em> of the original oriented tree.</p>

  <p class="indent">For example, the oriented tree</p>

  <div class="equation"><a id="ch02eq-lev3sec4-17"></a><img src="../Images/ch02/390equ02.jpg"></div>

  <p class="noindent">with 10 vertices has the canonical representation 1, 3, 10, 5, 10, 1, 3, 5, 3.</p>

  <p class="indent">The important point here is that we can reverse this process and go from any sequence of <em>n</em> − 1 numbers (<a href="../Text/ch02b.html#ch02eq-lev3sec4-16">16</a>) back to the oriented tree that produced it. For if we have any sequence <em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ..., x</em><sub><em>n</em>−1</sub> of numbers between 1 and <em>n</em>, let <em>V</em><sub>1</sub> be the smallest number that does not appear in the sequence <em>x</em><sub>1</sub><em>, ..., x</em><sub><em>n</em>−1</sub>; then let <em>V</em><sub>2</sub> be the smallest number ≠ <em>V</em><sub>1</sub> that does not appear in the sequence <em>x</em><sub>2</sub><em>, ..., x</em><sub><em>n</em>−1</sub>; and so on. After obtaining a permutation <em>V</em><sub>1</sub><em>V</em><sub>2</sub><em>... V</em><sub><em>n</em></sub> of the integers {1<em>,</em> 2<em>, ..., n</em>} in this way, draw arcs from vertex <em>V</em><sub><em>j</em></sub> to vertex <em>x</em><sub><em>j</em></sub>, for 1<em>≤ j &lt; n</em>. This gives a construction of a directed graph with no oriented cycles, and by <a id="page_391"></a><a href="../Text/ch02b.html#ch02lev3sec2">exercise 2.3.4.2</a>–<a href="../Text/ch02b.html#ch02ex_3_4_7">7</a> it is an oriented tree. Clearly, the sequence <em>x</em><sub>1</sub><em>, x</em><sub>2</sub><em>, ..., x</em><sub><em>n</em>−1</sub> is the same as the sequence (<a href="../Text/ch02b.html#ch02eq-lev3sec4-16">16</a>) for this oriented tree.</p>

  <p class="indent">Since the process is reversible, we have obtained a one-to-one correspondence between (<em>n</em> − 1)-tuples of numbers {1<em>,</em> 2<em>, ..., n</em>} and oriented trees on these vertices. Hence <em>there are n<sup><em>n</em>−1</sup> distinct oriented trees with n labeled vertices.</em> If we specify that one vertex is to be the root, there is clearly no difference between one vertex and another, so there are <em>n</em><sup><em>n</em>−2</sup> distinct oriented trees on {1<em>,</em> 2<em>, ..., n</em>} having a given root. This accounts for the 16 = 4<sup>4−2</sup> trees in (<a href="../Text/ch02b.html#ch02eq-lev3sec4-15">15</a>). From this information it is easy to determine the number of <em>free trees</em> with labeled vertices (see <a href="../Text/ch02b.html#ch02ex_3_4_22">exercise 22</a>). The number of <em>ordered trees</em> with labeled vertices is also easy to determine, once we know the answer to that problem when no labels are involved (see <a href="../Text/ch02b.html#ch02ex_3_4_23">exercise 23</a>). So we have essentially solved the problems of enumerating the three fundamental classes of trees, with both labeled and unlabeled vertices.</p>

  <p class="indent">It is interesting to see what would happen if we were to apply our usual method of generating functions to the problem of enumerating labeled oriented trees. For this purpose we would probably find it easiest to consider the quantity <em>r</em>(<em>n, q</em>), the number of labeled directed graphs with <em>n</em> vertices, with no oriented cycles, and with one arc emanating from each of <em>q</em> designated vertices. The number of labeled oriented trees with a specified root is therefore <em>r</em>(<em>n, n</em> − 1). In this notation we find by simple counting arguments that, for any fixed integer <em>m</em>,</p>

  <div class="equation"><a id="ch02eq-lev3sec4-18"></a><img src="../Images/ch02/391equ01.jpg"></div>

  <div class="equation"><a id="ch02eq-lev3sec4-19"></a><img src="../Images/ch02/391equ02.jpg"></div>

  <p class="noindent">The first of these relations is obtained if we partition the undesignated vertices into two groups <em>A</em> and <em>B</em>, with <em>m</em> vertices in <em>A</em> and <em>n</em> − <em>q</em> − <em>m</em> vertices in <em>B</em>; then the <em>q</em> designated vertices are partitioned into <em>k</em> vertices that begin paths leading into <em>A</em>, and <em>q − k</em> vertices that begin paths leading into <em>B</em>. Relation (<a href="../Text/ch02b.html#ch02eq-lev3sec4-19">19</a>) is obtained by considering oriented trees in which the root has degree <em>k</em>.</p>

  <p class="indent">The form of these relations indicates that we can work profitably with the generating function</p>

  <div class="image"><img src="../Images/ch02/e391_01.jpg"></div>

  <p class="noindent">In these terms Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-18">18</a>) says that <em>G</em><sub><em>n</em>−<em>q</em></sub> (<em>z</em>) = <em>G</em><sub><em>m</em></sub>(<em>z</em>)<em>G</em><sub><em>n</em>−<em>q</em>−<em>m</em></sub> (<em>z</em>), and therefore by induction on <em>m</em>, we find that <em>G</em><sub><em>m</em></sub> (<em>z</em>) = <em>G</em><sub>1</sub> (<em>z</em>)<sup><em>m</em></sup>. Now from Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-19">19</a>), we obtain</p>

  <div class="image"><img src="../Images/ch02/e391_02.jpg"></div>

  <p class="indent"><a id="page_392"></a>In other words, putting <em>G</em><sub>1</sub> (<em>z</em>) = <em>w</em>, the solution to our problem comes from the coefficients of the solution to the transcendental equation</p>

  <div class="equation"><a id="ch02eq-lev3sec4-20"></a><img src="../Images/ch02/392equ01.jpg"></div>

  <p class="indent">This equation can be solved with the use of Lagrange’s inversion formula: z = ζ/<em>f</em> (ζ) implies that</p>

  <div class="equation"><a id="ch02eq-lev3sec4-21"></a><img src="../Images/ch02/392equ02.jpg"></div>

  <p class="noindent">where <em>g</em><sub><em>n</em></sub> (ζ) = <em>f</em> (ζ) <sup><em>n</em></sup>, when <em>f</em> is analytic in the neighborhood of the origin, and <em>f</em> (0) ≠ 0 (see exercise 4.7–16). In this case, we may set ζ = <em>zw</em>, <em>f</em> (ζ) = <em>e</em><sup>ζ</sup>, and we deduce the solution</p>

  <div class="equation"><a id="ch02eq-lev3sec4-22"></a><img src="../Images/ch02/392equ03.jpg"></div>

  <p class="noindent">in agreement with the answer obtained above.</p>

  <p class="indent">G. N. Raney has shown that we can extend this method in an important way to obtain an explicit power series for the solution to the considerably more general equation</p>

  <p class="center"><em>w</em> = <em>y</em><sub>1</sub><em>e</em><sup><em>z</em>1<em>w</em></sup> + <em>y</em><sub>2</sub><em>e</em><sup><em>z</em> 2 <em>w</em></sup> + · · · + <em>y</em><sub><em>s</em></sub>e<sup><em>z</em>a<em>w</em></sup>,</p>

  <p class="noindent">solving for <em>w</em> in terms of a power series in <em>y</em><sub>1</sub>, ..., <em>y</em><sub><em>s</em></sub> and <em>z</em><sub>1</sub>, ..., <em>z</em><sub><em>s</em></sub> . For this generalization, let us consider <em>s</em>-dimensional vectors of integers</p>

  <p class="center"><strong>n</strong> = (<em>n</em><sub>1</sub>, <em>n</em><sub>2</sub>, ..., <em>n</em><sub><em>s</em></sub>),</p>

  <p class="noindent">and let us write for convenience</p>

  <p class="center">∑<strong>n</strong> = <em>n</em><sub>1</sub> + <em>n</em><sub>2</sub> + · · · + <em>n</em><sub>s</sub> .</p>

  <p class="indent">Suppose that we have <em>s</em> colors <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, ..., <em>C</em><sub><em>s</em></sub>, and consider directed graphs in which each vertex is assigned a color; for example,</p>

  <div class="equation"><a id="ch02eq-lev3sec4-23"></a><img src="../Images/ch02/392equ04.jpg"></div>

  <p class="noindent">Let <em>r</em>(<strong>n</strong><em>,</em> <strong>q</strong>) be the number of ways to draw arcs and to assign colors to the vertices {1<em>,</em> 2<em>, ..., n</em>}, such that</p>

  <p class="indenti">i) for 1 ≤ <em>i</em> ≤ <em>s</em> there are exactly <em>n</em><sub>i</sub> vertices of color <em>C</em><sub><em>i</em></sub> (hence <em>n</em> = ∑<strong>n</strong>);</p>

  <p class="indenti">ii) there are <em>q</em> arcs, one leading from each of the vertices {1<em>,</em> 2<em>, ..., q</em>};</p>

  <p class="indenti">iii) for 1 ≤ <em>i</em> ≤ <em>s</em> there are exactly <em>q</em><sub><em>i</em></sub> arcs leading to vertices of color <em>C</em><sub><em>i</em></sub> (hence <em>q</em> = ∑<strong>q</strong>);</p>

  <p class="indenti">iv) there are no oriented cycles (hence <em>q</em> &lt; <em>n</em>, unless <em>q</em> = <em>n</em> = 0).</p>

  <p class="noindent">Let us call this an (<strong>n</strong>,<strong>q</strong>)-construction.</p>

  <p class="indent"><a id="page_393"></a>For example, if <em>C</em><sub>1</sub> = red, <em>C</em><sub>2</sub> = yellow, and <em>C</em><sub>3</sub> = blue, then (<a href="../Text/ch02b.html#ch02eq-lev3sec4-23">23</a>) shows a ((3, 2, 2), (1, 2, 2))-construction. When there is only one color, we have the oriented tree problem that we have already solved. Raney’s idea is to generalize the one-dimension construction to <em>s</em> dimensions.</p>

  <p class="indent">Let <strong>n</strong> and <strong>q</strong> be fixed <em>s</em>-place vectors of nonnegative integers, and let <em>n</em> = ∑<strong>n</strong>, <em>q</em> = ∑<strong>q</strong>. For each (<strong>n</strong>,<strong>q</strong>)-construction and each number <em>k</em>, 1 ≤ <em>k</em> ≤ <em>n</em>, we will define a <em>canonical representation</em> consisting of four things:</p>

  <p class="indenthangingA">a) a number <em>t</em>, with <em>q</em> &lt; <em>t</em> ≤ <em>n</em>;</p>

  <p class="indenthangingA">b) a sequence of <em>n</em> colors, with <em>n</em><sub><em>i</em></sub> of color <em>C</em><sub><em>i</em></sub>;</p>

  <p class="indenthangingA">c) a sequence of <em>q</em> colors, with <em>q</em><sub><em>i</em></sub> of color <em>C</em><sub><em>i</em></sub>;</p>

  <p class="indenthangingA">d) for 1 ≤ <em>i</em> ≤ <em>s</em>, <em>a</em> sequence of <em>q</em><sub><em>i</em></sub> elements of the set {1, 2, ..., <em>n</em><sub><em>i</em></sub>}.</p>

  <p class="noindent">The canonical representation is defined thus: First list the vertices {1, 2, ..., <em>q</em>} in the order <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ..., <em>V</em><sub><em>q</em></sub> of the canonical representation of oriented trees (as given above), and then write below vertex <em>V</em><sub><em>j</em></sub> the number <em>f</em> (<em>V</em><sub>j</sub>) of the vertex on the arc leading from <em>V</em><sub><em>j</em></sub> . Let <em>t</em> = <em>f</em> (<em>V</em><sub>q</sub>); and let the sequence (c) of colors be the respective colors of the vertices <em>f</em> (<em>V</em><sub>1</sub>) <em>, ..., f</em> (<em>V</em><sub>q</sub>). Let the sequence (b) of colors be the respective colors of the vertices <em>k</em>, <em>k</em> + 1, ..., <em>n</em>, 1, ..., <em>k</em> − 1. Finally, let the <em>i</em>th sequence in (d) be <em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ..., <em>x</em><sub><em>iq</em></sub><sub>i</sub>, where <em>x</em><sub><em>ij</em></sub> = <em>m</em> if the <em>j</em> th <em>C</em><sub><em>i</em></sub>-colored element of the sequence <em>f</em> (<em>V</em><sub>1</sub>)<em>, ..., f</em> (<em>V</em><sub>q</sub>) is the <em>m</em>th <em>C</em><sub>i</sub>-colored element of the sequence <em>k</em>, <em>k</em> + 1, ..., <em>n</em>, 1, ..., <em>k</em> − 1.</p>

  <p class="indent">For example, consider construction (<a href="../Text/ch02b.html#ch02eq-lev3sec4-23">23</a>) and let <em>k</em> = 3. We start by listing <em>V</em><sub>1</sub>, ..., <em>V</em><sub>5</sub> and <em>f</em> (<em>V</em><sub>1</sub>), ..., <em>f</em> (<em>V</em><sub>5</sub>) below them as follows:</p>

  <p class="center">1&nbsp;&nbsp;2&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;3<br>
  7&nbsp;&nbsp;6&nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;6</p>

  <p class="noindent">Hence <em>t</em> = 6, and sequence (c) represents the respective colors of 7, 6, 3, 3, 6, namely red, yellow, blue, blue, yellow. Sequence (b) represents the respective colors of 3, 4, 5, 6, 7, 1, 2, namely blue, yellow, red, yellow, red, blue, red. Finally, to get the sequences in (d), proceed as follows:</p>

  <div class="image"><img src="../Images/ch02/e393_02.jpg"></div>

  <p class="noindent">Hence the (d) sequences are 2; 2<em>,</em> 2; and 1<em>,</em> 1.</p>

  <p class="indent">From the canonical representation, we can recover both the original (<strong>n</strong>,<strong>q</strong>)-construction and the number <em>k</em> as follows: From (a) and (c) we know the color of vertex <em>t</em>. The last element of the (d) sequence for this color tells us, in conjunction with (b), the position of <em>t</em> in the sequence <em>k, ..., n,</em> 1<em>, ..., k</em> − 1; hence we know <em>k</em> and the colors of all vertices. Then the subsequences in (d) together with (b) and (c) determine <em>f</em> (<em>V</em><sub>1</sub>), <em>f</em> (<em>V</em><sub>2</sub>), ..., <em>f</em> (V<sub><em>q</em></sub>), and finally the directed graph is reconstructed by locating <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>q</em></sub> as we did for oriented trees.</p>

  <p class="indent"><a id="page_394"></a>The reversibility of this canonical representation allows us to count the number of possible (<strong>n</strong>,<strong>q</strong>)-constructions, since there are <em>n</em> − <em>q</em> choices for (a), and the multinomial coefficient</p>

  <div class="image"><img src="../Images/ch02/e394_01.jpg"></div>

  <p class="noindent">choices for (b), and</p>

  <div class="image"><img src="../Images/ch02/e394_02.jpg"></div>

  <p class="noindent">choices for (c), and <span class="middle"><img src="../Images/ch02/e394_03.jpg"></span> choices for (d). Dividing by the n choices for <em>k</em>, we have the general result</p>

  <div class="equation"><a id="ch02eq-lev3sec4-24"></a><img src="../Images/ch02/394equ01.jpg"></div>

  <p class="indent">Furthermore, we can derive analogs of Eqs. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-18">18</a>) and (<a href="../Text/ch02b.html#ch02eq-lev3sec4-19">19</a>):</p>

  <div class="equation"><a id="ch02eq-lev3sec4-25"></a><img src="../Images/ch02/394equ02.jpg"></div>

  <p class="noindent">with the convention that <em>r</em>(<strong>0</strong><em>,</em> <strong>0</strong>) = 1, and <em>r</em>(<strong>n</strong><em>,</em> <strong>q</strong>) = 0 if any <em>n</em><sub><em>i</em></sub> or <em>q<sub>i</sub></em> is negative or if <em>q</em> &gt; <em>n</em>;</p>

  <div class="equation"><a id="ch02eq-lev3sec4-26"></a><img src="../Images/ch02/394equ03.jpg"></div>

  <p class="noindent">where <strong>e</strong><sub><em>i</em></sub> is the vector with 1 in position <em>i</em> and zeros elsewhere. Relation (<a href="../Text/ch02b.html#ch02eq-lev3sec4-25">25</a>) is based on breaking the vertices {<em>q</em> + 1<em>, ..., n</em>} into two parts having <em>m</em> and <em>n</em> − <em>q</em> − <em>m</em> elements, respectively; the second relation is derived by removing the unique root and considering the remaining structure. We now obtain the following result:</p>

  <p class="noindent"><strong>Theorem R.</strong> [George N. Raney, <em>Canadian J. Math.</em> 16 (1964), 755–762.] <em>Let</em></p>

  <div class="equation"><a id="ch02eq-lev3sec4-27"></a><img src="../Images/ch02/394equ04.jpg"></div>

  <p class="noindent"><em>where r</em>(<strong>n</strong>, <strong>q</strong>) <em>is defined by</em> (<a href="../Text/ch02b.html#ch02eq-lev3sec4-24">24</a>), <em>and where</em> <strong>n</strong>, <strong>q</strong> <em>are s-dimensional integer vectors. Then w satisfies the identity</em></p>

  <div class="equation"><a id="ch02eq-lev3sec4-28"></a><img src="../Images/ch02/394equ05.jpg"></div>

  <p class="noindent"><em>Proof.</em> By (<a href="../Text/ch02b.html#ch02eq-lev3sec4-25">25</a>) and induction on <em>m</em>, we find that</p>

  <div class="equation"><a id="ch02eq-lev3sec4-29"></a><img src="../Images/ch02/394equ06.jpg"></div>

  <p class="noindent"><a id="page_395"></a>Now by (<a href="../Text/ch02b.html#ch02eq-lev3sec4-26">26</a>),</p>

  <div class="image"><img src="../Images/ch02/e395_01.jpg"></div>

  <p class="indent">The special case where <em>s</em> = 1 and <em>z</em><sub>1</sub> = 1 in (<a href="../Text/ch02b.html#ch02eq-lev3sec4-27">27</a>) and (<a href="../Text/ch02b.html#ch02eq-lev3sec4-28">28</a>) is especially important in applications, so it has become known as the “tree function”</p>

  <div class="equation"><a id="ch02eq-lev3sec4-30"></a><img src="../Images/ch02/395equ01.jpg"></div>

  <p class="noindent">See Corless, Gonnet, Hare, Jeffrey, and Knuth, <em>Advances in Computational Math</em>. <strong>5</strong> (1996), 329–359, for a discussion of this function’s history and some of its remarkable properties.</p>

  <p class="indent">A survey of enumeration formulas for trees, based on skillful manipulations of generating functions, has been given by I. J. Good [<em>Proc. Cambridge Philos. Soc.</em> <strong>61</strong> (1965), 499–517; <strong>64</strong> (1968), 489]. More recently, a mathematical <em>theory of species</em> developed by André Joyal [<em>Advances in Math.</em> <strong>42</strong> (1981), 1–82] has led to a high-level viewpoint in which algebraic operations on generating functions correspond directly to combinatorial properties of structures. The book <em>Combinatorial Species and Tree-like Structures</em> by F. Bergeron, G. Labelle, and P. Leroux (Cambridge Univ. Press, 1998), presents numerous examples of this beautiful and instructive theory, generalizing many of the formulas derived above.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_4_1a" id="ch02ex_3_4_1">1</a>.</strong> [<em>M20</em>] (G. Pólya.) Show that</p>

  <div class="image"><img src="../Images/ch02/e395_02.jpg"></div>

  <p class="exercisesp">[<em>Hint:</em> Take logarithms of (<a href="../Text/ch02b.html#ch02eq-lev3sec4-3">3</a>).]</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_4_2a" id="ch02ex_3_4_2">2</a>.</strong> [<em>HM24</em>] (R. Otter.) Show that the numbers <em>a</em><sub>n</sub> satisfy the following condition:</p>

  <p class="center"><em>na</em><sub>n+1</sub> = <em>a</em><sub>1</sub><em>s</em><sub>n1</sub> + 2<em>a</em><sub>2</sub> s<sub>n2</sub> + · · · + <em>na</em><sub><em>n</em></sub><em>s</em><sub><em>nn</em></sub>,</p>

  <p class="exercisesp">where</p>

  <div class="image"><img src="../Images/ch02/e395_03.jpg"></div>

  <p class="exercisesp">(These formulas are useful for the calculation of the <em>a<sub>n</sub></em>, since <em>s<sub>nk</sub></em> = <em>s</em><sub>(<em>n−k</em>)<em>k</em></sub> + <em>a</em><sub><em>n</em>+1−<em>k</em></sub>.)</p>

  <p class="exercises"><a id="page_396"></a><strong><a id="ch02ex_3_4_3"></a>3.</strong> [<em>M40</em>] Write a computer program that determines the number of (unlabeled) free trees and of oriented trees with <em>n</em> vertices, for <em>n</em> ≤ 100. (Use the result of <a href="../Text/ch02b.html#ch02ex_3_4_2">exercise 2</a>.) Explore arithmetical properties of these numbers; can anything be said about their prime factors, or their residues modulo <em>p</em>?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_4a" id="ch02ex_3_4_4">4</a>.</strong> [<em>HM39</em>] (G. Pólya, 1937.) Using complex variable theory, determine the asymptotic value of the number of oriented trees as follows:</p>

  <p class="indenthangingA">a) Show that there is a real number α between 0 and 1 for which <em>A</em>(<em>z</em>) has radius of convergence α and <em>A</em>(<em>z</em>) converges absolutely for all complex <em>z</em> such that |z| ≤ α, having maximum value A(α) = a &lt; ∞. [<em>Hint:</em> When a power series has nonnegative coefficients, it either is entire or has a positive real singularity; and show that <em>A</em>(<em>z</em>)<em>/z</em> is bounded as <em>z</em> → α−, by using the identity in <a href="../Text/ch02b.html#ch02ex_3_4_1">exercise 1</a>.]</p>

  <p class="indenthangingA">b) Let</p>

  <div class="image"><img src="../Images/ch02/e396_01.jpg"></div>

  <p class="indenthangingAP">Show that in a neighborhood of (<em>z, w</em>) = (<em>α, a/</em>α), <em>F</em> (<em>z, w</em>) is analytic in each variable separately.</p>

  <p class="indenthangingA">c) Show that at the point (<em>z, w</em>) = (<em>α, a/</em>α), we have <em>∂F/∂w</em> = 0; hence <em>a</em> = 1.</p>

  <p class="indenthangingA">d) At the point (<em>z, w</em>) = (<em>α,</em> 1<em>/</em>α) show that</p>

  <div class="image"><img src="../Images/ch02/e396_02.jpg"></div>

  <p class="indenthangingA">e) When |<em>z</em>| = <em>α</em> and <em>z</em> <em>≠ α</em>, show that <em>∂F/∂w</em> <em>≠</em> 0; hence <em>A</em>(<em>z</em>) has only one singularity on |<em>z</em>| = <em>α</em>.</p>

  <p class="indenthangingA">f) Prove that there is a region larger than |<em>z</em>| &lt; <em>α</em> in which</p>

  <div class="image"><img src="../Images/ch02/e396_03.jpg"></div>

  <p class="indenthangingAP">where <em>R</em>(<em>z</em>) is an analytic function of <span class="middle"><img src="../Images/ch02/e396_04.jpg"></span>.</p>

  <p class="indenthangingA">g) Prove that consequently</p>

  <div class="image"><img src="../Images/ch02/e396_05.jpg"></div>

  <p class="indenthangingAP">[<em>Note:</em> 1<em>/α</em> ≈ 2.955765285652, and <span class="middle"><img src="../Images/ch02/e396_06.jpg"></span>.]</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_5a" id="ch02ex_3_4_5">5</a>.</strong> [<em>M25</em>] (A. Cayley.) Let <em>c</em><sub><em>n</em></sub> be the number of (unlabeled) oriented trees having <em>n</em> leaves (namely, vertices with in-degree zero) and having at least two subtrees at every other vertex. Thus c<sub>3</sub> = 2, by virtue of the two trees</p>

  <div class="image"><img src="../Images/ch02/e396_07.jpg"></div>

  <p class="exercisesp">Find a formula analogous to (<a href="../Text/ch02b.html#ch02eq-lev3sec4-3">3</a>) for the generating function</p>

  <div class="image"><img src="../Images/ch02/e396_08.jpg"></div>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_4_6a" id="ch02ex_3_4_6">6</a>.</strong> [<em>M25</em>] Let an “oriented binary tree” be an oriented tree in which each vertex has in-degree two or less. Find a reasonably simple relation that defines the generating function <em>G</em>(<em>z</em>) for the number of distinct oriented binary trees with <em>n</em> vertices, and find the first few values.</p>

  <p class="exercises"><a id="page_397"></a><strong><a href="../Text/app01b.html#ch02ex_3_4_7a" id="ch02ex_3_4_7">7</a>.</strong> [<em>HM40</em>] Obtain asymptotic values for the numbers of <a href="../Text/ch02b.html#ch02ex_3_4_6">exercise 6</a>. (See <a href="../Text/ch02b.html#ch02ex_3_4_4">exercise 4</a>.)</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_4_8a" id="ch02ex_3_4_8">8</a>.</strong> [<em>20</em>] According to Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-9">9</a>), there are six free trees with six vertices. Draw them, and indicate their centroids.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_4_9a" id="ch02ex_3_4_9">9</a>.</strong> [<em>M20</em>] From the fact that at most one subtree of a vertex in a free tree can contain a centroid, prove that there are at most two centroids in a free tree; furthermore if there are two, then they must be adjacent.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_10a" id="ch02ex_3_4_10">10</a>.</strong> [<em>M22</em>] Prove that a free tree with <em>n</em> vertices and two centroids consists of two free trees with <em>n/</em>2 vertices, joined by an edge. Conversely, if two free trees with <em>m</em> vertices are joined by an edge, we obtain a free tree with 2<em>m</em> vertices and two centroids.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_11a" id="ch02ex_3_4_11">11</a>.</strong> [<em>M28</em>] The text derives the number of different binary trees with <em>n</em> nodes (<a href="../Text/ch02b.html#ch02eq-lev3sec4-14">14</a>). Generalize this to find the number of different <em>t</em>-ary trees with <em>n</em> nodes. (See <a href="../Text/ch02a.html#ch02lev2sec7">exercise 2.3.1</a>–<a href="../Text/ch02a.html#ch02ex_2_7_35">35</a>; a <em>t</em>-ary tree is either empty or consists of a root and <em>t</em> disjoint <em>t</em>-ary trees.) <em>Hint:</em> Use Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-21">21</a>) of <a href="../Text/ch01a.html#ch01lev2sec9">Section 1.2.9</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_12a" id="ch02ex_3_4_12">12</a>.</strong> [<em>M20</em>] Find the number of labeled oriented trees with <em>n</em> vertices by using determinants and the result of <a href="../Text/ch02b.html#ch02lev3sec2">exercise 2.3.4.2</a>–<a href="../Text/ch02b.html#ch02ex_3_2_19">19</a>. (See also <a href="../Text/ch01.html#ch01lev2sec3">exercise 1.2.3</a>–<a href="../Text/ch01.html#ch01ex_2_3_36">36</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_13a" id="ch02ex_3_4_13">13</a>.</strong> [<em>15</em>] What oriented tree on the vertices {1<em>,</em> 2<em>, ...,</em> 10} has the canonical representation 3, 1, 4, 1, 5, 9, 2, 6, 5?</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_14a" id="ch02ex_3_4_14">14</a>.</strong> [<em>10</em>] True or false: The last entry, <em>f</em> (<em>V</em><sub>n−1</sub>), in the canonical representation of an oriented tree is always the root of that tree.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_15a" id="ch02ex_3_4_15">15</a>.</strong> [<em>21</em>] Discuss the relationships that exist (if any) between the topological sort algorithm of <a href="../Text/ch02.html#ch02lev2sec3">Section 2.2.3</a> and the canonical representation of an oriented tree.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_16a" id="ch02ex_3_4_16">16</a>.</strong> [<em>25</em>] Design an algorithm (as efficient as possible) that converts from the canonical representation of an oriented tree to a conventional computer representation using <code>PARENT</code> links.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_17a" id="ch02ex_3_4_17">17</a>.</strong> [<em>M26</em>] Let <em>f</em> (<em>x</em>) be an integer-valued function, where 1 ≤ <em>f</em> (<em>x</em>) ≤ <em>m</em> for all integers 1 ≤ <em>x</em> ≤ <em>m</em>. Define <em>x</em> ≡ <em>y</em> if <em>f</em> <sup>[r]</sup> (<em>x</em>) = f <sup>[s]</sup> (y) for some <em>r, s</em> ≥ 0, where <em>f</em> <sup>[0]</sup> (<em>x</em>) = <em>x</em> and <em>f</em> <sup>[r+1]</sup> (x) = f (f <sup>[r]</sup> (x)). By using methods of enumeration like those in this section, show that the number of functions such that <em>x</em> ≡ <em>y</em> for all x and y is <em>m</em><sup><em>m</em>−1</sup><em>Q(m)</em>, where <em>Q</em>(<em>m</em>) is the function defined in <a href="../Text/ch01b.html#ch01lev3sec3">Section 1.2.11.3</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_18a" id="ch02ex_3_4_18">18</a>.</strong> [<em>24</em>] Show that the following method is another way to define a one-to-one correspondence between (<em>n</em> − 1)-tuples of numbers from 1 to <em>n</em> and oriented trees with <em>n</em> labeled vertices: Let the leaves of the tree be <em>V</em><sub>1</sub>, ..., <em>V</em><sub><em>k</em></sub> in ascending order. Let (<em>V</em><sub>1</sub>, <em>V</em><sub>k+1</sub>, <em>V</em><sub>k+2</sub>, ..., <em>V</em><sub>q</sub>) be the path from <em>V</em><sub>1</sub> to the root, and write down the vertices <em>V</em><sub><em>q</em></sub>, ..., <em>V</em><sub>k+2</sub>, <em>V</em><sub>k+1</sub> . Then let (<em>V</em><sub>2</sub>, <em>V</em><sub>q+1</sub>, <em>V</em><sub>q+2</sub>, ..., <em>V</em><sub><em>r</em></sub>) be the shortest oriented path from <em>V</em><sub>2</sub> such that <em>V</em><sub><em>r</em></sub> has already been written down, and write down <em>V</em><sub>r</sub>, ..., V<sub>q+2</sub>, V<sub>q+1</sub> . Then let (V<sub>3</sub>, V<sub>r+1</sub>, ..., V<sub>s</sub>) be the shortest oriented path from <em>V</em><sub>3</sub> such that <em>V</em><sub>s</sub> has already been written, and write <em>V</em><sub>s</sub>, ..., <em>V</em><sub>r+1</sub>; and so on. For example, the tree (<a href="../Text/ch02b.html#ch02eq-lev3sec4-17">17</a>) would be encoded as 3, 1, 3, 3, 5, 10, 5, 10, 1. Show that this process is reversible, and in particular, draw the oriented tree with vertices {1, 2, ..., 10} and representation 3, 1, 4, 1, 5, 9, 2, 6, 5.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_19a" id="ch02ex_3_4_19">19</a>.</strong> [<em>M24</em>] How many different labeled, oriented trees are there having <em>n</em> vertices, <em>k</em> of which are leaves (have in-degree zero)?</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_20a" id="ch02ex_3_4_20">20</a>.</strong> [<em>M24</em>] (J. Riordan.) How many different labeled, oriented trees are there having <em>n</em> vertices, <em>k</em><sub>0</sub> of which have in-degree 0, <em>k</em><sub>1</sub> have in-degree 1, <em>k</em><sub>2</sub> have in-degree 2, ... ? (Note that necessarily <em>k</em><sub>0</sub> + <em>k</em><sub>1</sub> + <em>k</em><sub>2</sub> + · · · = <em>n</em>, and <em>k</em><sub>1</sub> + 2<em>k</em><sub>2</sub> + 3<em>k</em><sub>3</sub> + · · · = <em>n</em> − 1.)</p>

  <p class="exercises3"><a id="page_398"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_21a" id="ch02ex_3_4_21">21</a>.</strong> [<em>M21</em>] Enumerate the number of labeled oriented trees in which each vertex has in-degree zero or two. (See <a href="../Text/ch02b.html#ch02ex_3_4_20">exercise 20</a> and <a href="../Text/ch02a.html#ch02lev1sec3">exercise 2.3</a>–<a href="../Text/ch02a.html#ch02ex_1_3_20">20</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_22a" id="ch02ex_3_4_22">22</a>.</strong> [<em>M20</em>] How many <em>labeled</em> free trees are possible with <em>n</em> vertices? (In other words, if we are given <em>n</em> vertices, there are <span class="middle"><img src="../Images/ch02/e398_01.jpg"></span> possible graphs having these vertices, depending on which of the <span class="middle"><img src="../Images/ch02/e398_02.jpg"></span> possible edges are incorporated into the graph; how many of these graphs are free trees?)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_23a" id="ch02ex_3_4_23">23</a>.</strong> [<em>M21</em>] How many ordered trees are possible with <em>n</em> labeled vertices? (Give a simple formula involving factorials.)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_24a" id="ch02ex_3_4_24">24</a>.</strong> [<em>M16</em>] All labeled oriented trees with vertices 1, 2, 3, 4 and with root 1 are shown in (<a href="../Text/ch02b.html#ch02eq-lev3sec4-15">15</a>). How many would there be if we listed all labeled <em>ordered</em> trees with these vertices and this root?</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_25a" id="ch02ex_3_4_25">25</a>.</strong> [<em>M20</em>] What is the value of the quantity <em>r</em>(<em>n, q</em>) that appears in Eqs. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-18">18</a>) and (<a href="../Text/ch02b.html#ch02eq-lev3sec4-19">19</a>)? (Give an explicit formula; the text only mentions that <em>r</em>(<em>n, n</em> − 1) = <em>n</em><sup><em>n</em>−2</sup> .)</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_26a" id="ch02ex_3_4_26">26</a>.</strong> [<em>20</em>] In terms of the notation at the end of this section, draw the ((3<em>,</em> 2<em>,</em> 4)<em>,</em> (1<em>,</em> 4<em>,</em> 2))-construction, analogous to (<a href="../Text/ch02b.html#ch02eq-lev3sec4-23">23</a>), and find the number <em>k</em> that corresponds to the canonical representation having <em>t</em> = 8, the sequences of colors “red, yellow, blue, red, yellow, blue, red, blue, blue” and “red, yellow, blue, yellow, yellow, blue, yellow”, and the index sequences 3; 1, 2, 2, 1; 2, 4.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_27a" id="ch02ex_3_4_27">27</a>.</strong> [<em>M28</em>] Let <em>U</em><sub>1</sub>, <em>U</em><sub>2</sub>, ..., <em>U</em><sub><em>p</em></sub>, ..., <em>U</em><sub><em>q</em></sub>; <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ..., <em>V</em><sub><em>r</em></sub> be vertices of a directed graph, where 1 ≤ p ≤ q. Let <em>f</em> be any function from the set {<em>p</em> + 1, ..., <em>q</em>} into the set {1, 2, ..., <em>r</em>}, and let the directed graph contain exactly <em>q</em> − <em>p</em> arcs, from <em>U</em><sub><em>k</em></sub> to <em>V</em><sub><em>f</em> (<em>k</em>)</sub> for <em>p</em> &lt; <em>k</em> ≤ <em>q</em>. Show that the number of ways to add r additional arcs, one from each of the <em>V</em>’s to one of the <em>U</em>’s, such that the resulting directed graph contains no oriented cycles, is <em>q</em><sup><em>r</em>−1</sup><em>p</em>. Prove this by generalizing the canonical representation method; that is, set up a one-to-one correspondence between all such ways of adding <em>r</em> further arcs and the set of all sequences of integers <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ..., <em>a</em><sub><em>r</em></sub>, where 1 ≤ <em>a</em><sub><em>k</em></sub> ≤ <em>q</em> for 1 ≤ <em>k</em> &lt; <em>r</em>, and 1 ≤ <em>a</em><sub><em>r</em></sub> ≤ <em>p</em>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_28a" id="ch02ex_3_4_28">28</a>.</strong> [<em>M22</em>] (<em>Bipartite trees.</em>) Use the result of <a href="../Text/ch02b.html#ch02ex_3_4_27">exercise 27</a> to enumerate the number of labeled free trees on vertices <em>U</em><sub>1</sub>, ..., <em>U</em><sub><em>m</em></sub>, <em>V</em><sub>1</sub>, ..., <em>V</em><sub>n</sub>, such that each edge joins <em>U</em><sub><em>j</em></sub> to <em>V</em><sub><em>k</em></sub> for some <em>j</em> and <em>k</em>.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_29a" id="ch02ex_3_4_29">29</a>.</strong> [<em>HM26</em>] Prove that if <em>E</em><sub>k</sub> (<em>r, t</em>) = <em>r</em> (<em>r</em> + <em>kt</em>)<sup>k−1</sup><em>/k</em>!, and if <em>zx</em><sup>t</sup> = ln <em>x</em>, then</p>

  <div class="image"><img src="../Images/ch02/e398_03.jpg"></div>

  <p class="exercisesp">for fixed <em>t</em> and for sufficiently small |<em>z</em>| and |<em>x</em> − 1|. [Use the fact that <em>G</em><sub><em>m</em></sub> (<em>z</em>) = <em>G</em><sub>1</sub> (<em>z</em>)<sup>m</sup> in the discussion following Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-19">19</a>).] In this formula, <em>r</em> stands for an arbitrary real number. [<em>Note:</em> As a consequence of this formula we have the identity</p>

  <div class="image"><img src="../Images/ch02/e398_04.jpg"></div>

  <p class="exercisesp">this implies Abel’s binomial theorem, Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-16">16</a>) of <a href="../Text/ch01a.html#ch01lev2sec6">Section 1.2.6</a>. Compare also Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-30">30</a>) of that section.]</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_30a" id="ch02ex_3_4_30">30</a>.</strong> [<em>M23</em>] Let <em>n, x, y, z</em><sub>1</sub>, ..., <em>z</em><sub><em>n</em></sub> be positive integers. Consider a set of <em>x</em> + <em>y</em> + <em>z</em><sub>1</sub> + · · · + <em>z</em><sub>n</sub> + <em>n</em> vertices <em>r</em><sub><em>i</em></sub>, <em>s</em><sub><em>jk</em></sub>, <em>t</em><sub><em>j</em></sub> (1 ≤ <em>i</em> ≤ <em>x</em> + <em>y</em>, 1 ≤ <em>j</em> ≤ <em>n</em>, 1 ≤ <em>k</em> ≤ <em>z</em><sub>j</sub>), in which arcs have been drawn from <em>s</em><sub><em>jk</em></sub> to <em>t</em><sub><em>j</em></sub> for all <em>j</em> and <em>k</em>. According to <a href="../Text/ch02b.html#ch02ex_3_4_27">exercise 27</a>, there are (<em>x</em> + <em>y</em>)(<em>x</em> + <em>y</em> + <em>z</em><sub>1</sub> + · · · + <em>z</em><sub>n</sub>) <sup><em>n</em>−1</sup> ways to draw one arc from each of <em>t</em><sub>1</sub><em>, ..., t</em><sub>n</sub> to other <a id="page_399"></a>vertices such that the resulting directed graph contains no oriented cycles. Use this fact to prove Hurwitz’s generalization of the binomial theorem:</p>

  <div class="image"><img src="../Images/ch02/e399_01.jpg"></div>

  <p class="exercisesp">where the sum is over all 2<sup><em>n</em></sup> choices of <span class="ent">∊</span><sub>1</sub><em>, ...,</em> <span class="ent">∊</span><sub>n</sub> equal to 0 or 1.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_31a" id="ch02ex_3_4_31">31</a>.</strong> [<em>M24</em>] Solve <a href="../Text/ch02b.html#ch02ex_3_4_5">exercise 5</a> for ordered trees; that is, derive the generating function for the number of unlabeled ordered trees with <em>n</em> terminal nodes and no nodes of degree 1.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_4_32a" id="ch02ex_3_4_32">32</a>.</strong> [<em>M37</em>] (A. Erdélyi and I. M. H. Etherington, <em>Edinburgh Math. Notes</em> <strong>32</strong> (1941), 7–12.) How many (ordered, unlabeled) trees are there with <em>n</em><sub>0</sub> nodes of degree 0, <em>n</em><sub>1</sub> of degree 1, ..., <em>n</em><sub><em>m</em></sub> of degree <em>m</em>, and none of degree higher than <em>m</em>? (An explicit solution to this problem can be given in terms of factorials, thereby considerably generalizing the result of <a href="../Text/ch02b.html#ch02ex_3_4_11">exercise 11</a>.)</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_4_33a" id="ch02ex_3_4_33">33</a>.</strong> [<em>M28</em>] The text gives an explicit power series solution for the equation <em>w</em> = <em>y</em><sub>1</sub> e<sup>z<sub>1</sub>w</sup> + · · · + <em>yr e</em><sup>z<sub>r</sub> w</sup>, based on enumeration formulas for certain oriented forests. Similarly, show that the enumeration formula of <a href="../Text/ch02b.html#ch02ex_3_4_32">exercise 32</a> leads to an explicit power series solution to the equation</p>

  <p class="center"><em>w</em> = <em>z</em><sub>1</sub><em>w</em><sup><em>e</em><sub>1</sub></sup> + <em>z</em><sub>2</sub><em>w</em><sup><em>e</em><sub>2</sub></sup> + · · · + <em>z</em><sub><em>r</em></sub><em>w</em><sup><em>e</em><sub><em>r</em></sub></sup>,</p>

  <p class="noindent">expressing <em>w</em> as a power series in <em>z</em><sub>1</sub>, ..., <em>z</em><sub><em>r</em></sub>. (Here <em>e</em><sub>1</sub>, ..., <em>e</em><sub><em>r</em></sub> are fixed nonnegative integers, at least one of which is zero.)</p>

  <div class="heading">
    <h5 id="ch02lev3sec5">2.3.4.5. Path length</h5>

    <p class="noindent">The concept of the “path length” of a tree is of great importance in the analysis of algorithms, since this quantity is often directly related to the execution time. Our primary concern is with binary trees, since they are so close to actual computer representations.</p>
  </div>

  <p class="indent">In the following discussion we will extend each binary tree diagram by adding special nodes wherever a null subtree was present in the original tree, so that</p>

  <div class="equation"><a id="ch02eq-lev3sec5-1"></a><img src="../Images/ch02/399equ01.jpg"></div>

  <p class="noindent">The latter is called an <em>extended binary tree</em>. After the square-shaped nodes have been added in this way, the structure is sometimes more convenient to deal with, and we shall therefore meet extended binary trees frequently in later chapters. It is clear that every circular node has two children and every square node has none. (Compare with <a href="../Text/ch02a.html#ch02lev1sec3">exercise 2.3</a>–<a href="../Text/ch02a.html#ch02ex_1_3_20">20</a>.) If there are <em>n</em> circular nodes and <em>s</em> square nodes, we have <em>n</em> + <em>s</em> − 1 edges (since the diagram is a free tree); counting another <a id="page_400"></a>way, by the number of children, we see that there are 2<em>n</em> edges. Hence it is clear that</p>

  <div class="equation"><a id="ch02eq-lev3sec5-2"></a><img src="../Images/ch02/400equ01.jpg"></div>

  <p class="noindent">in other words, the number of “external” nodes just added is one more than the number of “internal” nodes we had originally. (For another proof, see <a href="../Text/ch02a.html#ch02lev2sec7">exercise 2.3.1</a>–<a href="../Text/ch02a.html#ch02ex_2_7_14">14</a>.) Formula (<a href="../Text/ch02b.html#ch02eq-lev3sec5-2">2</a>) is correct even when <em>n</em> = 0.</p>

  <p class="indent">Assume that a binary tree has been extended in this way. The <em>external path length of the tree</em>, <em>E</em>, is defined to be the sum — taken over all external (square) nodes — of the lengths of the paths from the root to each node. The <em>internal path length</em>, <em>I</em>, is the same quantity summed over the internal (circular) nodes. In (<a href="../Text/ch02b.html#ch02eq-lev3sec5-1">1</a>) the external path length is</p>

  <p class="center"><em>E</em> = 3 + 3 + 2 + 3 + 4 + 4 + 3 + 3 = 25,</p>

  <p class="noindent">and the internal path length is</p>

  <p class="center"><em>I</em> = 2 + 1 + 0 + 2 + 3 + 1 + 2 = 11.</p>

  <p class="noindent">These two quantities are always related by the formula</p>

  <div class="equation"><a id="ch02eq-lev3sec5-3"></a><img src="../Images/ch02/400equ02.jpg"></div>

  <p class="noindent">where <em>n</em> is the number of internal nodes.</p>

  <p class="indent">To prove formula (<a href="../Text/ch02b.html#ch02eq-lev3sec5-3">3</a>), consider deleting an internal node <em>V</em> at a distance <em>k</em> from the root, where both children of <em>V</em> are external. The quantity <em>E</em> goes down by 2(<em>k</em> + 1), since the children of <em>V</em> are removed, then it goes up by <em>k</em>, since <em>V</em> becomes external; so the net change in <em>E</em> is −<em>k</em> − 2. The net change in <em>I</em> is −<em>k</em>, so (<a href="../Text/ch02b.html#ch02eq-lev3sec5-3">3</a>) follows by induction.</p>

  <p class="indent">It is not hard to see that the internal path length (and hence the external path length also) is greatest when we have a degenerate tree with linear structure; in that case the internal path length is</p>

  <div class="image"><img src="../Images/ch02/e400_01.jpg"></div>

  <p class="noindent">It can be shown that the “average” path length over all binary trees is essentially proportional to <span class="middle"><img src="../Images/ch02/e400_02.jpg"></span> (see <a href="../Text/ch02b.html#ch02ex_3_5_5">exercise 5</a>).</p>

  <p class="indent">Consider now the problem of constructing a binary tree with <em>n</em> nodes that has <em>minimum</em> path length. Such a tree will be important, since it will minimize the computation time for various algorithms. Clearly, only one node (the root) can be at zero distance from the root; at most two nodes can be at distance 1 from the root, at most four can be 2 away, and so on. Therefore <em>the internal path length is always at least as big as the sum of the first n terms of the series</em></p>

  <p class="center">0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, ... .</p>

  <p class="noindent">This is the sum <span class="middle"><img src="../Images/ch02/e400_03.jpg"></span>, which we know from <a href="../Text/ch01.html#ch01lev2sec4">exercise 1.2.4</a>–<a href="../Text/ch01.html#ch01ex_2_3_42">42</a> is</p>

  <div class="equation"><a id="ch02eq-lev3sec5-4"></a><img src="../Images/ch02/400equ03.jpg"></div>

  <p class="noindent"><a id="page_401"></a>The optimum value (<a href="../Text/ch02b.html#ch02eq-lev3sec5-4">4</a>) is <em>n</em> lg <em>n</em>+<em>O</em>(<em>n</em>), since <em>q</em> = lg <em>n</em>+<em>O</em>(1); it is clearly achieved in a tree that looks like this (illustrated for <em>n</em> = 12):</p>

  <div class="equation"><a id="ch02eq-lev3sec5-5"></a><img src="../Images/ch02/401equ01.jpg"></div>

  <p class="indent">A tree such as (<a href="../Text/ch02b.html#ch02eq-lev3sec5-5">5</a>) is called the <em>complete binary tree</em> with <em>n</em> internal nodes. In the general case we can number the internal nodes 1<em>,</em> 2<em>, ..., n</em>; this numbering has the useful property that the parent of node <em>k</em> is node <span class="middle"><img src="../Images/ch02/en0470_01.jpg"></span><em>k/</em>2<span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span>, and the children of node <em>k</em> are nodes 2<em>k</em> and 2<em>k</em> + 1. The external nodes are numbered <em>n</em> + 1 through 2<em>n</em> + 1, inclusive.</p>

  <p class="indent">It follows that a complete binary tree may simply be represented in sequential memory locations, with the structure implicit in the locations of the nodes (not in links). The complete binary tree appears explicitly or implicitly in many important computer algorithms, so the reader should give it special attention.</p>

  <p class="indent">These concepts have important generalizations to ternary, quaternary, and higher-order trees. We define a <em>t-ary tree</em> as a set of nodes that is either empty or consists of a root and <em>t</em> ordered, disjoint <em>t</em>-ary trees. (This generalizes the definition of binary tree in <a href="../Text/ch02a.html#ch02lev1sec3">Section 2.3</a>.) Here, for example, is the <em>complete ternary tree</em> with 12 internal nodes:</p>

  <div class="equation"><a id="ch02eq-lev3sec5-6"></a><img src="../Images/ch02/401equ02.jpg"></div>

  <p class="noindent">It is easy to see that the same construction works for any <em>t</em> ≥ 2. In the complete <em>t</em>-ary tree with internal nodes {1<em>,</em> 2<em>, ..., n</em>}, the parent of node <em>k</em> is node</p>

  <p class="center"><span class="middle"><img src="../Images/ch02/en0470_01.jpg"></span>(<em>k</em> + <em>t</em> − 2)<em>/t</em><span class="middle"><img src="../Images/ch02/en0470_02.jpg"></span> = <span class="middle"><img src="../Images/ch02/en0477_01.jpg"></span>(<em>k</em> − 1)<em>/t</em><span class="middle"><img src="../Images/ch02/en0477_02.jpg"></span><em>,</em></p>

  <p class="noindent">and the children of node <em>k</em> are</p>

  <p class="center"><em>t</em>(<em>k</em> − 1) + 2, <em>t</em>(<em>k</em> − 1) + 3, ..., <em>tk</em> + 1.</p>

  <p class="noindent"><a id="page_402"></a>This tree has the minimum internal path length among all <em>t</em>-ary trees with <em>n</em> internal nodes; <a href="../Text/ch02b.html#ch02ex_3_5_8">exercise 8</a> proves that its internal path length is</p>

  <div class="equation"><a id="ch02eq-lev3sec5-7"></a><img src="../Images/ch02/402equ01.jpg"></div>

  <p class="indent">These results have another important generalization if we shift our point of view slightly. Suppose that we are given <em>m</em> real numbers <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, ..., <em>w</em><sub><em>m</em></sub>; the problem is to find an extended binary tree with <em>m</em> external nodes, and to associate the numbers <em>w</em><sub>1</sub>, ..., <em>w</em><sub><em>m</em></sub> with these nodes in such a way that the sum ∑ <em>w</em><sub>j</sub><em>l</em><sub>j</sub> is minimized, where <em>l</em><sub>j</sub> is the length of path from the root and the sum is taken over all external nodes. For example, if the given numbers are 2, 3, 4, 11, we can form extended binary trees such as these three:</p>

  <div class="equation"><a id="ch02eq-lev3sec5-8"></a><img src="../Images/ch02/402equ02.jpg"></div>

  <p class="noindent">Here the “weighted” path lengths ∑ <em>w</em><sub>j</sub><em>l</em><sub>j</sub> are 34, 53, and 40, respectively. (There- fore a perfectly balanced tree does <em>not</em> give the minimum weighted path length when the weights are 2, 3, 4, and 11, although we have seen that it does give the minimum in the special case <em>w</em><sub>1</sub> = <em>w</em><sub>2</sub> = · · · = <em>w</em><sub>m</sub> = 1.)</p>

  <p class="indent">Several interpretations of weighted path length arise in connection with different computer algorithms; for example, we can apply it to the merging of sorted sequences of respective lengths <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, ..., <em>w</em><sub><em>m</em></sub> (see Chapter 5). One of the most straightforward applications of this idea is to consider a binary tree as a general search procedure, where we start at the root and then make some test; the outcome of the test sends us to one of the two branches, where we may make further tests, etc. For example, if we want to decide which of four different alternatives is true, and if these possibilities will be true with the respective probabilities <span class="middle"><img src="../Images/ch02/2by20.jpg"></span>, <span class="middle"><img src="../Images/ch02/3by20.jpg"></span>, <span class="middle"><img src="../Images/ch02/4by20.jpg"></span>, and <span class="middle"><img src="../Images/ch02/11by20.jpg"></span>, a tree that minimizes the weighted path length will constitute an <em>optimal search procedure</em>. [These are the weights shown in (<a href="../Text/ch02b.html#ch02eq-lev3sec5-8">8</a>), times a scale factor.]</p>

  <p class="indent">An elegant algorithm for finding a tree with minimum weighted path length was discovered by D. Huffman [<em>Proc. IRE</em> <strong>40</strong> (1952), 1098–1101]: First find the two <em>w</em>’s of lowest value, say <em>w</em><sub>1</sub> and <em>w</em><sub>2</sub> . Then solve the problem for <em>m</em> − 1 weights <em>w</em><sub>1</sub> + <em>w</em><sub>2</sub>, <em>w</em><sub>3</sub>, ..., <em>w</em><sub><em>m</em></sub>, and replace the node</p>

  <div class="equation"><a id="ch02eq-lev3sec5-9"></a><img src="../Images/ch02/402equ03.jpg"></div>

  <p class="noindent"><a id="page_403"></a>in this solution by</p>

  <div class="equation"><a id="ch02eq-lev3sec5-10"></a><img src="../Images/ch02/403equ01.jpg"></div>

  <p class="indent">As an example of Huffman’s method, let us find the optimal tree for the weights 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41. First we combine 2 + 3, and look for the solution to 5, 5, 7, ..., 41; then we combine 5 + 5, etc. The computation is summarized as follows:</p>

  <div class="image"><img src="../Images/ch02/e403_01.jpg"></div>

  <p class="noindent">Therefore the following tree corresponds to Huffman’s construction:</p>

  <div class="equation"><a id="ch02eq-lev3sec5-11"></a><img src="../Images/ch02/403equ02.jpg"></div>

  <p class="noindent">(The numbers inside the circular nodes show the correspondence between this tree and our computation; see also <a href="../Text/ch02b.html#ch02ex_3_5_9">exercise 9</a>.)</p>

  <p class="indent">It is not hard to prove that this method does in fact minimize the weighted path length, by induction on <em>m</em>. Suppose we have <em>w</em><sub>1</sub> ≤ <em>w</em><sub>2</sub> ≤ <em>w</em><sub>3</sub> ≤ · · · ≤ <em>w</em><sub><em>m</em></sub>, where <em>m</em> ≥ 2, and suppose that we are given a tree that minimizes the weighted path length. (Such a tree certainly exists, since only finitely many binary trees with <em>m</em> terminal nodes are possible.) Let <em>V</em> be an internal node of maximum distance from the root. If <em>w</em><sub>1</sub> and <em>w</em><sub>2</sub> are not the weights already attached to the children of <em>V</em>, we can interchange them with the values that are already there; <a id="page_404"></a>such an interchange does not increase the weighted path length. Thus there is a tree that minimizes the weighted path length and contains the subtree (<a href="../Text/ch02b.html#ch02eq-lev3sec5-10">10</a>). Now it is easy to prove that the weighted path length of a tree for the weights <em>w</em><sub>1</sub>, ..., <em>w</em><sub>m</sub> that contains (<a href="../Text/ch02b.html#ch02eq-lev3sec5-10">10</a>) as a subtree is minimized if and only if that tree with (<a href="../Text/ch02b.html#ch02eq-lev3sec5-10">10</a>) replaced by (<a href="../Text/ch02b.html#ch02eq-lev3sec5-9">9</a>) has minimum path length for the weights <em>w</em><sub>1</sub> + <em>w</em><sub>2</sub>, <em>w</em><sub>3</sub>, ..., <em>w</em><sub>m</sub> . (See <a href="../Text/ch02b.html#ch02ex_3_5_9">exercise 9</a>.)</p>

  <p class="indent">Every time this construction combines two weights, they are at least as big as the weights previously combined, if the given <em>w</em><sub><em>i</em></sub> were nonnegative. This means that there is a neat way to find Huffman’s tree, provided that the given weights have been sorted into nondecreasing order: We simply maintain two queues, one containing the original weights and the other containing the combined weights. At each step the smallest unused weight will appear at the front of one of the queues, so we never have to search for it. See <a href="../Text/ch02b.html#ch02ex_3_5_13">exercise 13</a>, which shows that the same idea works even when the weights might be negative.</p>

  <p class="indent">In general, there are many trees that minimize ∑ <em>w</em><sub><em>j</em></sub><em>l</em><sub><em>j</em></sub> . If the algorithm sketched in the preceding paragraph always uses an original weight instead of a combined weight in case of ties, then the tree it constructs has the smallest value of max <em>l</em><sub><em>j</em></sub> and of ∑ <em>l</em><sub><em>j</em></sub> among all trees that minimize ∑ <em>w</em><sub><em>j</em></sub><em>l</em><sub><em>j</em></sub> . If the weights are positive, this tree actually minimizes ∑ <em>w</em><sub><em>j</em></sub><em>f</em> (<em>l</em><sub><em>j</em></sub>) for <em>any</em> convex function <em>f</em>, over all such trees. [See E. S. Schwartz, <em>Information and Control</em> <strong>7</strong> (1964), 37–44; G. Markowsky, <em>Acta Informatica</em> <strong>16</strong> (1981), 363–370.]</p>

  <p class="indent">Huffman’s method can be generalized to <em>t</em>-ary trees as well as binary trees. (See <a href="../Text/ch02b.html#ch02ex_3_5_10">exercise 10</a>.) Another important generalization of Huffman’s method is discussed in Section 6.2.2. Further discussion of path length appears in Sections<br>
  5.3.1, 5.4.9, and 6.3.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_1a" id="ch02ex_3_5_1">1</a>.</strong> [<em>12</em>] Are there any other binary trees with 12 internal nodes and minimum path length, besides the complete binary tree (<a href="../Text/ch02b.html#ch02eq-lev3sec5-5">5</a>)?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_2a" id="ch02ex_3_5_2">2</a>.</strong> [<em>17</em>] Draw an extended binary tree with terminal nodes containing the weights 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, having minimum weighted path length.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_5_3a" id="ch02ex_3_5_3">3</a>.</strong> [<em>M24</em>] An extended binary tree with <em>m</em> external nodes determines a set of path lengths <em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, ..., <em>l</em><sub>m</sub> that describe the lengths of paths from the root to the respective external nodes. Conversely, if we are given a set of numbers <em>l</em><sub>1</sub>, <em>l</em><sub>2</sub>, ..., <em>l</em><sub><em>m</em></sub>, is it always possible to construct an extended binary tree in which these numbers are the path lengths in some order? Show that this is possible if and only if <span class="middle"><img src="../Images/ch02/e404_01.jpg"></span>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_5_4a" id="ch02ex_3_5_4">4</a>.</strong> [<em>M25</em>] (E. S. Schwartz and B. Kallick.) Assume that <em>w</em><sub>1</sub> ≤ <em>w</em><sub>2</sub> ≤ · · · ≤ <em>w</em><sub><em>m</em></sub>. Show that there is an extended binary tree that minimizes ∑ <em>w</em><sub><em>j</em></sub><em>l</em><sub><em>j</em></sub> and for which the terminal nodes in left to right order contain the respective values w<sub>1</sub>, <em>w</em><sub>2</sub>, ..., <em>w</em><sub>m</sub>. [For example, tree (<a href="../Text/ch02b.html#ch02eq-lev3sec5-11">11</a>) does <em>not</em> meet this condition since the weights appear in the order 19, 23, 11, 13, 29, 2, 3, 5, 7, 17, 31, 37, 41. We seek a tree for which the weights appear in ascending order, and this does not always happen with Huffman’s construction.]</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_5a" id="ch02ex_3_5_5">5</a>.</strong> [<em>HM26</em>] Let</p>

  <div class="image"><img src="../Images/ch02/e404_02.jpg"></div>

  <p class="noindent"><a id="page_405"></a>where <em>b</em><sub><em>np</em></sub> is the number of binary trees with <em>n</em> nodes and internal path length <em>p</em>. [Thus,</p>

  <p class="center"><em>B</em>(<em>w, z</em>) = 1 + <em>z</em> + 2<em>wz</em><sup>2</sup> + (<em>w</em><sup>2</sup> + 4<em>w</em><sup>3</sup>) <em>z</em><sup>3</sup> + (4<em>w</em><sup>4</sup> + 2<em>w</em><sup>5</sup> + 8<em>w</em><sup>6</sup>) <em>z</em><sup>4</sup> + · · ·;</p>

  <p class="noindent"><em>B</em>(1<em>, z</em>) is the function <em>B</em>(<em>z</em>) of Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-13">13</a>) in <a href="../Text/ch02b.html#ch02lev3sec4">Section 2.3.4.4</a>.]</p>

  <p class="indenthangingA">a) Find a functional relation that characterizes <em>B</em>(<em>w, z</em>), generalizing <a href="../Text/ch02b.html#ch02lev3sec4">2.3.4.4</a>–(<a href="../Text/ch02b.html#ch02eq-lev3sec4-12">12</a>).</p>

  <p class="indenthangingA">b) Use the result of (a) to determine the <em>average internal path length</em> of a binary tree with <em>n</em> nodes, assuming that each of the <span class="middle"><img src="../Images/ch02/e405_01.jpg"></span> trees is equally probable.</p>

  <p class="indenthangingA">c) Find the asymptotic value of this quantity.</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_6a" id="ch02ex_3_5_6">6</a>.</strong> [<em>16</em>] If a <em>t</em>-ary tree is extended with square nodes as in (<a href="../Text/ch02b.html#ch02eq-lev3sec5-1">1</a>), what is the relation between the number of square and circular nodes corresponding to Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec5-2">2</a>)?</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_7a" id="ch02ex_3_5_7">7</a>.</strong> [<em>M21</em>] What is the relation between external and internal path length in a <em>t</em>-ary tree? (See <a href="../Text/ch02b.html#ch02ex_3_5_6">exercise 6</a>; a generalization of Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec5-3">3</a>) is desired.)</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_8a" id="ch02ex_3_5_8">8</a>.</strong> [<em>M23</em>] Prove Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec5-7">7</a>).</p>

  <p class="exercises"><strong><a href="../Text/app01b.html#ch02ex_3_5_9a" id="ch02ex_3_5_9">9</a>.</strong> [<em>M21</em>] The numbers that appear in the circular nodes of (<a href="../Text/ch02b.html#ch02eq-lev3sec5-11">11</a>) are equal to the sums of the weights in the external nodes of the corresponding subtree. Show that the sum of all values in the circular nodes is equal to the weighted path length.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_5_10a" id="ch02ex_3_5_10">10</a>.</strong> [<em>M26</em>] (D. Huffman.) Show how to construct a <em>t</em>-ary tree with minimum weighted path length, given nonnegative weights <em>w</em><sub>1</sub>, <em>w</em><sub>2</sub>, ..., <em>w</em><sub><em>m</em></sub>. Construct an optimal ternary tree for weights 1, 4, 9, 16, 25, 36, 49, 64, 81, 100.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_5_11a" id="ch02ex_3_5_11">11</a>.</strong> [<em>16</em>] Is there any connection between the complete binary tree (<a href="../Text/ch02b.html#ch02eq-lev3sec5-5">5</a>) and the “Dewey decimal notation” for binary trees described in <a href="../Text/ch02a.html#ch02lev2sec7">exercise 2.3.1</a>–<a href="../Text/ch02a.html#page_331">5</a>?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_5_12a" id="ch02ex_3_5_12">12</a>.</strong> [<em>M20</em>] Suppose that a node has been chosen at random in a binary tree, with each node equally likely. Show that the average size of the subtree rooted at that node is related to the path length of the tree.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_5_13a" id="ch02ex_3_5_13">13</a>.</strong> [<em>22</em>] Design an algorithm that begins with <em>m</em> weights <em>w</em><sub>1</sub> ≤ <em>w</em><sub>2</sub> ≤ · · · ≤ <em>w</em><sub><em>m</em></sub> and constructs an extended binary tree having minimum weighted path length. Represent the final tree in three arrays</p>

  <p class="center"><em>A</em>[1] ... <em>A</em>[2<em>m</em> − 1], <em>L</em>[1] ... <em>L</em>[<em>m</em> − 1], <em>R</em>[1] ... <em>R</em>[<em>m</em> − 1];</p>

  <p class="noindent">here <em>L</em>[<em>i</em>] and <em>R</em>[<em>i</em>] point to the left and right children of internal node <em>i</em>, the root is node 1, and <em>A</em>[<em>i</em>] is the weight of node <em>i</em>. The original weights should appear as the external node weights <em>A</em>[<em>m</em>], ..., <em>A</em>[2<em>m</em> − 1]. Your algorithm should make fewer than 2<em>m</em> weight-comparisons. <em>Caution:</em> Some or all of the given weights may be negative!</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_5_14a" id="ch02ex_3_5_14">14</a>.</strong> [<em>25</em>] (T. C. Hu and A. C. Tucker.) After <em>k</em> steps of Huffman’s algorithm, the nodes combined so far form a forest of <em>m</em> − <em>k</em> extended binary trees. Prove that this forest has the smallest total weighted path length, among all forests of <em>m</em> − <em>k</em> extended binary trees that have the given weights.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_5_15a" id="ch02ex_3_5_15">15</a>.</strong> [<em>M25</em>] Show that a Huffman-like algorithm will find an extended binary tree that minimizes (a) max(<em>w</em><sub>1</sub> + <em>l</em><sub>1</sub>, ..., <em>w</em><sub><em>m</em></sub> + <em>l</em><sub><em>m</em></sub>); (b) <em>w</em><sub>1</sub><em>x</em><sup><em>l</em>1</sup> + · · · + <em>w<sub>m</sub> x<sup>lm</sup></em>, given <em>x</em> &gt; 1.</p>

  <p class="exercises1"><strong><a href="../Text/app01b.html#ch02ex_3_5_16a" id="ch02ex_3_5_16">16</a>.</strong> [<em>M25</em>] (F. K. Hwang.) Let <em>w</em><sub>1</sub> ≤ · · · ≤ <em>w</em><sub><em>m</em></sub> and <span class="middle"><img src="../Images/ch02/e405_02.jpg"></span> be two sets of weights with</p>

  <div class="image"><img src="../Images/ch02/e405_03.jpg"></div>

  <p class="exercisesp">Prove that the minimum weighted path lengths satisfy <span class="middle"><img src="../Images/ch02/e405_04.jpg"></span>.</p>

  <p class="exercises1"><a id="page_406"></a><strong><a href="../Text/app01b.html#ch02ex_3_5_17a" id="ch02ex_3_5_17">17</a>.</strong> [<em>HM30</em>] (C. R. Glassey and R. M. Karp.) Let <em>s</em><sub>1</sub>, ..., <em>s</em><sub><em>m</em>−1</sub> be the numbers inside the internal (circular) nodes of an extended binary tree formed by Huffman’s algorithm, in the order of construction. Let <span class="middle"><img src="../Images/ch02/e406_01.jpg"></span> be the internal node weights of any extended binary tree on the same set of weights {<em>w</em><sub>1</sub>, ..., <em>w</em><sub><em>m</em></sub>}, listed in any order such that each nonroot internal node appears before its parent. (a) Prove that <span class="middle"><img src="../Images/ch02/e406_02.jpg"></span> for 1 ≤ <em>k</em> &lt; <em>m</em>. (b) The result of (a) is equivalent to</p>

  <div class="image"><img src="../Images/ch02/e406_03.jpg"></div>

  <p class="exercisesp">for every nondecreasing concave function <em>f</em>, namely every function <em>f</em> with <em>f</em>′ (<em>x</em>) ≥ 0 and <em>f</em>′′ (<em>x</em>) ≤ 0. [See Hardy, Littlewood, and Pólya, <em>Messenger of Math.</em> <strong>58</strong> (1929), 145–152.] Use this fact to show that the minimum value in the recurrence</p>

  <div class="image"><img src="../Images/ch02/e406_04.jpg"></div>

  <p class="exercisesp">always occurs when <em>k</em> = 2<sup><span class="middle"><img src="../Images/ch02/en0477_01.jpg"></span>lg(<em>n</em>/3)<span class="middle"><img src="../Images/ch02/en0477_02.jpg"></span></sup>, given any function <em>f</em> (<em>n</em>) with the property that <em>Δf</em> (<em>n</em>) = <em>f</em> (<em>n</em> + 1) − <em>f</em> (<em>n</em>) ≥ 0 and Δ<sup>2</sup><em>f</em> (<em>n</em>) = <em>Δf</em> (<em>n</em> + 1) − <em>Δf</em> (<em>n</em>) ≤ 0.</p>

  <div class="heading">
    <h5 id="ch02lev3sec6">*2.3.4.6. History and bibliography</h5>

    <p class="noindent">Trees have of course been in existence since the third day of creation, and through the ages tree structures (especially <em>family</em> trees) have been in common use. The concept of tree as a formally defined <em>mathematical</em> entity seems to have appeared first in the work of G. Kirchhoff [<em>Annalen der Physik und Chemie</em> <strong>72</strong> (1847), 497–508, English translation in <em>IRE Transactions</em> <strong>CT-5</strong> (1958), 4–7]; Kirchhoff used free trees to find a set of fundamental cycles in an electrical network in connection with the law that bears his name, essentially as we did in <a href="../Text/ch02b.html#ch02lev3sec1">Section 2.3.4.1</a>. The concept also appeared at about the same time in the book <em>Geometrie der Lage</em> (pages <a href="../Text/ch01.html#page_20">20</a>–<a href="../Text/ch01.html#page_21">21</a>) by K. G. Chr. von Staudt. The name “tree” and many results dealing mostly with enumeration of trees began to appear ten years later in a series of papers by Arthur Cayley [see <em>Collected Mathematical Papers of A. Cayley</em> <strong>3</strong> (1857), 242–246; 4 (1859), 112– 115; <strong>9</strong> (1874), 202–204; <strong>9</strong> (1875), 427–460; <strong>10</strong> (1877), 598–600; <strong>11</strong> (1881), 365– 367; <strong>13</strong> (1889), 26–28]. Cayley was unaware of the previous work of Kirchhoff and von Staudt; his investigations began with studies of the structure of algebraic formulas, and they were later inspired chiefly by applications to the problem of isomers in chemistry. Tree structures were also studied independently by C. W. Borchardt [<em>Crelle</em> <strong>57</strong> (1860), 111–121]; J. B. Listing [<em>Göttinger Abhandlungen</em>, Math. Classe, <strong>10</strong> (1862), 137–139]; and C. Jordan [<em>Crelle</em> <strong>70</strong> (1869), 185–190].</p>
  </div>

  <p class="indent">The “infinity lemma” was formulated first by Dénes König [<em>Fundamenta Math</em>. <strong>8</strong> (1926), 114–134], and he gave it a prominent place in his classic book <em>Theorie der endlichen und unendlichen Graphen</em> (Leipzig: 1936), Chapter 6. A similar result called the “fan theorem” occurred slightly earlier in the work of L. E. J. Brouwer [<em>Verhandelingen Akad. Amsterdam</em> <strong>12</strong> (1919), 7], but this involved much stronger hypotheses; see A. Heyting, <em>Intuitionism</em> (1956), Section 3.4, for a discussion of Brouwer’s work.</p>

  <p class="indent">Formula (<a href="../Text/ch02b.html#ch02eq-lev3sec5-3">3</a>) of <a href="../Text/ch02b.html#ch02lev3sec4">Section 2.3.4.4</a> for enumerating unlabeled oriented trees was given by Cayley in his first paper on trees. In his second paper he enumerated unlabeled ordered trees; an equivalent problem in geometry (see <a href="../Text/ch02b.html#ch02ex_3_6_1">exercise 1</a>) <a id="page_407"></a>had already been proposed and solved by L. Euler, who mentioned his results in a letter to C. Goldbach on 4 September 1751 [see J. von Segner and L. Euler, <em>Novi Commentarii Academiæ Scientiarum Petropolitan</em>æ <strong>7</strong> (1758–1759), summary 13–15, 203–210]. Euler’s problem was the subject of seven papers by G. Lamé, E. Catalan, O. Rodrigues, and J. Binet in <em>Journal de mathématiques</em> <strong>3, 4</strong> (1838, 1839); additional references appear in the answer to <a href="../Text/ch02.html#ch02lev2sec1">exercise 2.2.1</a>–<a href="../Text/ch02.html#ch02ex_2_1_4">4</a>. The corresponding numbers are now commonly called “Catalan numbers.” A Mongolian Chinese mathematician, An-T’u Ming, had encountered the Catalan numbers before 1750 in his study of infinite series, but he did not relate them to trees or other combinatorial objects [see J. Luo, <em>Acta Scientiarum Naturalium Universitatis Intramongolic</em>æ <strong>19</strong> (1988), 239–245; <em>Combinatorics and Graph Theory</em> (World Scientific Publishing, 1993), 68–70]. Catalan numbers occur in an enormous number of different contexts; Richard Stanley explains more than 60 of them in his magnificent book <em>Enumerative Combinatorics</em> <strong>2</strong> (Cambridge Univ. Press, 1999), Chapter 6. Perhaps most surprising of all is the Catalan connection to certain arrangements of numbers that H. S. M. Coxeter has called “frieze patterns” because of their symmetry; see <a href="../Text/ch02b.html#ch02ex_3_6_4">exercise 4</a>.</p>

  <p class="indent">The formula <em>n</em><sup><em>n</em>−2</sup> for the number of <em>labeled</em> free trees was discovered by J. J. Sylvester [<em>Quart. J. Pure and Applied Math.</em> <strong>1</strong> (1857), 55–56], as a byproduct of his evaluation of a certain determinant (<a href="../Text/ch02b.html#ch02lev3sec2">exercise 2.3.4.2</a>–<a href="../Text/ch02b.html#ch02ex_3_2_28">28</a>). Cayley gave an independent derivation of the formula in 1889 [see the reference above]; his discussion, which was extremely vague, hinted at a connection between labeled oriented trees and (<em>n</em> − 1)-tuples of numbers. An explicit correspondence demonstrating such a connection was first published by Heinz Prüfer [<em>Arch. Math. und Phys</em>. <strong>27</strong> (1918), 142–144], quite independently of Cayley’s prior work. A large literature on this subject has developed, and the classical results are surveyed beautifully in J. W. Moon’s book, <em>Counting Labelled Trees</em> (Montreal: Canadian Math. Congress, 1970).</p>

  <p class="indent">A very important paper on the enumeration of trees and many other kinds of combinatorial structures was published by G. Pólya in <em>Acta Math.</em> <strong>68</strong> (1937), 145–253. For a discussion of enumeration problems for graphs and an excellent bibliography of the early literature, see the survey by Frank Harary in <em>Graph Theory and Theoretical Physics</em> (London: Academic Press, 1967), 1–41.</p>

  <p class="indent">The principle of minimizing weighted path length by repeatedly combining the smallest weights was discovered by D. Huffman [<em>Proc. IRE</em> <strong>40</strong> (1952), 1098– 1101], in connection with the design of codes for minimizing message lengths. The same idea was independently published by Seth Zimmerman [<em>AMM</em> <strong>66</strong> (1959), 690–693].</p>

  <p class="indent">Several other noteworthy papers about the theory of tree structures have been cited in <a href="../Text/ch02b.html#ch02lev3sec1">Sections 2.3.4.1</a> through <a href="../Text/ch02b.html#ch02lev3sec5">2.3.4.5</a> in connection with particular topics.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_6_1a" id="ch02ex_3_6_1">1</a>.</strong> [<em>21</em>] Find a simple one-to-one correspondence between binary trees with <em>n</em> nodes and dissections of an (<em>n</em> + 2)-sided convex polygon into <em>n</em> triangles, assuming that the sides of the polygon are distinct.</p>

  <p class="exercises2"><a id="page_408"></a><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_6_2a" id="ch02ex_3_6_2">2</a>.</strong> [<em>M26</em>] T. P. Kirkman conjectured in 1857 that the number of ways to draw <em>k</em> nonoverlapping diagonals in an <em>r</em>-sided polygon is <span class="middle"><img src="../Images/ch02/e408_01.jpg"></span>.</p>

  <p class="indenthangingA">a) Extend the correspondence of <a href="../Text/ch02b.html#ch02ex_3_6_1">exercise 1</a> to obtain an equivalent problem about the enumeration of trees.</p>

  <p class="indenthangingA">b) Prove Kirkman’s conjecture by using the methods of <a href="../Text/ch02b.html#ch02lev3sec4">exercise 2.3.4.4</a>–<a href="../Text/ch02b.html#ch02ex_3_4_32">32</a>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_6_3a" id="ch02ex_3_6_3">3</a>.</strong> [<em>M30</em>] Consider all ways of partitioning the vertices of a convex <em>n</em>-gon into <em>k</em> nonempty parts, in such a way that no diagonal between two vertices of one part crosses a diagonal between two vertices of another part.</p>

  <p class="indenthangingA">a) Find a one-to-one correspondence between noncrossing partitions and an interesting class of tree structures.</p>

  <p class="indenthangingA">b) Given <em>n</em> and <em>k</em>, how many ways are there to make such a partition?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.jpg"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01b.html#ch02ex_3_6_4a" id="ch02ex_3_6_4">4</a>.</strong> [<em>M38</em>] (Conway and Coxeter.) A <em>frieze pattern</em> is an infinite array such as</p>

  <p class="indenthangingNP">1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;...<br>
  &nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;4&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;4&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;...<br>
  5&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;...<br>
  &nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;5&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;...<br>
  1&nbsp;&nbsp;4&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;4&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;3&nbsp;&nbsp;1&nbsp;&nbsp;4&nbsp;&nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;...<br>
  &nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;...</p>

  <p class="noindent">in which the top and bottom rows consist entirely of 1s, and each diamond of adjacent values <span class="middle"><img src="../Images/ch02/e408_03.jpg"></span> satisfies <em>ad</em> − <em>bc</em> = 1. Find a one-to-one correspondence between <em>n</em>-node binary trees and (<em>n</em> + 1)-rowed frieze patterns of positive integers.</p>
</body>
</html>