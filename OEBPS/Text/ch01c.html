<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$","$"]],
        displayMath: [["$$","$$"]],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  <title></title>
  <link href="../Styles/caps.css" rel="stylesheet" type="text/css">
</head>

<body>
  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_1a" id="ch01ex_2_14_1">1</a>.</strong> [<em>02</em>] Consider the transformation of \{0<em>,</em> 1<em>,</em> 2<em>,</em> 3<em>,</em> 4<em>,</em> 5<em>,</em> 6\} that replaces <em>x</em> by 2<em>x</em> mod 7. Show that this transformation is a permutation, and write it in cycle form.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_2a" id="ch01ex_2_14_2">2</a>.</strong> [<em>10</em>] The text shows how we might set (<em>a, b, c, d, e, f</em>) ← (<em>c, d, f, b, e, a</em>) by using a series of replacement operations (<em>x</em> ← <em>y</em>) and one auxiliary variable <em>t</em>. Show how to do the job by using a series of <em>exchange</em> operations (<em>x ↔ y</em>) and no auxiliary variables.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_3a" id="ch01ex_2_14_3">3</a>.</strong> [<em>03</em>] Compute the product <span class="middle"><img src="../Images/ch01/e182_01.jpg"></span>, and express the answer in two-line notation. (Compare with Eq. (<a href="../Text/ch01b.html#ch01eq-lev2sec14-4">4</a>).)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_4a" id="ch01ex_2_14_4">4</a>.</strong> [<em>10</em>] Express (<em>a b d</em>)(<em>e f</em>) (<em>a c f</em>) (<em>b d</em>) as a product of disjoint cycles.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_5a" id="ch01ex_2_14_5">5</a>.</strong> [<em>M10</em>] Equation (<a href="../Text/ch01b.html#ch01eq-lev2sec14-3">3</a>) shows several equivalent ways to express the same permutation in cycle form. How many different ways of writing that permutation are possible, if all singleton cycles are suppressed?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_6a" id="ch01ex_2_14_6">6</a>.</strong> [<em>M28</em>] What changes are made to the timing of <a href="../Text/ch01b.html#ch01b_pro_a">Program A</a> if we remove the assumption that all blank words occur at the extreme right?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_7a" id="ch01ex_2_14_7">7</a>.</strong> [<em>10</em>] If <a href="../Text/ch01b.html#ch01b_pro_a">Program A</a> is presented with the input (<a href="../Text/ch01b.html#ch01eq-lev2sec14-6">6</a>), what are the quantities <em>X</em>, <em>Y</em>, <em>M</em>, <em>N</em>, <em>U</em>, and <em>V</em> of (<a href="../Text/ch01b.html#ch01eq-lev2sec14-19">19</a>)? What is the time required by <a href="../Text/ch01b.html#ch01b_pro_a">Program A</a>, excluding input-output?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_8a" id="ch01ex_2_14_8">8</a>.</strong> [<em>23</em>] Would it be feasible to modify <a href="../Text/ch01b.html#ch01alg-lev2sec14-B">Algorithm B</a> to go from left to right instead of from right to left through the input?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_14_9a" id="ch01ex_2_14_9">9</a>.</strong> [<em>10</em>] Both Programs A and B accept the same input and give the answer in essentially the same form. Is the output <em>exactly</em> the same under both programs?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_10a" id="ch01ex_2_14_10">10</a>.</strong> [<em>M28</em>] Examine the timing characteristics of <a href="../Text/ch01c.html#programB">Program B</a>, namely, the quantities <em>A</em>, <em>B</em>, ..., <em>Z</em> shown there; express the total time in terms of the quantities <em>X</em>, <em>Y</em>, <em>M</em>, <em>N</em>, <em>U</em>, <em>V</em> defined in (<a href="../Text/ch01b.html#ch01eq-lev2sec14-19">19</a>), and of <em>F</em>. Compare the total time for <a href="../Text/ch01c.html#programB">Program B</a> with the total time for <a href="../Text/ch01b.html#ch01b_pro_a">Program A</a> on the input (<a href="../Text/ch01b.html#ch01eq-lev2sec14-6">6</a>), as computed in <a href="../Text/ch01c.html#ch01ex_2_14_7">exercise 7</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_11a" id="ch01ex_2_14_11">11</a>.</strong> [<em>15</em>] Find a simple rule for writing <em>π</em><sup>−</sup> in cycle form, if the permutation <em>π</em> is given in cycle form.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_12a" id="ch01ex_2_14_12">12</a>.</strong> [<em>M27</em>] (<em>Transposing a rectangular matrix.</em>) Suppose an <em>m</em> × <em>n</em> matrix (<em>a</em><sub><em>ij</em></sub>), <em>m</em> ≠ <em>n</em>, is stored in memory in a fashion like that of exercise <a href="../Text/ch01b.html#ch01lev2sec13">1.3.2</a>–<a href="../Text/ch01b.html#ch01ex_2_13_10">10</a>, so that the value of <em>a</em><sub><em>ij</em></sub> appears in location <em>L</em> + <em>n</em>(<em>i</em> − 1) + (<em>j</em> − 1), where <em>L</em> is the location of <em>a</em><sub>11</sub> . The problem is to find a way to <em>transpose</em> this matrix, obtaining an <em>n</em> × <em>m</em> matrix (<em>b</em><sub><em>ij</em></sub>), where <em>b</em><sub><em>ij</em></sub> = <em>a</em><sub><em>ji</em></sub> is stored in location <em>L</em> + <em>m</em>(<em>i</em> − 1) + (<em>j</em> − 1). Thus the matrix is to be transposed “on itself.” (a) Show that the transposition transformation moves the value that appears in cell <em>L</em> + <em>x</em> to cell <em>L</em> + (<em>mx</em> mod <em>N</em>), for all <em>x</em> in the range 0 ≤ <em>x</em> &lt; <em>N</em> = <em>mn</em> − 1. (b) Discuss methods for doing this transposition by computer.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_13a" id="ch01ex_2_14_13">13</a>.</strong> [<em>M24</em>] Prove that <a href="../Text/ch01b.html#ch01alg-lev2sec14-J">Algorithm J</a> is valid.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_14a" id="ch01ex_2_14_14">14</a>.</strong> [<em>M34</em>] Find the average value of the quantity <em>A</em> in the timing of <a href="../Text/ch01b.html#ch01alg-lev2sec14-J">Algorithm J</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_15_14a" id="ch01ex_2_14_15">15</a>.</strong> [<em>M12</em>] Is there a permutation that represents exactly the same transformation both in the canonical cycle form without parentheses and in the linear form?</p>

  <p class="exercises1"><a id="page_183"></a><strong><a href="../Text/app01a.html#ch01ex_2_14_16a" id="ch01ex_2_14_16">16</a>.</strong> [<em>M15</em>] Start with the permutation 1324 in linear notation; convert it to canonical cycle form and then remove the parentheses; repeat this process until arriving at the original permutation. What permutations occur during this process?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_17a" id="ch01ex_2_14_17">17</a>.</strong> [<em>M24</em>] (a) The text demonstrates that there are <em>n</em>! <em>H<sub>n</sub></em> cycles altogether, among all the permutations on <em>n</em> elements. If these cycles (including singleton cycles) are individually written on <em>n</em>! <em>H<sub>n</sub></em> slips of paper, and if one of these slips of paper is chosen at random, what is the average length of the cycle that is thereby picked? (b) If we write the <em>n</em>! permutations on <em>n</em>! slips of paper, and if we choose a number <em>k</em> at random and also choose one of the slips of paper, what is the probability that the cycle containing <em>k</em> on that slip is an <em>m</em>-cycle? What is the average length of the cycle containing <em>k</em>?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_18a" id="ch01ex_2_14_18">18</a>.</strong> [<em>M27</em>] What is <em>p</em><sub><em>nkm</em></sub>, the probability that a permutation of <em>n</em> objects has exactly <em>k</em> cycles of length <em>m</em>? What is the corresponding generating function <em>G</em><sub><em>nm</em></sub> (<em>z</em>)? What is the average number of <em>m</em>-cycles and what is the standard deviation? (The text considers only the case <em>m</em> = 1.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_19a" id="ch01ex_2_14_19">19</a>.</strong> [<em>HM21</em>] Show that, in the notation of Eq. (<a href="../Text/ch01b.html#ch01eq-lev2sec14-25">25</a>), the number <em>P</em><sub>n0</sub> of derangements is exactly equal to <em>n</em>!<em>/e rounded to the nearest integer</em>, for all <em>n</em> ≥ 1.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_20a" id="ch01ex_2_14_20">20</a>.</strong> [<em>M20</em>] Given that all singleton cycles are written out explicitly, how many different ways are there to write the cycle notation of a permutation that has <em>α</em><sub>1</sub> one-cycles, <em>α</em><sub>2</sub> two-cycles, ... ? (See <a href="../Text/ch01c.html#ch01ex_2_14_5">exercise 5</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_21a" id="ch01ex_2_14_21">21</a>.</strong> [<em>M22</em>] What is the probability <em>P</em> (<em>n</em>; <em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, ...) that a permutation of <em>n</em> objects has exactly <em>α</em><sub>1</sub> one-cycles, <em>α</em><sub>2</sub> two-cycles, etc.?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_22a" id="ch01ex_2_14_22">22</a>.</strong> [<em>HM34</em>] (The following approach, due to L. Shepp and S. P. Lloyd, gives a convenient and powerful method for solving problems related to the cycle structure of random permutations.) Instead of regarding the number, <em>n</em>, of objects as fixed, and the permutation variable, let us assume instead that we independently choose the quantities <em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, <em>α</em><sub>3</sub>, ... appearing in <a href="../Text/ch01c.html#ch01ex_2_14_20">exercises 20</a> and <a href="../Text/ch01c.html#ch01ex_2_14_21">21</a> according to some probability distribution. Let <em>w</em> be any real number between 0 and 1.</p>

  <p class="indenthangingA">a) Suppose that we choose the random variables <em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, <em>α</em><sub>3</sub>, ... according to the rule that “the probability that <em>α</em><sub><em>m</em></sub> = <em>k</em> is <em>f</em> (<em>w, m, k</em>),” for some function <em>f</em> (<em>w, m, k</em>). Determine the value of <em>f</em> (<em>w, m, k</em>) so that the following two conditions hold: (i) ∑<sub>k ≥0</sub><em>f</em> (<em>w, m, k</em>) = 1, for 0 &lt; <em>w</em> &lt; 1 and <em>m</em> ≥ 1; (ii) the probability that <em>α</em><sub>1</sub> + 2<em>α</em><sub>2</sub> + 3<em>α</em><sub>3</sub> + · · · = <em>n and</em> that <em>α</em><sub>1</sub> = <em>k</em><sub>1</sub>, <em>α</em><sub>2</sub> = <em>k</em><sub>2</sub>, <em>α</em><sub>3</sub> = <em>k</em><sub>3</sub>, ... equals (1 − <em>w</em>)<em>w</em><sup><em>n</em></sup><em>P</em> (<em>n</em>; <em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, <em>k</em><sub>3</sub>, ...), where <em>P</em> (<em>n</em>; <em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>, <em>k</em><sub>3</sub>, ...) is defined in <a href="../Text/ch01c.html#ch01ex_2_14_21">exercise 21</a>.</p>

  <p class="indenthangingA">b) A permutation whose cycle structure is <em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, <em>α</em><sub>3</sub>, ... clearly permutes exactly <em>α</em><sub>1</sub> + 2<em>α</em><sub>2</sub> + 3<em>α</em><sub>3</sub> + · · · objects. Show that if the <em>α</em>’s are randomly chosen according to the probability distribution in part (a), the probability that <em>α</em><sub>1</sub> +2<em>α</em><sub>2</sub> +3<em>α</em><sub>3</sub> +· · · = <em>n</em> is (1 − <em>w</em>)<em>w</em><sup>n</sup>; the probability that <em>α</em><sub>1</sub> + 2<em>α</em><sub>2</sub> + 3<em>α</em><sub>3</sub> + · · · is <em>infinite</em> is zero.</p>

  <p class="indenthangingA">c) Let <em>φ</em>(<em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, ...) be any function of the infinitely many numbers <em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, ... . Show that if the <em>α</em>’s are chosen according to the probability distribution in (a), the average value of <em>φ</em> is <span class="middle"><img src="../Images/ch01/e183_01.jpg"></span>; here <em>φ<sub>n</sub></em> denotes the average value of <em>φ</em> taken over all permutations of <em>n</em> objects, where the variable <em>α</em><em><sup>j</sup></em> represents the number of <em>j</em>-cycles of a permutation. [For example, if <em>φ</em>(<em>α</em><sub>1</sub>, <em>α</em><sub>2</sub>, ...) = <em>α</em><sub>1</sub>, the value of <em>φ</em><em><sub>n</sub></em> is the average number of singleton cycles in a random permutation of <em>n</em> objects; we showed in (<a href="../Text/ch01b.html#ch01eq-lev2sec14-28">28</a>) that <em>φ<sub>n</sub></em> = 1 for all <em>n</em>.]</p>

  <p class="indenthangingA">d) Use this method to find the average number of cycles of <em>even</em> length in a random permutation of <em>n</em> objects.</p>

  <p class="indenthangingA">e) Use this method to solve <a href="../Text/ch01c.html#ch01ex_2_14_18">exercise 18</a>.</p>

  <p class="exercises1"><a id="page_184"></a><strong><a href="../Text/app01a.html#ch01ex_2_14_23a" id="ch01ex_2_14_23">23</a>.</strong> [<em>HM42</em>] (Golomb, Shepp, Lloyd.) If <em>l</em><sub><em>n</em></sub> denotes the average length of the <em>longest</em> cycle in a permutation of <em>n</em> objects, show that <span class="middle"><img src="../Images/ch01/e184_01.jpg"></span>, where <span class="middle"><img src="../Images/ch01/e184_02a.jpg"></span> is a constant. Prove in fact that <span class="middle"><img src="../Images/ch01/e184_02.jpg"></span>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_24a" id="ch01ex_2_14_24">24</a>.</strong> [<em>M41</em>] Find the variance of the quantity <em>A</em> that enters into the timing of <a href="../Text/ch01b.html#ch01alg-lev2sec14-J">Algorithm J</a>. (See <a href="../Text/ch01c.html#ch01ex_2_14_14">exercise 14</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_25a" id="ch01ex_2_14_25">25</a>.</strong> [<em>M22</em>] Prove Eq. (<a href="../Text/ch01b.html#ch01eq-lev2sec14-29">29</a>).</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_26a" id="ch01ex_2_14_26">26</a>.</strong> [<em>M24</em>] Extend the principle of inclusion and exclusion to obtain a formula for the number of elements that are in exactly <em>r</em> of the subsets <em>S</em><sub>1</sub>, <em>S</em><sub>2</sub>, ..., <em>S</em><sub><em>M</em></sub> . (The text considers only the case <em>r</em> = 0.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_27a" id="ch01ex_2_14_27">27</a>.</strong> [<em>M20</em>] Use the principle of inclusion and exclusion to count the number of integers <em>n</em> in the range 0 ≤ <em>n</em> &lt; <em>am</em><sub>1</sub><em>m</em><sub>2</sub> ... <em>m<sub>t</sub></em> that are not divisible by any of <em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, ..., <em>m</em><sub>t</sub> . Here <em>m</em><sub>1</sub>, <em>m</em><sub>2</sub>, ..., <em>m<sub>t</sub></em>, and <em>a</em> are positive integers, with <em>m</em><sub><em>j</em></sub><span class="ent">⊥</span> <em>m</em><sub><em>k</em></sub> when <em>j</em> ≠ <em>k</em>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_28a" id="ch01ex_2_14_28">28</a>.</strong> [<em>M21</em>] (I. Kaplansky.) If the “Josephus permutation” defined in exercise <a href="../Text/ch01b.html#ch01lev2sec13">1.3.2</a>–<a href="../Text/ch01b.html#ch01ex_2_13_22">22</a> is expressed in cycle form, we obtain (1 5 3 6 8 2 4)(7) when <em>n</em> = 8 and <em>m</em> = 4. Show that this permutation in the general case is the product (<em>n n</em>−1 ... 2 1)<sup><em>m</em>−1</sup> × (<em>n n</em>−1 ... 2)<sup><em>m</em>−1</sup> ... (<em>n n</em>−1)<sup><em>m</em>−1</sup>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_29a" id="ch01ex_2_14_29">29</a>.</strong> [<em>M25</em>] Prove that the cycle form of the Josephus permutation when <em>m</em> = 2 can be obtained by first expressing the “perfect shuffle” permutation of \{1, 2<em>, ...,</em> 2<em>n</em>\}, which takes (1<em>,</em> 2<em>, ...,</em> 2<em>n</em>) into (2, 4<em>, ...,</em> 2<em>n,</em> 1<em>,</em> 3<em>, ...,</em> 2<em>n</em>−1), in cycle form, then reversing left and right and erasing all the numbers greater than <em>n</em>. For example, when <em>n</em> = 11 the perfect shuffle is (1 2 4 8 16 9 18 13 3 6 12)(5 10 20 17 11 22 21 19 15 7 14) and the Josephus permutation is (7 11 10 5)(6 3 9 8 4 2 1).</p>

  <p class="exercises1"><strong><a id="ch01ex_2_14_30"></a>30.</strong> [<em>M24</em>] Use <a href="../Text/ch01c.html#ch01ex_2_14_29">exercise 29</a> to show that the fixed elements of the Josephus permutation when <em>m</em> = 2 are precisely the numbers (2<sup><em>d</em></sup> − 1)(2<em>n</em> + 1)<em>/</em>(2<sup><em>d</em>+1</sup> − 1) for all positive integers <em>d</em> such that this is an integer.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_31a" id="ch01ex_2_14_31">31</a>.</strong> [<em>HM38</em>] Generalizing <a href="../Text/ch01c.html#ch01ex_2_14_29">exercises 29</a> and <a href="../Text/ch01c.html#ch01ex_2_14_30">30</a>, prove that the <em>j</em>th man to be executed, for general <em>m</em> and <em>n</em>, is in position <em>x</em>, where <em>x</em> may be computed as follows: Set <em>x</em> ← <em>jm</em>; then, while <em>x</em> &gt; <em>n</em>, set <em>x</em> ← \lfloor{(<em>m</em>(<em>x</em> − <em>n</em>) − 1)/(<em>m</em> − 1)}\rfloor. Consequently the average number of fixed elements, for 1 ≤ <em>n</em> ≤ <em>N</em> and fixed <em>m</em> &gt; 1 as <em>N</em> → ∞, approaches ∑<sub>k≥1</sub> (<em>m</em> − 1)<sup><em>k</em></sup><em>/</em>(<em>m</em> <sup>k+1</sup> − (<em>m</em> − 1)<sup><em>k</em></sup>). [Since this value lies between (<em>m</em> − 1)<em>/m</em> and 1, the Josephus permutations have slightly fewer fixed elements than random ones do.]</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_32a" id="ch01ex_2_14_32">32</a>.</strong> [<em>M25</em>] (a) Prove that any permutation <em>π</em> = <em>π</em><sub>1</sub><em>π</em><sub>2</sub> ... <em>π</em><em><sub>2m+1</sub></em> of the form</p>

  <div class="image"><img src="../Images/ch01/e184_03.jpg"></div>

  <p class="exercisesp">where each <em>e</em><sub><em>k</em></sub> is 0 or 1, has |<em>π</em><sub><em>k</em></sub> − <em>k</em>| ≤ 2 for 1 ≤ <em>k</em> ≤ 2<em>m</em> + 1.</p>

  <p class="indent">(b) Given any permutation <em>ρ</em> of \{1<em>,</em> 2<em>, ..., n</em>\}, construct a permutation <em>π</em> of the stated form such that <em>ρπ</em> is a single cycle. Thus every permutation is “near” a cycle.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_33a" id="ch01ex_2_14_33">33</a>.</strong> [<em>M33</em>] If <span class="middle"><img src="../Images/ch01/e184_03a.jpg"></span> and <em>n</em> = 2<sup>2<em>l</em>+1</sup>, show how to construct sequences of permutations (<em>α</em><sub><em>j</em>1</sub>, <em>α</em><sub><em>j</em>2</sub>, ..., <em>α</em><sub><em>jn</em></sub>; <em>β</em><sub><em>j</em>1</sub>, <em>β</em><sub><em>j</em>2</sub>, ..., <em>β</em><sub><em>jn</em></sub>) for 0 ≤ <em>j</em> &lt; <em>m</em> with the following “orthogonality” property:</p>

  <div class="image"><img src="../Images/ch01/e184_04.jpg"></div>

  <p class="exercisesp">Each <em>α</em><sub><em>jk</em></sub> and <em>β</em><sub><em>jk</em></sub> should be a permutation of \{1, 2, 3, 4, 5\}.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_14_34a" id="ch01ex_2_14_34">34</a>.</strong> [<em>M25</em>] (<em>Transposing blocks of data.</em>) One of the most common permutations needed in practice is the change from <em>αβ</em> to <em>βα</em>, where <em>α</em> and <em>β</em> are substrings of an array. <a id="page_185"></a>In other words, if <em>x</em><sub>0</sub><em>x</em><sub>1</sub> ... <em>x</em><sub><em>m</em>−1</sub> = <em>α</em> and <em>x</em><sub><em>m</em></sub><em>x</em><sub><em>m</em>+1</sub> ... <em>x</em><sub><em>m</em>+<em>n</em>−1</sub> = <em>β</em>, we want to change the array <em>x</em><sub>0</sub><em>x</em><sub>1</sub> ... <em>x</em><sub><em>m</em>+<em>n</em>−1</sub> = <em>αβ</em> to the array <em>x</em><sub><em>m</em></sub><em>x</em><sub><em>m</em>+1</sub> ... <em>x</em><sub><em>m</em>+<em>n</em>−1</sub><em>x</em><sub>0</sub><em>x</em><sub>1</sub> ... <em>x</em><sub><em>m</em>−1</sub> = <em>βα</em>; each element <em>x</em><sub><em>k</em></sub> should be replaced by <em>x</em><sub><em>p</em>(k)</sub> for 0 ≤ <em>k &lt; m</em> + <em>n</em>, where <em>p</em>(<em>k</em>) = (<em>k</em> + <em>m</em>) mod (<em>m</em> + <em>n</em>). Show that every such “cyclic-shift” permutation has a simple cycle structure, and exploit that structure to devise a simple algorithm for the desired rearrangement.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_35a" id="ch01ex_2_14_35">35</a>.</strong> [<em>M30</em>] Continuing the previous exercise, let <em>x</em><sub>0</sub><em>x</em><sub>1</sub> ... <em>x</em><sub>l+<em>m</em>+<em>n</em>−1</sub> = <em>αβγ</em> where <em>α</em>, <em>β</em>, and <em>γ</em> are strings of respective lengths <em>l</em>, <em>m</em>, and <em>n</em>, and suppose that we want to change <em>αβ</em><em>γ</em> to <em>γβα</em>. Show that the corresponding permutation has a convenient cycle structure that leads to an efficient algorithm. [<a href="../Text/ch01c.html#ch01ex_2_14_34">Exercise 34</a> considered the special case <em>m</em> = 0.] Hint: Consider changing (<em>αβ</em>)(<em>γβ</em>) to (<em>γβ</em>)(<em>αβ</em>).</p>

  <p class="exercises1"><strong>36.</strong> [<em>27</em>] Write a <code>MIX</code> subroutine for the algorithm in the answer to <a href="../Text/ch01c.html#ch01ex_2_14_35">exercise 35</a>, and analyze its running time. Compare it with the simpler method that goes from <em>αβ</em><em>γ</em> to (<em>αβγ</em>)<sup>R</sup> = <em>γ</em><sup><em>R</em></sup><em>β</em><sup><em>R</em></sup><em>α</em><sup><em>R</em></sup> to <em>γβα</em>, where <em>σ</em><sup><em>R</em></sup> denotes the left-right reversal of the string <em>σ</em>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_14_37a" id="ch01ex_2_14_37">37</a>.</strong> [<em>M26</em>] (<em>Even permutations.</em>) Let <em>π</em> be a permutation of \{1<em>, ..., n</em>\}. Prove that <em>π</em> can be written as the product of an even number of 2-cycles if and only if <em>π</em> can be written as the product of exactly two <em>n</em>-cycles.</p>

  <div class="heading">
    <h3 id="ch01lev1sec4"><a id="page_186"></a>1.4. Some Fundamental Programming Techniques</h3>

    <div class="heading">
      <h4 id="ch01lev2sec15">1.4.1. Subroutines</h4>

      <p>W<small>HEN A CERTAIN</small> task is to be performed at several different places in a program, it is usually undesirable to repeat the coding in each place. To avoid this situation, the coding (called a <em>subroutine</em>) can be put into one place only, and a few extra instructions can be added to restart the outer program properly after the subroutine is finished. Transfer of control between subroutines and main programs is called <em>subroutine linkage</em>.</p>
    </div>
  </div>

  <p class="indent">Each machine has its own peculiar manner for achieving efficient subroutine linkage, usually involving special instructions. In <code>MIX</code>, the J-register is used for this purpose; our discussion will be based on <code>MIX</code> machine language, but similar remarks will apply to subroutine linkage on other computers.</p>

  <p class="indent">Subroutines are used to save space in a program; they do not save any time, other than the time implicitly saved by occupying less space — for example, less time to load the program, or fewer passes necessary in the program, or better use of high-speed memory on machines with several grades of memory. The extra time taken to enter and leave a subroutine is usually negligible.</p>

  <p class="indent">Subroutines have several other advantages. They make it easier to visualize the structure of a large and complex program; they form a logical segmentation of the entire problem, and this usually makes debugging of the program easier. Many subroutines have additional value because they can be used by people other than the programmer of the subroutine.</p>

  <p class="indent">Most computer installations have built up a large library of useful subroutines, and such a library greatly facilitates the programming of standard computer applications that arise. A programmer should not think of this as the <em>only</em> purpose of subroutines, however; subroutines should not always be regarded as general-purpose programs to be used by the community. Special-purpose subroutines are just as important, even when they are intended to appear in only one program. <a href="../Text/ch01c.html#ch01lev3sec4">Section 1.4.3.1</a> contains several typical examples.</p>

  <p class="indent">The simplest subroutines are those that have only one entrance and one exit, such as the <code>MAXIMUM</code> subroutine we have already considered (see <a href="../Text/ch01b.html#ch01lev2sec13">Section 1.3.2</a>, <a href="../Text/ch01c.html#ch01c_pro_m">Program M</a>). For reference, we will recopy that program here, changing it so that a fixed number of cells, 100, is searched for the maximum:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-1"></a><img src="../Images/ch01/186equ01.jpg"></div>

  <p><a id="page_187"></a>In a larger program containing this coding as a subroutine, the single instruction ‘<code>JMP MAX100</code>’ would cause register A to be set to the current maximum value of locations <code>X</code> + 1 through <code>X</code> + 100, and the position of the maximum would appear in rI2. Subroutine linkage in this case is achieved by the instructions ‘<code>MAX100 STJ EXIT</code>’ and, later, ‘<code>EXIT JMP</code> *’. Because of the way the J-register operates, the exit instruction will then jump to the location following the place where the original reference to <code>MAX100</code> was made.</p>

  <p><span class="middle"><img src="../Images/ch01/signal.jpg"></span> <em>Newer computers, such as the machine <code>MMIX</code> that is destined to replace <code>MIX</code>, have better ways to remember return addresses. The main difference is that program instructions are no longer modified in memory; the relevant information is kept in registers or in a special array, not within the program itself. (See <a href="../Text/ch01c.html#ch01ex_2_15_7">exercise 7</a>.) The next edition of this book will adopt the modern view, but for now we will stick to the old-time practice of self-modifying code.</em></p>

  <p class="indent">It is not hard to obtain <em>quantitative</em> statements about the amount of code saved and the amount of time lost when subroutines are used. Suppose that a piece of coding requires <em>k</em> locations and that it appears in <em>m</em> places in the program. Rewriting this as a subroutine, we need an extra instruction <code>STJ</code> and an exit line for the subroutine, plus a single <code>JMP</code> instruction in each of the <em>m</em> places where the subroutine is called. This gives a total of <em>m</em> + <em>k</em> + 2 locations, rather than <em>mk</em>, so the amount saved is</p>

  <div class="equation"><a id="ch01eq-lev2sec15-2"></a><img src="../Images/ch01/187equ01.jpg"></div>

  <p>If <em>k</em> is 1 or <em>m</em> is 1 we cannot possibly save any space by using subroutines; this, of course, is obvious. If <em>k</em> is 2, <em>m</em> must be greater than 4 in order to gain, etc.</p>

  <p class="indent">The amount of time lost is the time taken for the extra <code>JMP, STJ,</code> and <code>JMP</code> instructions, which are not present if the subroutine is not used; therefore if the subroutine is used <em>t</em> times during a run of the program, 4<em>t</em> extra cycles of time are required.</p>

  <p class="indent">These estimates must be taken with a grain of salt, because they were given for an idealized situation. Many subroutines cannot be called simply with a single <code>JMP</code> instruction. Furthermore, if the coding is repeated in many parts of a program, without using a subroutine approach, the coding for each part can be customized to take advantage of special characteristics of the particular part of the program in which it lies. With a subroutine, on the other hand, the coding must be written for the most general case, not a specific case, and this will often add several additional instructions.</p>

  <p class="indent">When a subroutine is written to handle a general case, it is expressed in terms of <em>parameters</em>. Parameters are values that govern the subroutine’s actions; they are subject to change from one call of the subroutine to another.</p>

  <p class="indent">The coding in the outside program that transfers control to the subroutine and gets it properly started is known as the <em>calling sequence</em>. Particular values of parameters, supplied when the subroutine is called, are known as <em>arguments</em>. With our <code>MAX100</code> subroutine, the calling sequence is simply ‘<code>JMP MAX100</code>’, but <a id="page_188"></a>a longer calling sequence is generally necessary when arguments must be supplied. For example, <a href="../Text/ch01b.html#ch01b_pro_m">Program 1.3.2M</a> is a generalization of <code>MAX100</code> that finds the maximum of the first <em>n</em> elements of the table. The parameter <em>n</em> appears in index register 1, and its calling sequence</p>

  <div class="image"><img src="../Images/ch01/e188_01.jpg"></div>

  <p>involves two steps.</p>

  <p class="indent">If the calling sequence takes <em>c</em> memory locations, formula (<a href="../Text/ch01c.html#ch01eq-lev2sec15-2">2</a>) for the amount of space saved changes to</p>

  <div class="equation"><a id="ch01eq-lev2sec15-3"></a><img src="../Images/ch01/188equ01.jpg"></div>

  <p>and the time lost for subroutine linkage is slightly increased.</p>

  <p class="indent">A further correction to the formulas above can be necessary because certain registers might need to be saved and restored. For example, in the <code>MAX100</code> subroutine, we must remember that by writing ‘<code>JMP MAX100</code>’ we are not only getting the maximum value in register A and its position in register I2; we are also setting register I3 to zero. A subroutine may destroy register contents, and this must be kept in mind. In order to prevent <code>MAX100</code> from changing the setting of rI3, it would be necessary to include additional instructions. The shortest and fastest way to do this with <code>MIX</code> would be to insert the instruction ‘<code>ST3 3F(0:2</code>)’ just after <code>MAX100</code> and then ‘<code>3H ENT3 *</code>’ just before <code>EXIT</code>. The net cost would be an extra two lines of code, plus three machine cycles on every call of the subroutine.</p>

  <p class="indent">A subroutine may be regarded as an <em>extension</em> of the computer’s machine language. With the <code>MAX100</code> subroutine in memory, we now have a single instruction (namely, ‘<code>JMP MAX100</code>’) that is a maximum-finder. It is important to define the effect of each subroutine just as carefully as the machine language operators themselves have been defined; a programmer should therefore be sure to write down the characteristics of each subroutine, even though nobody else will be making use of the routine or its specification. In the case of <code>MAXIMUM</code> as given in <a href="../Text/ch01b.html#ch01lev2sec13">Section 1.3.2</a>, the characteristics are as follows:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-4"></a><img src="../Images/ch01/188equ02.jpg"></div>

  <p>(We will customarily omit mention of the fact that register J and the comparison indicator are affected by a subroutine; it has been mentioned here only for completeness.) Note that rX and rI1 are unaffected by the action of the subroutine, for otherwise these registers would have been mentioned in the exit conditions. A specification should also mention all memory locations external to the subroutine that might be affected; in this case the specification allows us to conclude that nothing has been stored, since (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>) doesn’t say anything about changes to memory.</p>

  <p class="indent"><a id="page_189"></a>Now let’s consider <em>multiple entrances</em> to subroutines. Suppose we have a program that requires the general subroutine <code>MAXIMUM</code>, but it usually wants to use the special case <code>MAX100</code> in which <em>n</em> = 100. The two can be combined as follows:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-5"></a><img src="../Images/ch01/189equ01.jpg"></div>

  <p>Subroutine (<a href="../Text/ch01c.html#ch01eq-lev2sec15-5">5</a>) is essentially the same as (<a href="../Text/ch01c.html#ch01eq-lev2sec15-1">1</a>), with the first two instructions interchanged; we have used the fact that ‘<code>ENT3</code>’ does not change the setting of the J-register. If we wanted to add a <em>third</em> entrance, <code>MAX50</code>, to this subroutine, we could insert the code</p>

  <div class="equation"><a id="ch01eq-lev2sec15-6"></a><img src="../Images/ch01/189equ02.jpg"></div>

  <p>at the beginning. (Recall that <code>‘JSJ’</code> means jump without changing register J.)</p>

  <p class="indent">When the number of parameters is small, it is often desirable to transmit them to a subroutine either by having them in convenient registers (as we have used rI3 to hold the parameter <em>n</em> in <code>MAXN</code> and as we used rI1 to hold the parameter <em>n</em> in <code>MAXIMUM</code>), or by storing them in fixed memory cells.</p>

  <p class="indent">Another convenient way to supply arguments is simply to list them <em>after</em> the <code>JMP</code> instruction; the subroutine can refer to its parameters because it knows the J-register setting. For example, if we wanted to make the calling sequence for <code>MAXN</code> be</p>

  <div class="equation"><a id="ch01eq-lev2sec15-7"></a><img src="../Images/ch01/189equ03.jpg"></div>

  <p>then the subroutine could be written as follows:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-8"></a><img src="../Images/ch01/189equ04.jpg"></div>

  <p>On machines like System/360, for which linkage is ordinarily done by putting the exit location in an index register, a convention like this is particularly convenient. It is also useful when a subroutine needs many arguments, or when a program has been written by a compiler. The technique of multiple entrances that we used above often fails in this case, however. We could “fake it” by writing</p>

  <div class="image"><img src="../Images/ch01/e189_01.jpg"></div>

  <p>but this is not as attractive as (<a href="../Text/ch01c.html#ch01eq-lev2sec15-5">5</a>).</p>

  <p class="indent"><a id="page_190"></a>A technique similar to that of listing arguments after the jump is normally used for subroutines with <em>multiple exits</em>. Multiple exit means that we want the subroutine to return to one of several different locations, depending on conditions detected by the subroutine. In the strictest sense, the location to which a subroutine exits is a parameter; so if there are several places to which it might exit, depending on the circumstances, they should be supplied as arguments. Our final example of the “maximum” subroutine will have two entrances and two exits. The calling sequence is:</p>

  <div class="image"><img src="../Images/ch01/e190_01.jpg"></div>

  <p>(In other words, exit is made to the location <em>two</em> past the jump when the maximum value is positive and less than the contents of register X.) The subroutine for these conditions is easily written:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-9"></a><img src="../Images/ch01/190equ01.jpg"></div>

  <p class="indent">Subroutines may call on other subroutines; in complicated programs it is not unusual to have subroutine calls nested more than five deep. The only restriction that must be followed when using linkage as described here is that no subroutine may call on any other subroutine that is (directly or indirectly) calling on it. For example, consider the following scenario:</p>

  <div class="equation"><a id="ch01eq-lev2sec15-10"></a><img src="../Images/ch01/190equ02.jpg"></div>

  <p class="indent">If the main program calls on <code>A</code>, which calls <code>B</code>, which calls <code>C</code>, and then <code>C</code> calls on <code>A</code>, the address in <code>EXITA</code> referring to the main program is destroyed, and there is no way to return to that program. A similar remark applies to all temporary storage cells and registers used by each subroutine. It is not difficult to <a id="page_191"></a>devise subroutine linkage conventions that will handle such recursive situations properly; Chapter 8 considers recursion in detail.</p>

  <p class="indent">We conclude this section by discussing briefly how we might go about writing a complex and lengthy program. How can we decide what kind of subroutines we will need, and what calling sequences should be used? One successful way to determine this is to use an iterative procedure:</p>

  <p class="indent"><strong>Step 0</strong> (Initial idea). First we decide vaguely upon the general plan of attack that the program will use.</p>

  <p class="indent"><strong>Step 1</strong> (A rough sketch of the program). We start now by writing the “outer levels” of the program, in any convenient language. A somewhat systematic way to go about this has been described very nicely by E. W. Dijkstra, <em>Structured Programming</em> (Academic Press, 1972), <a href="../Text/ch01.html#ch01">Chapter 1</a>, and by N. Wirth, <em>CACM</em> <strong>14</strong> (1971), 221–227. We may begin by breaking the whole program into a small number of pieces, which might be thought of temporarily as subroutines, although they are called only once. These pieces are successively refined into smaller and smaller parts, having correspondingly simpler jobs to do. Whenever some computational task arises that seems likely to occur elsewhere or that has already occurred elsewhere, we define a subroutine (a real one) to do that job. We do not write the subroutine at this point; we continue writing the main program, assuming that the subroutine has performed its task. Finally, when the main program has been sketched, we tackle the subroutines in turn, trying to take the most complex subroutines first and then their sub-subroutines, etc. In this manner we will come up with a list of subroutines. The actual function of each subroutine has probably already changed several times, so that the first parts of our sketch will by now be incorrect; but that is no problem, it is merely a sketch. For each subroutine we now have a reasonably good idea about how it will be called and how general-purpose it should be. It usually pays to extend the generality of each subroutine a little.</p>

  <p class="indent"><strong>Step 2</strong> (First working program). This step goes in the opposite direction from step 1. We now write in computer language, say <code>MIXAL</code> or <code>PL/MIX</code> or a higher-level language; we start this time with the lowest level subroutines, and do the main program last. As far as possible, we try never to write any instructions that call a subroutine before the subroutine itself has been coded. (In step 1, we tried the opposite, never considering a subroutine until all of its calls had been written.)</p>

  <p class="indent">As more and more subroutines are written during this process, our confidence gradually grows, since we are continually extending the power of the machine we are programming. After an individual subroutine is coded, we should immediately prepare a complete description of what it does, and what its calling sequences are, as in (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>). It is also important not to overlay temporary storage cells; it may very well be disastrous if every subroutine refers to location <code>TEMP</code>, although when preparing the sketch in step 1, it was convenient not to worry about such problems. An obvious way to overcome overlay worries is to have each subroutine use only its own temporary storage, but if this is too wasteful <a id="page_192"></a>of space, another scheme that does fairly well is to name the cells <code>TEMP1</code>, <code>TEMP2</code>, etc.; the numbering within a subroutine starts with <code>TEMP</code><em>j</em>, where <em>j</em> is one higher than the greatest number used by any of the sub-subroutines of this subroutine.</p>

  <p class="indent"><a id="step3"></a><strong>Step 3</strong> (Reexamination). The result of step 2 should be very nearly a working program, but it may be possible to improve on it. A good way is to reverse direction again, studying for each subroutine <em>all</em> of the calls made on it. It may well be that the subroutine should be enlarged to do some of the more common things that are always done by the outside routine just before or after it uses the subroutine. Perhaps several subroutines should be merged into one; or perhaps a subroutine is called only once and should not be a subroutine at all. (Perhaps a subroutine is never called and can be dispensed with entirely.)</p>

  <p class="indent">At this point, it is often a good idea to scrap everything and start over again at step 1! This is not intended to be a facetious remark; the time spent in getting this far has not been wasted, for we have learned a great deal about the problem. With hindsight, we will probably have discovered several improvements that could be made to the program’s overall organization. There’s no reason to be afraid to go back to step 1 — it will be much easier to go through steps 2 and 3 again, now that a similar program has been done already. Moreover, we will quite probably save as much debugging time later on as it will take to rewrite everything. Some of the best computer programs ever written owe much of their success to the fact that all the work was unintentionally lost, at about this stage, and the authors had to begin again.</p>

  <p class="indent">On the other hand, there is probably never a point when a complex computer program cannot be improved somehow, so steps 1 and 2 should not be repeated indefinitely. When significant improvement can clearly be made, it is well worth the additional time required to start over, but eventually a point of diminishing returns is reached.</p>

  <p class="indent"><strong>Step 4</strong> (Debugging). After a final polishing of the program, including perhaps the allocation of storage and other last-minute details, it is time to look at it in still another direction from the three that were used in steps 1, 2, and 3 — now we study the program in the order in which the computer will <em>perform</em> it. This may be done by hand or, of course, by machine. The author has found it quite helpful at this point to make use of system routines that trace each instruction the first two times it is executed; it is important to rethink the ideas underlying the program and to check that everything is actually taking place as expected.</p>

  <p class="indent">Debugging is an art that needs much further study, and the way to approach it is highly dependent on the facilities available at each computer installation. A good start towards effective debugging is often the preparation of appropriate test data. The most effective debugging techniques seem to be those that are designed and built into the program itself — many of today’s best programmers will devote nearly half of their programs to facilitating the debugging process in the other half; the first half, which usually consists of fairly straightforward routines that display relevant information in a readable format, will eventually be thrown away, but the net result is a surprising gain in productivity.</p>

  <p class="indent"><a id="page_193"></a>Another good debugging practice is to keep a record of every mistake made. Even though this will probably be quite embarrassing, such information is invaluable to anyone doing research on the debugging problem, and it will also help you learn how to reduce the number of future errors.</p>

  <p class="indent"><em>Note:</em> The author wrote most of the preceding comments in 1964, after he had successfully completed several medium-sized software projects but before he had developed a mature programming style. Later, during the 1980s, he learned that an additional technique, called <em>structured documentation</em> or <em>literate programming</em>, is probably even more important. A summary of his current beliefs about the best way to write programs of all kinds appears in the book <em>Literate Programming</em> (Cambridge Univ. Press, first published in 1992). Incidentally, Chapter 11 of that book contains a detailed record of all bugs removed from the TeX program during the period 1978–1991.</p>

  <p class="blockquote"><em>Up to a point it is better to let the snags [bugs] be there<br>
  than to spend such time in design that there are none<br>
  (how many decades would this course take?).</em></p>

  <p class="attribution">— A. M. TURING, Proposals for ACE (1945)</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_15_1a" id="ch01ex_2_15_1">1</a>.</strong> [<em>10</em>] State the characteristics of subroutine (<a href="../Text/ch01c.html#ch01eq-lev2sec15-5">5</a>), just as (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>) gives the characteristics of Subroutine <a href="../Text/ch01b.html#ch01b_pro_m">1.3.2M</a>.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_15_2a" id="ch01ex_2_15_2">2</a>.</strong> [<em>10</em>] Suggest code to substitute for (<a href="../Text/ch01c.html#ch01eq-lev2sec15-6">6</a>) without using the <code>JSJ</code> instruction.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_15_3a" id="ch01ex_2_15_3">3</a>.</strong> [<em>M15</em>] Complete the information in (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>) by stating precisely what happens to register J and the comparison indicator as a result of the subroutine; state also what happens if register I1 is not positive.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_15_4a" id="ch01ex_2_15_4">4</a>.</strong> [<em>21</em>] Write a subroutine that generalizes <code>MAXN</code> by finding the maximum value of <code>X[</code><em>a</em><code>]</code>, <code>X[</code><em>a + r</em><code>]</code>, <code>X[</code><em>a</em> + 2<em>r</em><code>]</code>, ..., <code>X[</code><em>n</em><code>]</code>, where <em>r</em> and <em>n</em> are parameters and <em>a</em> is the smallest positive number with <em>a</em> ≡ <em>n</em> (modulo <em>r</em>), namely <em>a</em> = 1 + (<em>n</em> − 1) mod <em>r</em>. Give a special entrance for the case <em>r</em> = 1. List the characteristics of your subroutine, as in (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>).</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_15_5a" id="ch01ex_2_15_5">5</a>.</strong> [<em>21</em>] Suppose <code>MIX</code> did not have a J-register. Invent a means for subroutine linkage that does not use register J, and give an example of your invention by writing a <code>MAX100</code> subroutine effectively equivalent to (<a href="../Text/ch01c.html#ch01eq-lev2sec15-1">1</a>). State the characteristics of this subroutine in a fashion similar to (<a href="../Text/ch01c.html#ch01eq-lev2sec15-4">4</a>). (Retain <code>MIX</code>’s conventions of self-modifying code.)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_15_6a" id="ch01ex_2_15_6">6</a>.</strong> [<em>26</em>] Suppose <code>MIX</code> did not have a <code>MOVE</code> operator. Write a subroutine entitled <code>MOVE</code> such that the calling sequence ‘<code>JMP MOVE; NOP A,I(F)</code>’ has an effect just the same as ‘<code>MOVE A,I(F)</code>’ if the latter were admissible. The only differences should be the effect on register J and the fact that a subroutine naturally consumes more time and space than a hardware instruction does.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_15_7a" id="ch01ex_2_15_7">7</a>.</strong> [<em>20</em>] Why is self-modifying code now frowned on?</p>

  <div class="heading">
    <h4 id="ch01lev2sec16">1.4.2. Coroutines</h4>

    <p>Subroutines are special cases of more general program components, called <em>coroutines</em>. In contrast to the unsymmetric relationship between a main routine and a subroutine, there is complete symmetry between coroutines, which <em>call on each other</em>.</p>
  </div>

  <p class="indent"><a id="page_194"></a>To understand the coroutine concept, let us consider another way of thinking about subroutines. The viewpoint adopted in the previous section was that a subroutine merely was an extension of the computer hardware, introduced to save lines of coding. This may be true, but another point of view is possible: We may consider the main program and the subroutine as a <em>team</em> of programs, each member of the team having a certain job to do. The main program, in the course of doing its job, will activate the subprogram; the subprogram will perform its own function and then activate the main program. We might stretch our imagination to believe that, from the subroutine’s point of view, when it exits <em>it</em> is calling the <em>main</em> routine; the main routine continues to perform its duty, then “exits” to the subroutine. The subroutine acts, then calls the main routine again.</p>

  <p class="indent">This somewhat far-fetched philosophy actually takes place with coroutines, for which it is impossible to distinguish which is a subroutine of the other. Suppose we have coroutines <code>A</code> and <code>B</code>; when programming <code>A</code>, we may think of <code>B</code> as our subroutine, but when programming <code>B</code>, we may think of <code>A</code> as our subroutine. That is, in coroutine <code>A</code>, the instruction ‘<code>JMP B</code>’ is used to activate coroutine <code>B</code>. In coroutine <code>B</code> the instruction ‘<code>JMP A</code>’ is used to activate coroutine <code>A</code> again. Whenever a coroutine is activated, it resumes execution of its program at the point where the action was last suspended.</p>

  <p class="indent">The coroutines <code>A</code> and <code>B</code> might, for example, be two programs that play chess. We can combine them so that they will play against each other.</p>

  <p class="indent">With <code>MIX</code>, such linkage between coroutines <code>A</code> and <code>B</code> is done by including the following four instructions in the program:</p>

  <div class="equation"><a id="ch01eq-lev2sec16-1"></a><img src="../Images/ch01/194equ01.jpg"></div>

  <p>This requires four machine cycles for transfer of control each way. Initially <code>AX</code> and <code>BX</code> are set to jump to the starting places of each coroutine, <code>A1</code> and <code>B1</code>. Suppose we start up coroutine <code>A</code> first, at location <code>A1</code>. When it executes ‘<code>JMP B</code>’ from location <code>A2</code>, say, the instruction in location <code>B</code> stores rJ in <code>AX</code>, which then says ‘<code>JMP A2+1</code>’. The instruction in <code>BX</code> gets us to location <code>B1</code>, and after coroutine <code>B</code> begins its execution, it will eventually get to an instruction ‘<code>JMP A</code>’ in location <code>B2</code>, say. We store rJ in <code>BX</code> and jump to location <code>A2+1</code>, continuing the execution of coroutine <code>A</code> until it again jumps to <code>B</code>, which stores rJ in <code>AX</code> and jumps to <code>B2+1</code>, etc.</p>

  <p class="indent">The essential difference between routine-subroutine and coroutine-coroutine linkage, as can be seen by studying the example above, is that a subroutine is always initiated <em>at its beginning</em>, which is usually a fixed place; the main routine or a coroutine is always initiated <em>at the place following</em> where it last terminated.</p>

  <p class="indent">Coroutines arise most naturally in practice when they are connected with algorithms for input and output. For example, suppose it is the duty of coroutine <code>A</code> to read cards and to perform some transformation on the input, reducing it to a sequence of items. Another coroutine, which we will call <code>B</code>, does further processing of these items, and prints the answers; <code>B</code> will periodically call for the successive input items found by <code>A</code>. Thus, coroutine <code>B</code> jumps to <code>A</code> whenever it <a id="page_195"></a>wants the next input item, and coroutine <code>A</code> jumps to <code>B</code> whenever an input item has been found. The reader may say, “Well, <code>B</code> is the main program and <code>A</code> is merely a <em>subroutine</em> for doing the input.” This, however, becomes less true when the process <code>A</code> is very complicated; indeed, we can imagine <code>A</code> as the main routine and <code>B</code> as a subroutine for doing the output, and the above description remains valid. The usefulness of the coroutine idea emerges midway between these two extremes, when both <code>A</code> and <code>B</code> are complicated and each one calls the other in numerous places. It is rather difficult to find short, simple examples of coroutines that illustrate the importance of the idea; the most useful coroutine applications are generally quite lengthy.</p>

  <p class="indent">In order to study coroutines in action, let us consider a contrived example. Suppose we want to write a program that translates one code into another. The input code to be translated is a sequence of alphameric characters terminated by a period, such as</p>

  <div class="equation"><a id="ch01eq-lev2sec16-2"></a><img src="../Images/ch01/195equ01.jpg"></div>

  <p>This has been punched onto cards; blank columns appearing on these cards are to be ignored. The input is to be understood as follows, from left to right: If the next character is a digit <code>0</code>, <code>1</code>, ..., <code>9</code>, say <em>n</em>, it indicates (<em>n</em> + 1) repetitions of the following character, whether the following character is a digit or not. A nondigit simply denotes itself. The output of our program is to consist of the sequence indicated in this manner and separated into groups of three characters each, until a period appears; the last group may have fewer than three characters. For example, (<a href="../Text/ch01c.html#ch01eq-lev2sec16-2">2</a>) should be translated by our program into</p>

  <div class="equation"><a id="ch01eq-lev2sec16-3"></a><img src="../Images/ch01/195equ02.jpg"></div>

  <p>Note that <code>3426F</code> does not mean 3427 repetitions of the letter <code>F</code>; it means 4 fours and 3 sixes followed by <code>F</code>. If the input sequence is ‘<code>1</code>.’, the output is simply ‘.’, not ‘..’, because the first period terminates the output. Our program should punch the output onto cards, with sixteen groups of three on each card except possibly the last.</p>

  <p class="indent">To accomplish this translation, we will write two coroutines and a subroutine. The subroutine, called <code>NEXTCHAR</code>, is designed to find nonblank characters of the input, and to put the next such character into register A:</p>

  <div class="image"><a id="l195pro01"></a><img src="../Images/ch01/195pro01.jpg"></div>

  <p class="indent">This subroutine has the following characteristics:</p>

  <div class="imageL"><img src="../Images/ch01/p0196_01.jpg"></div>

  <p class="indent">Our first coroutine, called <code>IN</code>, finds the characters of the input code with the proper replication. It begins initially at location <code>IN1</code>:</p>

  <div class="image3"><img src="../Images/ch01/196pro01.jpg"></div>

  <p>(Recall that in <code>MIX</code>’s character code, the digits 0–9 have codes 30–39.) This coroutine has the following characteristics:</p>

  <div class="imageL"><img src="../Images/ch01/p0196_02.jpg"></div>

  <p class="indent">The other coroutine, called <code>OUT</code>, puts the code into three-character groups and punches the cards. It begins initially at <code>OUT1</code>:</p>

  <div class="image"><a id="l196pro02"></a><img src="../Images/ch01/196pro02.jpg"></div>

  <p class="indent"><a id="page_196"></a>This coroutine has the following characteristics:</p>

  <div class="imageL"><a id="page_197"></a><img src="../Images/ch01/p0197_01.jpg"></div>

  <p class="indent">To complete the program, we need to write the coroutine linkage (see (<a href="../Text/ch01c.html#ch01eq-lev2sec16-1">1</a>)) and to provide the proper initialization. Initialization of coroutines tends to be a little tricky, although not really difficult.</p>

  <div class="image3"><img src="../Images/ch01/197pro01.jpg"></div>

  <p class="indent">This completes the program. The reader should study it carefully, noting in particular how each coroutine can be written independently as though the other coroutine were its subroutine.</p>

  <p class="indent"><a id="page_198"></a>The entry and exit conditions for the <code>IN</code> and <code>OUT</code> coroutines mesh perfectly in the program above. In general, we would not be so fortunate, and the coroutine linkage would also include instructions for loading and storing appropriate registers. For example, if <code>OUT</code> would destroy the contents of register A, the coroutine linkage would become</p>

  <div class="equation"><a id="ch01eq-lev2sec16-4"></a><img src="../Images/ch01/198equ01.jpg"></div>

  <p class="indent">There is an important relation between coroutines and <em>multipass algorithms</em>. For example, the translation process we have just described could have been done in two distinct passes: We could first have done just the <code>IN</code> coroutine, applying it to the entire input and writing each character with the proper amount of replication onto magnetic tape. After this was finished, we could rewind the tape and then do just the <code>OUT</code> coroutine, taking the characters from tape in groups of three. This would be called a “two-pass” process. (Intuitively, a “pass” denotes a complete scan of the input. This definition is not precise, and in many algorithms the number of passes taken is not at all clear; but the intuitive concept of “pass” is useful in spite of its vagueness.)</p>

  <p class="indent"><a href="../Text/ch01c.html#ch01fig22">Figure 22(a)</a> illustrates a four-pass process. Quite often we will find that the same process can be done in just one pass, as shown in part (b) of the figure, if we substitute four coroutines <code>A, B, C, D</code> for the respective passes <code>A, B, C, D</code>. Coroutine <code>A</code> will jump to <code>B</code> when pass <code>A</code> would have written an item of output on tape 1; coroutine <code>B</code> will jump to <code>A</code> when pass <code>B</code> would have read an item of input from tape 1, and <code>B</code> will jump to <code>C</code> when pass <code>B</code> would have written an item of output on tape 2; etc. UNIX<sup>®</sup> users will recognize this as a “pipe,” denoted by ‘<code>PassA | PassB | PassC | PassD</code>’. The programs for passes <code>B, C</code>, and <code>D</code> are sometimes referred to as “filters.”</p>

  <div class="image">
    <a id="ch01fig22"></a><img src="../Images/ch01/199fig01.jpg">

    <p class="fig-caption"><strong>Fig. 22.</strong> Passes: (a) a four-pass algorithm, and (b) a one-pass algorithm.</p>
  </div>

  <p class="indent">Conversely, a process done by <em>n</em> coroutines can often be transformed into an <em>n</em>-pass process. Due to this correspondence it is worthwhile to compare multipass algorithms with one-pass algorithms.</p>

  <p class="indenthangingA">a) <em>Psychological difference</em>. A multipass algorithm is generally easier to create and to understand than a one-pass algorithm for the same problem. Breaking a process down into a sequence of small steps that happen one after the other is easier to comprehend than an involved process in which many transformations take place simultaneously.</p>

  <p class="indent">Also, if a very large problem is being tackled and if many people are to co-operate in producing a computer program, a multipass algorithm provides a natural way to divide up the job.</p>

  <p class="indent">These advantages of a multipass algorithm are present in coroutines as well, since each coroutine can be written essentially separate from the others, and the linkage makes an apparently multipass algorithm into a single-pass process.</p>

  <p class="indenthangingA"><a id="page_199"></a>b) <em>Time difference</em>. The time required to pack, write, read, and unpack the intermediate data that flows between passes (for example, the information on tapes in <a href="../Text/ch01c.html#ch01fig22">Fig. 22</a>) is avoided in a one-pass algorithm. For this reason, a one-pass algorithm will be faster.</p>

  <p class="indenthangingA">c) <em>Space difference</em>. The one-pass algorithm requires space to hold all the programs in memory simultaneously, while a multipass algorithm requires space for only one at a time. This requirement may affect the speed, even to a greater extent than indicated in statement (b). For example, many computers have a limited amount of “fast memory” and a larger amount of slower memory; if each pass just barely fits into the fast memory, the result will be considerably faster than if we use coroutines in a single pass (since the use of coroutines would presumably force most of the program to appear in the slower memory or to be repeatedly swapped in and out of fast memory).</p>

  <p class="indent">Occasionally there is a need to design algorithms for several computer configurations at once, some of which have larger memory capacity than others. In such cases it is possible to write the program in terms of coroutines, and to let the memory size govern the number of passes: Load together as many coroutines as feasible, and supply input or output subroutines for the missing links.</p>

  <p class="indent">Although this relationship between coroutines and passes is important, we should keep in mind that coroutine applications cannot always be split into multipass algorithms. If coroutine <code>B</code> gets input from <code>A</code> and also sends back crucial information to <code>A</code>, as in the example of chess play mentioned earlier, the sequence of actions can’t be converted into pass <code>A</code> followed by pass <code>B</code>.</p>

  <p class="indent">Conversely, it is clear that some multipass algorithms cannot be converted to coroutines. Some algorithms are inherently multipass; for example, the second pass may require cumulative information from the first pass (like the total <a id="page_200"></a>number of occurrences of a certain word in the input). There is an old joke worth noting in this regard:</p>

  <p class="uln-indent"><em>Little old lady, riding a bus</em>. “Little boy, can you tell me how to get off at Pasadena Street?”</p>

  <p class="uln-indent"><em>Little boy</em>. “Just watch me, and get off two stops before I do.”</p>

  <p>(The joke is that the little boy gives a two-pass algorithm.)</p>

  <p class="indent">So much for multipass algorithms. We will see further examples of coroutines in numerous places throughout this book, for example, as part of the buffering schemes in <a href="../Text/ch01c.html#ch01lev2sec18">Section 1.4.4</a>. Coroutines also play an important role in discrete system simulation; see <a href="../Text/ch02.html#ch02lev2sec5">Section 2.2.5</a>. The important idea of <em>replicated coroutines</em> is discussed in Chapter 8, and some interesting applications of this idea may be found in Chapter 10.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_16_1a" id="ch01ex_2_16_1">1</a>.</strong> [<em>10</em>] Explain why short, simple examples of coroutines are hard for the author of a textbook to find.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_16_2a" id="ch01ex_2_16_2">2</a>.</strong> [<em>20</em>] The program in the text starts up the <code>OUT</code> coroutine first. What would happen if <code>IN</code> were the first to be executed — that is, if line 60 were changed from ‘<code>JMP OUT1</code>’ to ‘<code>JMP IN1</code>’?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_16_3a" id="ch01ex_2_16_3">3</a>.</strong> [<em>20</em>] True or false: The three ‘<code>CMPA PERIOD</code>’ instructions within <code>OUT</code> may all be omitted, and the program would still work. (Look carefully.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_16_4a" id="ch01ex_2_16_4">4</a>.</strong> [<em>20</em>] Show how coroutine linkage analogous to (<a href="../Text/ch01c.html#ch01eq-lev2sec16-1">1</a>) can be given for real-life computers you are familiar with.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_16_5a" id="ch01ex_2_16_5">5</a>.</strong> [<em>15</em>] Suppose both coroutines <code>IN</code> and <code>OUT</code> want the contents of register A to remain untouched between exit and entry; in other words, assume that wherever the instruction ‘<code>JMP IN</code>’ occurs within <code>OUT</code>, the contents of register A are to be unchanged when control returns to the next line, and make a similar assumption about ‘<code>JMP OUT</code>’ within <code>IN</code>. What coroutine linkage is needed? (Compare with (<a href="../Text/ch01c.html#ch01eq-lev2sec16-4">4</a>).)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_16_6a" id="ch01ex_2_16_6">6</a>.</strong> [<em>22</em>] Give coroutine linkage analogous to (<a href="../Text/ch01c.html#ch01eq-lev2sec16-1">1</a>) for the case of <em>three</em> coroutines, <code>A</code>, <code>B</code>, and <code>C</code>, each of which can jump to either of the other two. (Whenever a coroutine is activated, it begins where it last left off.)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>7.</strong> [<em>30</em>] Write a <code>MIX</code> program that <em>reverses</em> the translation done by the program in the text; that is, your program should convert cards punched like (<a href="../Text/ch01c.html#ch01eq-lev2sec16-3">3</a>) into cards punched like (<a href="../Text/ch01c.html#ch01eq-lev2sec16-2">2</a>). The output should be as short a string of characters as possible, so that the zero before the <code>Z</code> in (<a href="../Text/ch01c.html#ch01eq-lev2sec16-2">2</a>) would not really be produced from (<a href="../Text/ch01c.html#ch01eq-lev2sec16-3">3</a>).</p>

  <div class="heading">
    <h4 id="ch01lev2sec17">1.4.3. Interpretive Routines</h4>

    <p>In this section we will investigate a common type of computer program, the <em>interpretive routine</em> (which will be called <em>interpreter</em> for short). An interpretive routine is a computer program that performs the instructions of another program, where the other program is written in some machine-like language. By a machine-like language, we mean a way of representing instructions, where the instructions typically have operation codes, addresses, etc. (This definition, like most definitions of today’s computer terms, is not precise, nor should it be; we <a id="page_201"></a>cannot draw the line exactly and say just which programs are interpreters and which are not.)</p>
  </div>

  <p class="indent">Historically, the first interpreters were built around machine-like languages designed specially for simple programming; such languages were easier to use than a real machine language. The rise of symbolic languages for programming soon eliminated the need for interpretive routines of that kind, but interpreters have by no means begun to die out. On the contrary, their use has continued to grow, to the extent that an effective use of interpretive routines may be regarded as one of the essential characteristics of modern programming. The new applications of interpreters are made chiefly for the following reasons:</p>

  <p class="indenthangingA">a) a machine-like language is able to represent a complicated sequence of decisions and actions in a compact, efficient manner; and</p>

  <p class="indenthangingA">b) such a representation provides an excellent way to communicate between passes of a multipass process.</p>

  <p class="indent">In such cases, special purpose machine-like languages are developed for use in a particular program, and programs in those languages are often generated only by computers. (Today’s expert programmers are also good machine designers, as they not only create an interpretive routine, they also define a <em>virtual machine</em> whose language is to be interpreted.)</p>

  <p class="indent">The interpretive technique has the further advantage of being relatively machine-independent — only the interpreter must be rewritten when changing computers. Furthermore, helpful debugging aids can readily be built into an interpretive system.</p>

  <p class="indent">Examples of interpreters of type (a) appear in several places later in this series of books; see, for example, the recursive interpreter in Chapter 8 and the “Parsing Machine” in Chapter 10. We typically need to deal with a situation in which a great many special cases arise, all similar, but having no really simple pattern.</p>

  <p class="indent">For example, consider writing an algebraic compiler in which we want to generate efficient machine-language instructions that add two quantities together. There might be ten classes of quantities (constants, simple variables, temporary storage locations, subscripted variables, the contents of an accumulator or index register, fixed or floating point, etc.) and the combination of all pairs yields 100 different cases. A long program would be required to do the proper thing in each case. The interpretive solution to this problem is to make up an ad hoc language whose “instructions” fit in one byte. Then we simply prepare a table of 100 “programs” in this language, where each program ideally fits in a single word. The idea is then to pick out the appropriate table entry and to perform the program found there. This technique is simple and efficient.</p>

  <p class="indent">An example interpreter of type (b) appears in the article “Computer-Drawn Flowcharts” by D. E. Knuth, <em>CACM</em> <strong>6</strong> (1963), 555–563. In a multipass program, the earlier passes must transmit information to the later passes. This information is often transmitted most efficiently in a machine-like language, as a set of instructions for the later pass; the later pass is then nothing but a special purpose <a id="page_202"></a>interpretive routine, and the earlier pass is a special purpose “compiler.” This philosophy of multipass operation may be characterized as <em>telling</em> the later pass what to do, whenever possible, rather than simply presenting it with a lot of facts and asking it to <em>figure out</em> what to do.</p>

  <p class="indent">Another example of a type-(b) interpreter occurs in connection with compilers for special languages. If the language includes many features that are not easily done on the machine except by subroutine, the resulting object programs will be very long sequences of subroutine calls. This would happen, for example, if the language were concerned primarily with multiple-precision arithmetic. In such a case the object program would be considerably shorter if it were expressed in an interpretive language. See, for example, the book <em>ALGOL 60 Implementation</em>, by B. Randell and L. J. Russell (New York: Academic Press, 1964), which describes a compiler to translate from ALGOL 60 into an interpretive language, and which also describes the interpreter for that language; and see “An ALGOL 60 Compiler,” by Arthur Evans, Jr., <em>Ann. Rev. Auto. Programming</em> <strong>4</strong> (1964), 87–124, for examples of interpretive routines used <em>within</em> a compiler. The rise of microprogrammed machines and of special-purpose integrated circuit chips has made this interpretive approach even more valuable.</p>

  <p class="indent">The TeX program, which produced the pages of the book you are now reading, converted a file that contained the text of this section into an interpretive language called <code>DVI</code> format, designed by D. R. Fuchs in 1979. [See D. E. Knuth, <em>TeX: The Program</em> (Reading, Mass.: Addison–Wesley, 1986), Part 31.] The <code>DVI</code> file that TeX produced was then processed by an interpreter called <code>dvips</code>, written by T. G. Rokicki, and converted to a file of instructions in another interpretive language called PostScript <sup>®</sup> [Adobe Systems Inc., <em>PostScript Language Reference Manual</em>, 2nd edition (Reading, Mass.: Addison–Wesley, 1990)]. The PostScript file was sent to the publisher, who sent it to a commercial printer, who used a PostScript interpreter to produce printing plates. This three-pass operation illustrates interpreters of type (b); TeX itself also includes a small interpreter of type (a) to process the so-called ligature and kerning information for characters of each font of type [<em>TeX: The Program</em>, §545].</p>

  <p class="indent">There is another way to look at a program written in interpretive language: It may be regarded as a series of subroutine calls, one after another. Such a program may in fact be expanded into a long sequence of calls on subroutines, and, conversely, such a sequence can usually be packed into a coded form that is readily interpreted. The advantages of interpretive techniques are the compactness of representation, the machine independence, and the increased diagnostic capability. An interpreter can often be written so that the amount of time spent in interpretation of the code itself and branching to the appropriate routine is negligible.</p>

  <div class="heading">
    <h5 id="ch01lev3sec4">1.4.3.1. A <span class="EmpStrong">MIX</span> simulator</h5>

    <p>When the language presented to an interpretive routine is the machine language of another computer, the interpreter is often called a <em>simulator</em> (or sometimes an <em>emulator</em>).</p>
  </div>

  <p class="indent">In the author’s opinion, entirely too much programmers’ time has been spent in writing such simulators and entirely too much computer time has been <a id="page_203"></a>wasted in using them. The motivation for simulators is simple: A computer installation buys a new machine and still wants to run programs written for the old machine (rather than rewriting the programs). However, this usually costs more and gives poorer results than if a special task force of programmers were given temporary employment to do the reprogramming. For example, the author once participated in such a reprogramming project, and a serious error was discovered in the original program, which had been in use for several years; the new program worked at five times the speed of the old, besides giving the right answers for a change! (Not all simulators are bad; for example, it is usually advantageous for a computer manufacturer to simulate a new machine before it has been built, so that software for the new machine may be developed as soon as possible. But that is a very specialized application.) An extreme example of the inefficient use of computer simulators is the true story of machine <em>A</em> simulating machine <em>B</em> running a program that simulates machine <em>C</em> ! This is the way to make a large, expensive computer give poorer results than its cheaper cousin.</p>

  <p class="indent">In view of all this, why should such a simulator rear its ugly head in this book? There are two reasons:</p>

  <p class="indenthangingA">a) The simulator we will describe below is a good example of a typical interpretive routine; the basic techniques employed in interpreters are illustrated here. It also illustrates the use of subroutines in a moderately long program.</p>

  <p class="indenthangingA">b) We will describe a simulator of the <code>MIX</code> computer, written in (of all things) the <code>MIX</code> language. This will facilitate the writing of <code>MIX</code> simulators for most computers, which are similar; the coding of our program intentionally avoids making heavy use of <code>MIX</code>-oriented features. A <code>MIX</code> simulator will be of advantage as a teaching aid in conjunction with this book and possibly others.</p>

  <p class="indent">Computer simulators as described in this section should be distinguished from <em>discrete system simulators</em>. Discrete system simulators are important programs that will be discussed in <a href="../Text/ch02.html#ch02lev2sec5">Section 2.2.5</a>.</p>

  <p class="indent">Now let’s turn to the task of writing a <code>MIX</code> simulator. The input to our program will be a sequence of <code>MIX</code> instructions and data, stored in locations 0000–3499. We want to mimic the precise behavior of <code>MIX</code>’s hardware, pretending that <code>MIX</code> itself is interpreting those instructions; thus, we want to implement the specifications that were laid down in <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>. Our program will, for example, maintain a variable called <code>AREG</code> that will hold the magnitude of the simulated A-register; another variable, <code>SIGNA</code>, will hold the corresponding sign. A variable called <code>CLOCK</code> will record how many <code>MIX</code> units of simulated time have elapsed during the simulated program execution.</p>

  <p class="indent">The numbering of <code>MIX</code>’s instructions <code>LDA, LD1, ..., LDX</code> and other similar commands suggests that we keep the simulated contents of these registers in consecutive locations, as follows:</p>

  <p class="center"><code>AREG, I1REG, I2REG, I3REG, I4REG, I5REG, I6REG, XREG, JREG, ZERO.</code></p>

  <p>Here <code>ZERO</code> is a “register” filled with zeros at all times. The positions of <code>JREG</code> and <code>ZERO</code> are suggested by the op-code numbers of the instructions <code>STJ</code> and <code>STZ</code>.</p>

  <p class="indent"><a id="page_204"></a>In keeping with our philosophy of writing the simulator as though it were not really done with <code>MIX</code> hardware, we will treat the signs as independent parts of a register. For example, many computers cannot represent the number “minus zero”, while <code>MIX</code> definitely can; therefore we will always treat signs specially in this program. The locations <code>AREG, I1REG, ..., ZERO</code> will always contain the absolute values of the corresponding register contents; another set of locations in our program, called <code>SIGNA, SIGN1, ..., SIGNZ</code> will contain +1 or −1, depending on whether the sign of the corresponding register is plus or minus.</p>

  <p class="indent">An interpretive routine generally has a central control section that is called into action between interpreted instructions. In our case, the program transfers to location <code>CYCLE</code> at the end of each simulated instruction.</p>

  <p class="indent">The control routine does the things common to all instructions, unpacks the instruction into its various parts, and puts the parts into convenient places for later use. The program below sets</p>

  <p class="uln-indent">&nbsp;&nbsp;<code>rI6</code> = location of the next instruction;</p>

  <p class="uln-indent">&nbsp;&nbsp;<code>rI5</code> = M (address of the present instruction, plus indexing);</p>

  <p class="uln-indent">&nbsp;&nbsp;<code>rI4</code> = operation code of the present instruction;</p>

  <p class="uln-indent">&nbsp;&nbsp;<code>rI3</code> = F-field of the present instruction;</p>

  <p class="uln-indent"><code>INST</code> = the present instruction.</p>

  <p><a id="ch01c_pro_m"></a><strong>Program M.</strong></p>

  <div class="image3"><img src="../Images/ch01/204pro01.jpg"></div>

  <div class="image3"><img src="../Images/ch01/204pro01a.jpg"></div>

  <p class="indent"><a id="page_205"></a>The reader’s attention is called particularly to lines 034–036: A “switching table” of the 64 operators is part of the simulator, allowing it to jump rapidly to the correct routine for the current instruction. This is an important time-saving technique (see <a href="../Text/ch01b.html#ch01lev2sec13">exercise 1.3.2</a>–<a href="../Text/ch01c.html#ch01ex_2_18_9">9</a>).</p>

  <p class="indent">The 64-word switching table, called <code>OPTABLE</code>, gives also the execution time for the various operators; the following lines indicate the contents of that table:</p>

  <div class="image3"><img src="../Images/ch01/205pro01.jpg"></div>

  <div class="image3"><img src="../Images/ch01/205pro01a.jpg"></div>

  <p><a id="page_206"></a>(The entries for operators <code>LD<em>i</em>, LD<em>i</em>N,</code> and <code>INC<em>i</em></code> have an additional ‘<code>,1</code>’ to set the (3:3) field nonzero; this is used below in lines 289–290 to indicate the fact that the size of the quantity within the corresponding index register must be checked after simulating these operations.)</p>

  <p class="indent">The next part of our simulator program merely lists the locations used to contain the contents of the simulated registers:</p>

  <div class="image3"><img src="../Images/ch01/206pro01.jpg"></div>

  <p class="indent">Now we will consider three subroutines used by the simulator. First comes the <code>MEMORY</code> subroutine:</p>

  <div class="imageL"><img src="../Images/ch01/p0206_01.jpg"></div>

  <div class="image3"><img src="../Images/ch01/206pro_02.jpg"></div>

  <p class="indent"><a id="page_207"></a>The <code>FCHECK</code> subroutine processes a partial field specification, making sure that it has the form 8L + R with L ≤ R ≤ 5.</p>

  <div class="imageL"><img src="../Images/ch01/p0207_01.jpg"></div>

  <div class="image3"><img src="../Images/ch01/207pro01.jpg"></div>

  <p class="indent">The last subroutine, <code>GETV,</code> finds the quantity V (namely, the appropriate field of location M) used in various <code>MIX</code> operators, as defined in <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>.</p>

  <div class="imageL"><img src="../Images/ch01/p0207_02.jpg"></div>

  <div class="image3"><img src="../Images/ch01/207pro02.jpg"></div>

  <p class="indent">Now we come to the routines for each individual operator. These routines are given here for completeness, but the reader should study only a few of them unless there’s a compelling reason to look closer; the <code>SUB</code> and <code>JUMP</code> operators are recommended as typical examples for study. Notice the way in which routines <a id="page_208"></a>for similar operations can be neatly combined, and notice how the <code>JUMP</code> routine uses another switching table to govern the type of jump.</p>

  <div class="image"><img src="../Images/ch01/208pro01.jpg"></div>

  <div class="image"><img src="../Images/ch01/208pro01a.jpg"></div>

  <div class="image"><a id="page_209"></a><img src="../Images/ch01/208pro01b.jpg"></div>

  <div class="image"><img src="../Images/ch01/208pro01c.jpg"></div>

  <div class="image"><a id="page_210"></a><img src="../Images/ch01/208pro01d.jpg"></div>

  <div class="image"><img src="../Images/ch01/208pro01e.jpg"></div>

  <p class="indent"><a id="page_211"></a>The code above adheres to a subtle rule that was stated in <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>: The instruction ‘<code>ENTA -0</code>’ loads minus zero into register A, as does <code>‘ENTA -5,1’</code> when index register 1 contains +5. In general, when <code>M</code> is zero, <code>ENTA</code> loads the sign of the instruction and <code>ENNA</code> loads the opposite sign. The need to specify this condition was overlooked when the author prepared his first draft of <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>; such questions usually come to light only when a computer program is being written to follow the rules.</p>

  <p class="indent">In spite of its length, the program above is incomplete in several respects:</p>

  <p class="indenthangingA">a) It does not recognize floating point operations.</p>

  <p class="indenthangingA">b) The coding for operation codes 5, 6, and 7 has been left as an exercise.</p>

  <p class="indenthangingA">c) The coding for input-output operators has been left as an exercise.</p>

  <p class="indenthangingA">d) No provision has been made for loading simulated programs (see <a href="../Text/ch01c.html#ch01ex_3_4_4">exercise 4</a>).</p>

  <p class="indenthangingA">e) The error routines</p>

  <p class="center"><code>INDEXERROR, ADDRERROR, OPERROR, MEMERROR, FERROR, SIZEERROR</code></p>

  <p class="indenthangingAPP">have not been included; they handle error conditions that are detected in the simulated program.</p>

  <p class="indenthangingA">f) There is no provision for diagnostic facilities. (A useful simulator should, for example, make it possible to print out the register contents as a program is being executed.)</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_4_1a" id="ch01ex_3_4_1">1</a>.</strong> [<em>14</em>] Study all the uses of the <code>FCHECK</code> subroutine in the simulator program. Can you suggest a better way to organize the code? (See <a href="../Text/ch01c.html#step3">step 3</a> in the discussion at the end of <a href="../Text/ch01c.html#ch01lev2sec15">Section 1.4.1</a>.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_4_2a" id="ch01ex_3_4_2">2</a>.</strong> [<em>20</em>] Write the <code>SHIFT</code> routine, which is missing from the program in the text (operation code 6).</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong>3.</strong> [<em>22</em>] Write the <code>MOVE</code> routine, which is missing from the program in the text (operation code 7).</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_4_4a" id="ch01ex_3_4_4">4</a>.</strong> [<em>14</em>] Change the program in the text so that it begins as though <code>MIX</code>’s “<code>GO</code> button” had been pushed (see exercise <a href="../Text/ch01b.html#ch01lev2sec12">1.3.1</a>–<a href="../Text/ch01b.html#ch01ex_2_12_26">26</a>).</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_3_4_5a" id="ch01ex_3_4_5">5</a>.</strong> [<em>24</em>] Determine the time required to simulate the <code>LDA</code> and <code>ENTA</code> operators, compared with the actual time for <code>MIX</code> to execute these operators directly.</p>

  <p class="exercises"><strong>6.</strong> [<em>28</em>] Write programs for the input-output operators <code>JBUS, IOC, IN, OUT</code>, and <code>JRED</code>, which are missing from the program in the text, allowing only units 16 and 18. Assume <a id="page_212"></a>that the operations “read-card” and “skip-to-new-page” take <em>T</em> = 10000<em>u</em>, while “printline” takes <em>T</em> = 7500<em>u</em>. [<em>Note:</em> Experience shows that the <code>JBUS</code> instruction should be simulated by treating ‘<code>JBUS</code> *’ as a special case; otherwise the simulator seems to stop!]</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_3_4_7a" id="ch01ex_3_4_7">7</a>.</strong> [<em>32</em>] Modify the solutions of the previous exercise in such a way that execution of <code>IN</code> or <code>OUT</code> does not cause I/O transmission immediately; the transmission should take place after approximately half of the time required by the simulated devices has elapsed. (This will prevent a frequent student error, in which <code>IN</code> and <code>OUT</code> are used improperly.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_4_8a" id="ch01ex_3_4_8">8</a>.</strong> [<em>20</em>] True or false: Whenever line 010 of the simulator program is executed, we have 0 ≤ rI6 &lt; <code>BEGIN</code>.</p>

  <div class="heading">
    <h5 id="ch01lev3sec5">*1.4.3.2. Trace routines</h5>

    <p>When a machine is being simulated on itself (as <code>MIX</code> was simulated on <code>MIX</code> in the previous section) we have the special case of a simulator called a <em>trace</em> or <em>monitor</em> routine. Such programs are occasionally used to help in debugging, since they print out a step-by-step account of how the simulated program behaves.</p>
  </div>

  <p class="indent">The program in the preceding section was written as though another computer were simulating <code>MIX</code>. A quite different approach is used for trace programs; we generally let registers represent themselves and let the operators perform themselves. In fact, we usually contrive to let the machine execute most of the instructions by itself. The chief exception is a jump or conditional jump instruction, which must not be executed without modification, since the trace program must remain in control. Each machine also has idiosyncratic features that make tracing more of a challenge; in <code>MIX</code>’s case, the J-register presents the most interesting problem.</p>

  <p class="indent">The trace routine given below is initiated when the main program jumps to location <code>ENTER</code>, with register J set to the address for <em>starting</em> to trace and register X set to the address where tracing should <em>stop</em>. The program is interesting and merits careful study.</p>

  <div class="image3"><img src="../Images/ch01/212pro01.jpg"></div>

  <div class="image3"><img src="../Images/ch01/212pro01a.jpg"></div>

  <p class="indent"><a id="page_213"></a>The following things should be noted about trace routines in general and this one in particular.</p>

  <p class="indent">1) We have presented only the most interesting part of a trace program, the part that retains control while executing another program. For a trace to be useful, there must also be a routine for writing out the contents of registers, and this has not been included. Such a routine distracts from the more subtle features of a trace program, although it certainly is important; the necessary modifications are left as an exercise (see <a href="../Text/ch01c.html#ch01ex_3_5_2">exercise 2</a>).</p>

  <p class="indent">2) Space is generally more important than time; that is, the program should be written to be as short as possible. Then the trace routine will be able to coexist with extremely large programs. The running time is consumed by output anyway.</p>

  <p class="indent">3) Care was taken to avoid destroying the contents of most registers; in fact, the program uses only <code>MIX</code>’s A-register. Neither the comparison indicator nor <a id="page_214"></a>the overflow toggle are affected by the trace routine. (The less we use, the less we need to restore.)</p>

  <p class="indent">4) When a jump to location <code>JUMP</code> occurs, it is not necessary to <code>‘STA AREG’</code>, since rA cannot have changed.</p>

  <p class="indent">5) After leaving the trace routine, the J-register is not reset properly. <a href="../Text/ch01c.html#ch01ex_3_5_1">Exercise 1</a> shows how to remedy this.</p>

  <p class="indent">6) The program being traced is subject to only three restrictions:</p>

  <p class="indenthangingAA">a) It must not store anything into the locations used by the trace program.</p>

  <p class="indenthangingAA">b) It must not use the output device on which tracing information is being recorded (for example, <code>JBUS</code> would give an improper indication).</p>

  <p class="indenthangingAA">c) It will run at a slower speed while being traced.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_5_1a" id="ch01ex_3_5_1">1</a>.</strong> [<em>22</em>] Modify the trace routine of the text so that it restores register J when leaving. (You may assume that register J is not zero.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_5_2a" id="ch01ex_3_5_2">2</a>.</strong> [<em>26</em>] Modify the trace routine of the text so that before executing each program step it writes the following information on tape unit 0.</p>

  <p class="uln-indent1">Word 1, (0 : 2) field: location.</p>

  <p class="uln-indent1">Word 1, (4 : 5) field: register J (before execution).</p>

  <p class="uln-indent1">Word 1, (3 : 3) field: 2 if comparison is greater, 1 if equal, 0 if less; plus 8 if overflow is not on before execution.</p>

  <p class="uln-indent1">Word 2: instruction.</p>

  <p class="uln-indent1">Word 3: register A (before execution).</p>

  <p class="uln-indent1">Words 4–9: registers I1–I6 (before execution).</p>

  <p class="uln-indent1">Word 10: register X (before execution).</p>

  <p class="exercisesp">Words 11–100 of each 100-word tape block should contain nine more ten-word groups, in the same format.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_3_5_3a" id="ch01ex_3_5_3">3</a>.</strong> [<em>10</em>] The previous exercise suggests having the trace program write its output onto tape. Discuss why this would be preferable to printing directly.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_3_5_4a" id="ch01ex_3_5_4">4</a>.</strong> [<em>25</em>] What would happen if the trace routine were tracing <em>itself</em> ? Specifically, consider the behavior if the two instructions <code>ENTX LEAVEX; JMP *+1</code> were placed just before <code>ENTER</code>.</p>

  <p class="exercises"><strong>5.</strong> [<em>28</em>] In a manner similar to that used to solve the previous exercise, consider the situation in which two copies of the trace routine are placed in different places in memory, and each is set up to trace the other. What would happen?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_3_5_6a" id="ch01ex_3_5_6">6</a>.</strong> [<em>40</em>] Write a trace routine that is capable of tracing itself, in the sense of <a href="../Text/ch01c.html#ch01ex_3_5_4">exercise 4</a>: It should print out the steps of its own program at slower speed, and <em>that</em> program will be tracing itself at still <em>slower</em> speed, ad infinitum, until memory capacity is exceeded.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_3_5_7a" id="ch01ex_3_5_7">7</a>.</strong> [<em>25</em>] Discuss how to write an efficient <em>jump trace</em> routine, which emits much less output than a normal trace. Instead of displaying the register contents, a jump trace simply records the jumps that occur. It outputs a sequence of pairs (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>), (<em>x</em><sub>2</sub>, <em>y</em><sub>2</sub>), ..., meaning that the program jumped from location <em>x</em><sub>1</sub> to <em>y</em><sub>1</sub>, then (after performing the instructions in locations <em>y</em><sub>1</sub>, <em>y</em><sub>1</sub> + 1, ..., <em>x</em><sub>2</sub>) it jumped from <em>x</em><sub>2</sub> to <em>y</em><sub>2</sub>, etc. [From this information it is possible for a subsequent routine to reconstruct the flow of the program and to deduce how frequently each instruction was performed.]</p>

  <div class="heading">
    <h4 id="ch01lev2sec18"><a id="page_215"></a>1.4.4. Input and Output</h4>

    <p>Perhaps the most outstanding differences between one computer and the next are the facilities available for doing input and output, and the computer instructions that govern those peripheral devices. We cannot hope to discuss in a single book all of the problems and techniques that arise in this area, so we will confine ourselves to a study of typical input-output methods that apply to most computers. The input-output operators of <code>MIX</code> represent a compromise between the widely varying facilities available in actual machines; to give an example of how to think about input-output, let us discuss in this section the problem of getting the best <code>MIX</code> input-output.</p>
  </div>

  <p><span class="middle"><img src="../Images/ch01/signal.jpg"></span> <em>Once again the reader is asked to be indulgent about the anachronistic <span class="EmpItalic">MIX</span> computer with its punched cards, etc. Although such old-fashioned devices are now quite obsolete, they still can teach important lessons. The <span class="EmpItalic">MMIX</span> computer, when it comes, will of course teach those lessons even better.</em></p>

  <p class="indent">Many computer users feel that input and output are not actually part of “real” programming; input and output are considered to be tedious tasks that people must perform only because they need to get information in and out of a machine. For this reason, the input and output facilities of a computer are usually not learned until after all other features have been examined, and it frequently happens that only a small fraction of the programmers of a particular machine ever know much about the details of input and output. This attitude is somewhat natural, because the input-output facilities of machines have never been especially pretty. However, the situation cannot be expected to improve until more people give serious thought to the subject. We shall see in this section and elsewhere (for example, in Section 5.4.6) that some very interesting issues arise in connection with input-output, and some pleasant algorithms do exist.</p>

  <p class="indent">A brief digression about terminology is perhaps appropriate here. Although dictionaries of English formerly listed the words “input” and “output” only as nouns (“What kind of input are we getting?”), it is now customary to use them grammatically as adjectives (“Don’t drop the input tape.”) and as transitive verbs (“Why did the program output this garbage?”). The combined term “input-output” is most frequently referred to by the abbreviation “I/O”. Inputting is often called <em>reading</em>, and outputting is, similarly, called <em>writing</em>. The stuff that is input or output is generally known as “data” — this word is, strictly speaking, a plural form of the word “datum,” but it is used collectively as if it were singular (“The data has not been read.”), just as the word “information” is both singular and plural. This completes today’s English lesson.</p>

  <p class="indent">Suppose now that we wish to read from magnetic tape. The <code>IN</code> operator of <code>MIX</code>, as defined in <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>, merely <em>initiates</em> the input process, and the computer continues to execute further instructions while the input is taking place. Thus the instruction ‘<code>IN 1000(5)</code>’ will begin to read 100 words from tape unit number 5 into memory cells 1000–1099, but the ensuing program must not refer to these memory cells until later. The program can assume that input is complete only after (a) another I/O operation (<code>IN, OUT, or IOC</code>) referring to unit 5 <a id="page_216"></a>has been initiated, or (b) a conditional jump instruction <code>JBUS(5)</code> or <code>JRED(5)</code> indicates that unit 5 is no longer “busy.”</p>

  <p class="indent">The simplest way to read a tape block into locations 1000–1099 and to have the information present is therefore the sequence of two instructions</p>

  <div class="equation"><a id="ch01eq-lev2sec18-1"></a><img src="../Images/ch01/216equ01.jpg"></div>

  <p>We have used this rudimentary method in the program of <a href="../Text/ch01c.html#ch01lev2sec16">Section 1.4.2</a> (see lines <a href="../Text/ch01c.html#l195pro01">07–08</a> and <a href="../Text/ch01c.html#l196pro02">52–53</a>). The method is generally wasteful of computer time, however, because a very large amount of potentially useful calculating time, say 1000<em>u</em> or even 10000<em>u</em>, is consumed by repeated execution of the <code>‘JBUS’</code> instruction. The program’s running speed can be as much as doubled if this additional time is utilized for calculation. (See <a href="../Text/ch01c.html#ch01ex_2_18_4">exercises 4</a> and <a href="../Text/ch01c.html#ch01ex_2_18_5">5</a>.)</p>

  <p class="indent">One way to avoid such a “busy wait” is to use two areas of memory for the input: We can read into one area while computing with the data in the other. For example, we could begin our program with the instruction</p>

  <div class="equation"><a id="ch01eq-lev2sec18-2"></a><img src="../Images/ch01/216equ02.jpg"></div>

  <p>Subsequently, we may give the following five commands whenever a tape block is desired:</p>

  <div class="equation"><a id="ch01eq-lev2sec18-3"></a><img src="../Images/ch01/216equ03.jpg"></div>

  <p>This has the same overall effect as (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>), but it keeps the input tape busy while the program works on the data in locations 1000–1099.</p>

  <p class="indent">The last instruction of (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) begins to read a tape block into locations 2000– 2099 before the preceding block has been examined. This is called “reading ahead” or <em>anticipated input</em> — it is done on faith that the block will eventually be needed. In fact, however, we might discover that no more input is really required, after we begin to examine the block in 1000–1099. For example, consider the analogous situation in the coroutine program of <a href="../Text/ch01c.html#ch01lev2sec16">Section 1.4.2</a>, where the input was coming from punched cards instead of tape: A ‘.’ appearing anywhere in the card meant that it was the final card of the deck. Such a situation would make anticipated input impossible, unless we could assume that either (a) a blank card or special trailer card of some other sort would follow the input deck, or (b) an identifying mark (e.g., ‘.’) would appear in, say, column 80 of the final card of the deck. Some means for terminating the input properly at the end of the program must always be provided whenever input has been anticipated.</p>

  <p class="indent">The technique of overlapping computation time and I/O time is known as <em>buffering</em>, while the rudimentary method (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>) is called <em>unbuffered</em> input. The area of memory 2000–2099 used to hold the anticipated input in (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>), as well as the area 1000–1099 to which the input was moved, is called a <em>buffer</em>. Webster’s New World Dictionary defines “buffer” as “any person or thing that serves to lessen shock,” and the term is appropriate because buffering tends to keep I/O <a id="page_217"></a>devices running smoothly. (Computer engineers often use the word “buffer” in another sense, to denote a part of the I/O device that stores information during the transmission. In this book, however, “buffer” will signify an area of <em>memory</em> used by a programmer to hold I/O data.)</p>

  <p class="indent">The sequence (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) is not always superior to (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>), although the exceptions are rare. Let us compare the execution times: Suppose <em>T</em> is the time required to input 100 words, and suppose <em>C</em> is the computation time that intervenes between input requests. Method (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>) requires a time of essentially <em>T</em> + <em>C</em> per tape block, while method (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) takes essentially max(<em>C, T</em>) + 202<em>u</em>. (The quantity 202<em>u</em> is the time required by the two <code>MOVE</code> instructions.) One way to look at this running time is to consider “critical path time” — in this case, the amount of time the I/O unit is idle between uses. Method (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>) keeps the unit idle for <em>C</em> units of time, while method (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) keeps it idle for 202 units (assuming that <em>C &lt; T</em>).</p>

  <p class="indent">The relatively slow <code>MOVE</code> commands of (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) are undesirable, particularly because they take up critical path time when the tape unit must be inactive. An almost obvious improvement of the method allows us to avoid these <code>MOVE</code> instructions: The outside program can be revised so that it refers alternately to locations 1000–1099 and 2000–2099. While we are reading into one buffer area, we can be computing with the information in the other; then we can begin reading into the second buffer while computing with the information in the first. This is the important technique known as <em>buffer swapping</em>. The location of the current buffer of interest will be kept in an index register (or, if no index registers are available, in a memory location). We have already seen an example of buffer swapping applied to output in <a href="../Text/ch01b.html#ch01alg-lev2sec13-P">Algorithm 1.3.2P</a> (see steps <a href="../Text/ch01b.html#ch01p09">P9–P11</a>) and the accompanying program.</p>

  <p class="indent">As an example of buffer swapping on input, suppose that we have a computer application in which each tape block consists of 100 separate one-word items. The following program is a subroutine that gets the next word of input and begins to read in a new block if the current one is exhausted.</p>

  <div class="equation"><a id="ch01eq-lev2sec18-4"></a><img src="../Images/ch01/217equ01.jpg"></div>

  <p>In this routine, index register 6 is used to address the last word of input; we assume that the calling program does not affect this register. The symbol <code>U</code> <a id="page_218"></a>refers to a tape unit, and the symbol <code>SENTINEL</code> refers to a value that is known (from characteristics of the program) to be <em>absent</em> from all tape blocks.</p>

  <p class="indent">Several things about this subroutine should be noted:</p>

  <p class="indent">1) The sentinel constant appears as the 101st word of each buffer, and it makes a convenient test for the end of the buffer. In many applications, however, the sentinel technique will not be reliable, since any word may appear on tape. If we were doing card input, a similar method (with the 17th word of the buffer equal to a sentinel) could always be used without fear of failure; in that case, any negative word could serve as a sentinel, since <code>MIX</code> input from cards always gives nonnegative words.</p>

  <p class="indent">2) Each buffer contains the address of the other buffer (see lines 07, 11, and 14). This “linking together” facilitates the swapping process.</p>

  <p class="indent">3) No <code>JBUS</code> instruction was necessary, since the next input was initiated before any word of the previous block was accessed. If the quantities <em>C</em> and <em>T</em> refer as before to computation time and tape time, the execution time per tape block is now max (<em>C, T</em>); it is therefore possible to keep the tape going at full speed if <em>C ≤ T</em>. (<em>Note</em>: <code>MIX</code> is an idealized computer in this regard, however, since no I/O errors must be treated by the program. On most machines some instructions to test the successful completion of the previous operation would be necessary just before the <code>‘IN’</code> instruction here.)</p>

  <p class="indent">4) To make subroutine (<a href="../Text/ch01c.html#ch01eq-lev2sec18-4">4</a>) work properly, it will be necessary to get things started out right when the program begins. Details are left to the reader (see <a href="../Text/ch01c.html#ch01ex_2_18_6">exercise 6</a>).</p>

  <p class="indent">5) The <code>WORDIN</code> subroutine makes the tape unit appear to have a block length of 1 rather than 100 as far as the rest of the program is concerned. The idea of having several program-oriented records filling a single actual tape block is called <em>blocking of records</em>.</p>

  <p class="indent">The techniques that we have illustrated for input apply, with minor changes, to output as well (see <a href="../Text/ch01c.html#ch01ex_2_18_2">exercises 2</a> and <a href="../Text/ch01c.html#ch01ex_2_18_3">3</a>).</p>

  <p><strong>Multiple buffers.</strong> Buffer swapping is just the special case <em>N</em> = 2 of a general method involving <em>N</em> buffers. In some applications it is desirable to have more than two buffers; for example, consider the following type of algorithm:</p>

  <p class="uln-indent"><a id="page_219"></a><strong>Step 1.</strong> Read five blocks in rapid succession.</p>

  <p class="uln-indent"><strong>Step 2.</strong> Perform a fairly long calculation based on this data.</p>

  <p class="uln-indent"><strong>Step 3.</strong> Return to step 1.</p>

  <p>Here five or six buffers would be desirable, so that the next batch of five blocks could be read during step 2. This tendency for I/O activity to be “bunched” makes multiple buffering an improvement over buffer swapping.</p>

  <p class="indent">Suppose we have <em>N</em> buffers for some input or output process using a single I/O device; we will imagine that the buffers are arranged in a circle, as in <a href="../Text/ch01c.html#ch01fig23">Fig. 23</a>. The program external to the buffering process can be assumed to have the following general form with respect to the I/O unit of interest: .</p>

  <div class="image2"><img src="../Images/ch01/219pro01.jpg"></div>

  <div class="image">
    <a id="ch01fig23"></a><img src="../Images/ch01/01fig23.jpg">

    <p class="fig-caption"><strong>Fig. 23.</strong> A circle of buffers (<em>N</em> = 6).</p>
  </div>

  <p>in other words, we can assume that the program alternates between an action called “<code>ASSIGN</code>” and an action called “<code>RELEASE</code>”, separated by other computations that do not affect the allocation of buffers.</p>

  <p class="uln-indent"><code>ASSIGN</code> means that the program acquires the address of the next buffer area; this address is assigned as the value of some program variable.</p>

  <p class="uln-indent"><code>RELEASE</code> means that the program is done with the current buffer area.</p>

  <p>Between <code>ASSIGN</code> and <code>RELEASE</code> the program is communicating with one of the buffers, called the <em>current</em> buffer area; between <code>RELEASE</code> and <code>ASSIGN</code>, the program makes no reference to any buffer area.</p>

  <p class="indent">Conceivably, <code>ASSIGN</code> could immediately follow <code>RELEASE</code>, and discussions of buffering have often been based on this assumption. However, if <code>RELEASE</code> is done as soon as possible, the buffering process has more freedom and will be more effective; by separating the two essentially different functions of <code>ASSIGN</code> and <code>RELEASE</code> we will find that the buffering technique remains easy to understand, and our discussion will be meaningful even if <em>N</em> = 1.</p>

  <p class="indent">To be more explicit, let us consider the cases of input and output separately. For input, suppose we are dealing with a card reader. The action <code>ASSIGN</code> means that the program needs to see information from a new card; we would like to set an index register to the memory address at which the next card image is located. The action <code>RELEASE</code> occurs when the information in the current card image is no longer needed — it has somehow been digested by the program, perhaps copied <a id="page_220"></a>to another part of memory, etc. The current buffer area may therefore be filled with further anticipated input.</p>

  <p class="indent">For output, consider the case of a line printer. The action <code>ASSIGN</code> occurs when a free buffer area is needed, into which a line image is to be placed for printing. We wish to set an index register equal to the memory address of such an area. The action <code>RELEASE</code> occurs when this line image has been fully set up in the buffer area, in a form ready to be printed.</p>

  <p><em>Example:</em> To print the contents of locations 0800–0823, we might write</p>

  <div class="equation"><a id="ch01eq-lev2sec18-5"></a><img src="../Images/ch01/220equ01.jpg"></div>

  <p>where <code>ASSIGNP</code> and <code>RELEASEP</code> represent subroutines to do the two buffering functions for the line printer.</p>

  <p class="indent">In an optimal situation, from the standpoint of the computer, the <code>ASSIGN</code> operation will require virtually no execution time. This means, on input, that each card image will have been anticipated, so that the data is available when the program is ready for it; and on output, it means that there will always be a free place in memory to record the line image. In either case, no time will be spent waiting for the I/O device.</p>

  <p class="indent">To help describe the buffering algorithm, and to make it more colorful, we will say that buffer areas are either green, yellow, or red (shown as G, Y, and R in <a href="../Text/ch01c.html#ch01fig24">Fig. 24</a>).</p>

  <div class="image">
    <a id="ch01fig24"></a><img src="../Images/ch01/01fig24.jpg">

    <p class="fig-caption"><strong>Fig. 24.</strong> Buffer transitions, (a) after <code>ASSIGN</code>, (b) after I/O complete, and (c) after <code>RELEASE</code>.</p>
  </div>

  <p class="indent"><em>Green</em> means that the area is ready to be <code>ASSIGN</code>ed; this means that it has been filled with anticipated information (in an input situation), or that it is a free area (in an output situation).</p>

  <p class="indent"><em>Yellow</em> means that the area has been <code>ASSIGN</code>ed, not <code>RELEASE</code>d; this means that it is the current buffer, and the program is communicating with it.</p>

  <p class="indent"><em>Red</em> means that the area has been <code>RELEASE</code>d; thus it is a free area (in an input situation) or it has been filled with information (in an output situation).</p>

  <p class="indent"><a href="../Text/ch01c.html#ch01fig23">Figure 23</a> shows two “pointers” associated with the circle of buffers. These are, conceptually, index registers in the program. <code>NEXTG</code> and <code>NEXTR</code> point to the “next green” and “next red” buffer, respectively. A third pointer, <code>CURRENT</code> (shown in <a href="../Text/ch01c.html#ch01fig24">Fig. 24</a>), indicates the yellow buffer when one is present.</p>

  <p class="indent">The algorithms below apply equally well to input or output, but for definiteness we will consider first the case of input from a card reader. Suppose that a program has reached the state shown in <a href="../Text/ch01c.html#ch01fig23">Fig. 23</a>. This means that four card images have been anticipated by the buffering process, and they reside in the green buffers. At this moment, two things are happening <em>simultaneously</em>: (a) The program is computing, following a <code>RELEASE</code> operation; (b) a card is being read into the buffer indicated by <code>NEXTR</code>. This state of affairs will continue until the input cycle is completed (the unit will then go from “busy” to “ready”), or until the program does an <code>ASSIGN</code> operation. Suppose the latter occurs first; then the buffer indicated by <code>NEXTG</code> changes to yellow (it is assigned as the current buffer),</p>

  <p><a id="page_221"></a><code>NEXTG</code> moves clockwise, and we arrive at the position shown in <a href="../Text/ch01c.html#ch01fig24">Fig. 24(a)</a>. If now the input is completed, another anticipated block is present; so the buffer changes from red to green, and <code>NEXTR</code> moves over as shown in <a href="../Text/ch01c.html#ch01fig24">Fig. 24(b)</a>. If the <code>RELEASE</code> operation follows next, we obtain <a href="../Text/ch01c.html#ch01fig24">Fig. 24(c)</a>.</p>

  <p class="indent">For an example concerning output, see <a href="../Text/ch01c.html#ch01fig27">Fig. 27</a> on page <a href="../Text/ch01c.html#ch01fig27">226</a>. That illustration shows the “colors” of buffer areas as a function of time, in a program that opens with four quick outputs, then produces four at a slow pace, and finally issues two in rapid succession as the program ends. Three buffers appear in that example.</p>

  <p class="indent">The pointers <code>NEXTR</code> and <code>NEXTG</code> proceed merrily around the circle, each at an independent rate of speed, moving clockwise. It is a race between the program (which turns buffers from green to red) and the I/O buffering process (which turns them from red to green). Two situations of conflict can occur:</p>

  <p class="indenthangingA">a) if <code>NEXTG</code> tries to pass <code>NEXTR,</code> the program has gotten ahead of the I/O device and it must wait until the device is ready.</p>

  <p class="indenthangingA">b) if <code>NEXTR</code> tries to pass <code>NEXTG,</code> the I/O device has gotten ahead of the program and we must shut it down until the next <code>RELEASE</code> is given.</p>

  <p>Both of these situations are depicted in <a href="../Text/ch01c.html#ch01fig24">Fig. 24</a>. (See <a href="../Text/ch01c.html#ch01ex_2_18_9">exercise 9</a>.)</p>

  <p class="indent">Fortunately, in spite of the rather lengthy explanation just given of the ideas behind a circle of buffers, the actual algorithms for handling the situation are quite simple. In the following description,</p>

  <div class="equation"><a id="ch01eq-lev2sec18-6"></a><img src="../Images/ch01/221equ01.jpg"></div>

  <p>The variable <em>n</em> is used in the algorithm below to avoid interference between <code>NEXTG</code> and <code>NEXTR</code>.</p>

  <p><a id="ch01alg-lev2sec18-A"></a><strong>Algorithm A</strong> <code>(ASSIGN).</code> This algorithm includes the steps implied by <code>ASSIGN</code> within a computational program, as described above.</p>

  <p class="indenthanging"><strong>Al.</strong> [Wait for <em>n</em> &lt; N.] If <em>n</em> = <em>N</em>, stall the program until <em>n</em> &lt; <em>N</em>. (If <em>n</em> = <em>N</em>, no buffers are ready to be assigned; but <a href="../Text/ch01c.html#ch01alg-lev2sec18-B">Algorithm B</a> below, which runs in parallel with this one, will eventually succeed in producing a green buffer.)</p>

  <p class="indenthanging"><a id="page_222"></a><strong>A2.</strong> [<code>CURRENT</code> ← <code>NEXTG</code>.] Set <code>CURRENT</code> ← <code>NEXTG</code> (thereby assigning the current buffer).</p>

  <p class="indenthanging"><strong>A3.</strong> [Advance <code>NEXTG</code>.] Advance <code>NEXTG</code> to the next clockwise buffer. <span class="middle"><img src="../Images/ch01/box.jpg"></span></p>

  <p><a id="ch01alg-lev2sec18-R"></a><strong>Algorithm R</strong> (<code>RELEASE</code>). This algorithm includes the steps implied by <code>RELEASE</code> within a computational program, as described above.</p>

  <p class="indenthanging"><strong>R1.</strong> [Increase <em>n</em>.] Increase <em>n</em> by one. <span class="middle"><img src="../Images/ch01/box.jpg"></span></p>

  <p><a id="ch01alg-lev2sec18-B"></a><strong>Algorithm B</strong> (<em>Buffer control</em>). This algorithm performs the actual initiation of I/O operators in the machine; it is to be executed “simultaneously” with the main program, in the sense described below.</p>

  <p class="indenthanging"><strong>B1.</strong> [Compute.] Let the main program compute for a short period of time; step B2. will be executed after a certain time delay, at a time when the I/O device is ready for another operation.</p>

  <p class="indenthanging"><strong>B2.</strong> [<em>n</em> = 0?] If <em>n</em> = 0, go to B1. (Thus, if no buffers are red, no I/O action can be performed.)</p>

  <p class="indenthanging"><strong>B3.</strong> [Initiate I/O.] Initiate transmission between the buffer area designated by <code>NEXTR</code> and the I/O device.</p>

  <p class="indenthanging"><strong>B4.</strong> [Compute.] Let the main program run for a period of time; then go to step B5 when the I/O operation is completed.</p>

  <p class="indenthanging"><strong>B5.</strong> [Advance <code>NEXTR</code>.] Advance <code>NEXTR</code> to the next clockwise buffer.</p>

  <p class="indenthanging"><strong>B6.</strong> [Decrease <em>n</em>.] Decrease <em>n</em> by one, and go to B2. <span class="middle"><img src="../Images/ch01/box.jpg"></span></p>

  <p class="indent">In these algorithms, we have two independent processes going on “simultaneously,” the buffering control program and the computation program. These processes are, in fact, <em>coroutines</em>, which we will call <code>CONTROL</code> and <code>COMPUTE</code>. Coroutine <code>CONTROL</code> jumps to <code>COMPUTE</code> in steps B1 and B4; coroutine <code>COMPUTE</code> jumps to <code>CONTROL</code> by interspersing “jump ready” instructions at sporadic intervals in its program.</p>

  <p class="indent">Coding this algorithm for <code>MIX</code> is extremely simple. For convenience, assume that the buffers are linked so that the word <em>preceding</em> each one is the address of the next; for example, with <em>N</em> = 3 buffers we have <code>CONTENTS(BUF1</code> − 1<code>)</code> = <code>BUF2</code>, <code>CONTENTS(BUF2</code> − 1<code>)</code> = <code>BUF3</code>, and <code>CONTENTS(BUF3</code> − 1<code>)</code> = <code>BUF1</code>.</p>

  <p><a id="programA"></a><strong>Program A</strong> (<code>ASSIGN</code><em>, a subroutine within the</em> <code>COMPUTE</code> <em>coroutine</em>). rI4 ≡ <code>CURRENT</code>; rI6 ≡ <em>n</em>; calling sequence is <code>JMP ASSIGN</code>; on exit, rX contains <code>NEXTG</code>.</p>

  <div class="image2"><img src="../Images/ch01/e222_01.jpg"></div>

  <div class="image">
    <a id="page_223"></a><a id="ch01fig25"></a><img src="../Images/ch01/01fig25.jpg">

    <p class="fig-caption"><strong>Fig. 25.</strong> Algorithms for multiple buffering.</p>
  </div>

  <p><a id="programR"></a><strong>Program R</strong> (<code>RELEASE</code><em>, code used within the</em> <code>COMPUTE</code> <em>coroutine</em>). rI6 ≡ <em>n</em>. This short code is to be inserted wherever <code>RELEASE</code> is desired.</p>

  <div class="image3"><img src="../Images/ch01/223pro01.jpg"></div>

  <p><a id="programB"></a><strong>Program B</strong> (<em>The</em> <code>CONTROL</code> <em>coroutine</em>). rI6 ≡ <em>n</em>, rI5 ≡ <code>NEXTR</code>.</p>

  <div class="image3"><img src="../Images/ch01/223pro02.jpg"></div>

  <p class="indent">Besides the code above, we also have the usual coroutine linkage</p>

  <div class="image3"><img src="../Images/ch01/223pro03.jpg"></div>

  <p>and the instruction ‘<code>JRED CONTROL(U)</code>’ should be placed within <code>COMPUTE</code> about once in every fifty instructions.</p>

  <p class="indent">Thus the programs for multiple buffering essentially amount to only seven instructions for <code>CONTROL</code>, eight for <code>ASSIGN</code>, and two for <code>RELEASE</code>.</p>

  <p class="indent">It is perhaps remarkable that <em>exactly</em> the same algorithm will work for both input and output. What is the difference — how does the control routine know whether to anticipate (for input) or to lag behind (for output)? The answer lies in the initial conditions: For input we start out with <em>n</em> = <em>N</em> (all buffers red) and for output we start out with <em>n</em> = 0 (all buffers green). Once the routine has been started properly, it continues to behave as either an input process or an output process, respectively. The other initial condition is that <code>NEXTR</code> = <code>NEXTG</code>, both pointing at one of the buffers.</p>

  <p class="indent">At the conclusion of the program, it is necessary to stop the I/O process (if it is input) or to wait until it is completed (for output); details are left to the reader (see <a href="../Text/ch01c.html#ch01ex_2_18_12">exercises 12</a> and <a href="../Text/ch01c.html#ch01ex_2_18_13">13</a>).</p>

  <p class="indent"><a id="page_224"></a>It is important to ask what is the best value of <em>N</em> to use. Certainly as <em>N</em> gets larger, the speed of the program will not decrease, but it will not increase indefinitely either and so we come to a point of diminishing returns. Let us refer again to the quantities <em>C</em> and <em>T</em>, representing computation time between I/O operators and the I/O time itself. More precisely, let <em>C</em> be the amount of time between successive <code>ASSIGN</code>s, and let <em>T</em> be the amount of time needed to transmit one block. If <em>C</em> is always <em>greater</em> than <em>T</em>, then <em>N</em> = 2 is adequate, for it is not hard to see that with two buffers we keep the computer busy at all times. If <em>C</em> is always <em>less</em> than <em>T</em>, then again <em>N</em> = 2 is adequate, for we keep the I/O device busy at all times (except when the device has special timing constraints as in <a href="../Text/ch01c.html#ch01ex_2_18_19">exercise 19</a>). Larger values of <em>N</em> are therefore useful chiefly when <em>C</em> varies between small values and large values; the average number of consecutive small values, plus 1, may be right for <em>N</em>, if the large values of <em>C</em> are significantly longer than <em>T</em>. (However, the advantage of buffering is virtually nullified if all input occurs at the beginning of the program and if all output occurs at the end.) If the time between <code>ASSIGN</code> and <code>RELEASE</code> is always quite small, the value of <em>N</em> may be decreased by 1 throughout the discussion above, with little effect on running time.</p>

  <p class="indent">This approach to buffering can be adapted in many ways, and we will mention a few of them briefly. So far we have assumed that only one I/O device was being used; in practice, of course, several devices will be in use at the same time.</p>

  <p class="indent">There are several ways to approach the subject of multiple units. In the simplest case, we can have a separate circle of buffers for each device. Each unit will have its own values of <em>n</em>, <em>N</em>, <code>NEXTR</code>, <code>NEXTG</code>, and <code>CURRENT</code>, and its own <code>CONTROL</code> coroutine. This will give efficient buffering action simultaneously on every I/O device.</p>

  <p class="indent">It is also possible to “pool” buffer areas that are of the same size, so that two or more devices share buffers from a common list. This can be handled by using the linked memory techniques of <a href="../Text/ch02.html#ch02">Chapter 2</a>, with all red input buffers linked together in one list and all green output buffers linked together in another. It becomes necessary to distinguish between input and output in this case, and to rewrite the algorithms without using <em>n</em> and <em>N</em>. The algorithm may get irrevocably stuck, if all buffers in the pool are filled with anticipated input; so a check should be made that there is always at least one buffer (preferably one for each device) that is not input-green; only if the <code>COMPUTE</code> routine is stalled at step A1 for some input device should we allow input into the final buffer of the pool from that device.</p>

  <p class="indent">Some machines have additional constraints on the use of input-output units, so that it is impossible to be transmitting data from certain pairs of devices at the same time. (For example, several units might be attached to the computer by means of a single “channel.”) This constraint also affects our buffering routine; when we must choose which I/O unit to initiate next, how is the choice to be made? This is called the problem of “forecasting.” The best forecasting rule for the general case would seem to give preference to the unit whose buffer circle <a id="page_225"></a>has the largest value of <em>n/N</em>, assuming that the number of buffers in the circles has been chosen wisely.</p>

  <p class="indent">Let’s conclude this discussion by taking note of a useful method for doing both input and output from the <em>same</em> buffer circle, under certain conditions. <a href="../Text/ch01c.html#ch01fig26">Figure 26</a> introduces a new kind of buffer, which has the color purple. In this situation, green buffers represent anticipated <em>input</em>; the program <code>ASSIGN</code>s and a green buffer becomes yellow, then upon <code>RELEASE</code> it turns red and represents a block to be <em>output</em>. The input and output processes follow around the circle independently as before, except that now we turn red buffers to purple after the output is done, and convert purple to green on input. It is necessary to ensure that none of the pointers <code>NEXTG</code>, <code>NEXTR</code>, <code>NEXTP</code> pass each other. At the instant shown in <a href="../Text/ch01c.html#ch01fig26">Fig. 26</a>, the program is computing between <code>ASSIGN</code> and <code>RELEASE</code>, while accessing the yellow buffer; simultaneously, input is going into the buffer indicated by <code>NEXTP</code>; and output is coming from the buffer indicated by <code>NEXTR</code>.</p>

  <div class="image">
    <a id="ch01fig26"></a><img src="../Images/ch01/01fig26.jpg">

    <p class="fig-caption"><strong>Fig. 26.</strong> Input and output from the same circle.</p>
  </div>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_1a" id="ch01ex_2_18_1">1</a>.</strong> [<em>05</em>] (a) Would sequence (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) still be correct if the <code>MOVE</code> instructions were placed before the <code>JBUS</code> instruction instead of after it? (b) What if the <code>MOVE</code> instructions were placed after the <code>IN</code> command?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_2a" id="ch01ex_2_18_2">2</a>.</strong> [<em>10</em>] The instructions ‘<code>OUT 1000(6)</code>; <code>JBUS *(6)</code>’ may be used to output a tape block in an unbuffered fashion, just as the instructions (<a href="../Text/ch01c.html#ch01eq-lev2sec18-1">1</a>) did this for input. Give a method analogous to (<a href="../Text/ch01c.html#ch01eq-lev2sec18-2">2</a>) and (<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) that buffers this output, by using <code>MOVE</code> instructions and an auxiliary buffer in locations 2000–2099.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_3a" id="ch01ex_2_18_3">3</a>.</strong> [<em>22</em>] Write a buffer-swapping output subroutine analogous to (<a href="../Text/ch01c.html#ch01eq-lev2sec18-4">4</a>). The subroutine, called <code>WORDOUT</code>, should store the word in rA as the next word of output, and if a buffer is full it should write 100 words onto tape unit <code>V</code>. Index register 5 should be used to refer to the current buffer position. Show the layout of buffer areas and explain what instructions (if any) are necessary at the beginning and end of the program to ensure that the first and last blocks are properly written. The final block should be filled out with zeros if necessary.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_4a" id="ch01ex_2_18_4">4</a>.</strong> [<em>M20</em>] Show that if a program refers to a single I/O device, we might be able to cut the running time in half by buffering the I/O, in favorable circumstances; but we can never decrease the running time by more than a factor of two, with respect to the time taken by unbuffered I/O.</p>

  <p class="exercises2"><a id="page_226"></a><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_5a" id="ch01ex_2_18_5">5</a>.</strong> [<em>M21</em>] Generalize the situation of the preceding exercise to the case when the program refers to <em>n</em> I/O devices instead of just one.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_6a" id="ch01ex_2_18_6">6</a>.</strong> [<em>12</em>] What instructions should be placed at the beginning of a program so that the <code>WORDIN</code> subroutine (<a href="../Text/ch01c.html#ch01eq-lev2sec18-4">4</a>) gets off to the right start? (For example, index register 6 must be set to <em>something</em>.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_7a" id="ch01ex_2_18_7">7</a>.</strong> [<em>22</em>] Write a subroutine called <code>WORDIN</code> that is essentially like (<a href="../Text/ch01c.html#ch01eq-lev2sec18-4">4</a>) except that it does not make use of a sentinel.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch01ex_2_18_8a" id="ch01ex_2_18_8">8</a>.</strong> [<em>11</em>] The text describes a hypothetical input scenario that leads from <a href="../Text/ch01c.html#ch01fig23">Fig. 23</a> through parts (a), (b), and (c) of <a href="../Text/ch01c.html#ch01fig24">Fig. 24</a>. Interpret the same scenario under the assumption that output to the line printer is being done, instead of input from cards. (For example, what things are happening at the time shown in <a href="../Text/ch01c.html#ch01fig23">Fig. 23</a>?)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_9a" id="ch01ex_2_18_9">9</a>.</strong> [<em>21</em>] A program that leads to the buffer contents shown in <a href="../Text/ch01c.html#ch01fig27">Fig. 27</a> may be characterized by the following list of times:</p>

  <p class="uln-indent1"><em>A,</em> 1000, <em>R,</em> 1000, <em>A,</em> 1000, <em>R,</em> 1000, <em>A,</em> 1000, <em>R,</em> 1000, <em>A,</em> 1000, <em>R,</em> 1000,</p>

  <p class="uln-indent1"><em>A,</em> 7000, <em>R,</em> 5000, <em>A,</em> 7000, <em>R,</em> 5000, <em>A,</em> 7000, <em>R,</em> 5000, <em>A,</em> 7000, <em>R,</em> 5000,</p>

  <p class="uln-indent1"><em>A,</em> 1000, <em>R,</em> 1000, <em>A,</em> 2000, <em>R,</em> 1000.</p>

  <div class="image4">
    <a id="ch01fig27"></a><img class="img1" src="../Images/ch01/01fig27.jpg">

    <p class="fig-caption"><strong>Fig. 27.</strong> Output with three buffers (see <a href="../Text/ch01c.html#ch01ex_2_18_9">exercise 9</a>).</p>
  </div>

  <p>This list means “assign, compute for 1000<em>u</em>, release, compute for 1000<em>u</em>, assign, ..., compute for 2000<em>u</em>, release, compute for 1000<em>u</em>.” The computation times given do not include any intervals during which the computer might have to wait for the output device to catch up (as at the fourth “assign” in <a href="../Text/ch01c.html#ch01fig27">Fig. 27</a>). The output device operates at a speed of 7500<em>u</em> per block.</p>

  <p class="indent"><a id="page_227"></a>The following chart specifies the actions shown in <a href="../Text/ch01c.html#ch01fig27">Fig. 27</a> as time passes:</p>

  <div class="image"><img src="../Images/ch01/227pro01.jpg"></div>

  <p>The total time required was therefore 81500<em>u</em>; the computer was idle from 6000–8500, 10500–16000, and 69000–81500, or 20500<em>u</em> altogether; the output unit was idle from 0–1000, 46000–47000, and 54500–59000, or 6500<em>u</em>.</p>

  <p class="indent">Make a time-action chart like the above for the same program, assuming that there are only <em>two</em> buffers.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_18_10a" id="ch01ex_2_18_10">10</a>.</strong> [<em>21</em>] Repeat <a href="../Text/ch01c.html#ch01ex_2_18_9">exercise 9</a>, except with <em>four</em> buffers.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_18_11a" id="ch01ex_2_18_11">11</a>.</strong> [<em>21</em>] Repeat <a href="../Text/ch01c.html#ch01ex_2_18_9">exercise 9</a>, except with just <em>one</em> buffer.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_18_12a" id="ch01ex_2_18_12">12</a>.</strong> [<em>24</em>] Suppose that the multiple buffering algorithm in the text is being used for card input, and suppose the input is to terminate as soon as a card with “.” in column 80 has been read. Show how the <code>CONTROL</code> coroutine (<a href="../Text/ch01c.html#ch01alg-lev2sec18-B">Algorithm B</a> and <a href="../Text/ch01c.html#programB">Program B</a>) should be changed so that input is shut off in this way.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch01ex_2_18_13a" id="ch01ex_2_18_13">13</a>.</strong> [<em>20</em>] What instructions should be included at the end of the <code>COMPUTE</code> coroutine in the text, if the buffering algorithms are being applied to output, to ensure that all information has been output from the buffers?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_14a" id="ch01ex_2_18_14">14</a>.</strong> [<em>20</em>] Suppose the computational program does not alternate between <code>ASSIGN</code> and <code>RELEASE</code>, but instead gives the sequence of actions ... <code>ASSIGN</code> ... <code>ASSIGN</code> ... <code>RELEASE</code> ... <code>RELEASE</code>. What effect does this have on the algorithms described in the text? Is it possibly useful?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_15a" id="ch01ex_2_18_15">15</a>.</strong> [<em>22</em>] Write a complete <code>MIX</code> program that copies 100 blocks from tape unit 0 to tape unit 1, using just three buffers. The program should be as fast as possible.</p>

  <p class="exercises1"><strong><a id="ch01ex_2_18_16"></a>16.</strong> [<em>29</em>] Formulate the “green-yellow-red-purple” algorithm, suggested by <a href="../Text/ch01c.html#ch01fig26">Fig. 26</a>, in the manner of the algorithms for multiple buffering given in the text, using three coroutines (one to control the input device, one for the output device, and one for the computation).</p>

  <p class="exercises1"><strong><a id="ch01ex_2_18_17"></a>17.</strong> [<em>40</em>] Adapt the multiple-buffer algorithm to pooled buffers; build in methods that keep the process from slowing down, due to too much anticipated input. Try to make the algorithm as elegant as possible. Compare your method to nonpooling methods, applied to real-life problems.</p>

  <p class="exercises3"><a id="page_228"></a><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_18a" id="ch01ex_2_18_18">18</a>.</strong> [<em>30</em>] A proposed extension of <code>MIX</code> allows its computations to be interrupted, as explained below. Your task in this exercise is to modify Algorithms and <a href="../Text/ch01c.html#programA">Programs A</a>, <a href="../Text/ch01c.html#programR">R</a>, and <a href="../Text/ch01c.html#programB">B</a> of the text so that they use these interrupt facilities instead of the ‘<code>JRED</code>’ instructions.</p>

  <p class="indent">The new <code>MIX</code> features include an additional 3999 memory cells, locations −3999 through −0001. The machine has two internal “states,” <em>normal state</em> and <em>control state</em>. In normal state, locations −3999 through −0001 are not admissible memory locations and the <code>MIX</code> computer behaves as usual. When an “interrupt” occurs, due to conditions explained later, locations −0009 through −0001 are set equal to the contents of <code>MIX</code>’s registers: rA in −0009; rI1 through rI6 in −0008 through −0003; rX in −0002; and rJ, the overflow toggle, the comparison indicator, and the location of the next instruction are stored in −0001 as</p>

  <div class="image"><img src="../Images/ch01/e228_01.jpg"></div>

  <p>the machine enters control state, at a location depending on the type of interrupt.</p>

  <p class="indent">Location −0010 acts as a “clock”: Every 1000<em>u</em> of time, the number appearing in this location is decreased by one, and if the result is zero an interrupt to location –0011 occurs.</p>

  <p class="indent">The new <code>MIX</code> instruction ‘<code>INT</code>’ (C = 5, F = 9) works as follows: (a) In normal state, an interrupt occurs to location −0012. (Thus a programmer may force an interrupt, to communicate with a control routine; the address of <code>INT</code> has no effect, although the control routine may use it for information to distinguish between types of interrupt.) (b) In control state, all <code>MIX</code> registers are loaded from locations −0009 to −0001, the computer goes into normal state, and it resumes execution. The execution time for <code>INT</code> is 2<em>u</em> in each case.</p>

  <p class="indent">An <code>IN</code>, <code>OUT</code>, or <code>IOC</code> instruction given in <em>control</em> state will cause an interrupt to occur as soon as the I/O operation is completed. The interrupt goes to location −(0020+ unit number).</p>

  <p class="indent">No interrupts occur while in control state; any interrupt conditions are “saved” until after the next <code>INT</code> operation, and interrupt will occur after one instruction of the normal state program has been performed.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch01/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch01ex_2_18_19a" id="ch01ex_2_18_19">19</a>.</strong> [<em>M28</em>] Special considerations arise when input or output involves short blocks on a rotating device like a magnetic disk. Suppose a program works with <em>n</em> ≥ 2 consecutive blocks of information in the following way: Block <em>k</em> begins to be input at time <em>t<sub>k</sub></em>, where <em>t</em><sub>1</sub> = 0. It is assigned for processing at time <em>u<sub>k</sub></em> ≥ <em>t<sub>k</sub></em> + <em>T</em> and released from its buffer at time <em>v<sub>k</sub></em> = <em>u<sub>k</sub></em> + <em>C</em>. The disk rotates once every <em>P</em> units of time, and its reading head passes the start of a new block every <em>L</em> units; so we must have <em>t<sub>k</sub></em> ≡ (<em>k</em>−1)<em>L</em> (modulo <em>P</em>). Since the processing is sequential, we must also have <em>u<sub>k</sub></em> ≥ <em>v<sub>k−</sub></em><sub>1</sub> for 1 <em>&lt; k</em> ≤ <em>n</em>. There are <em>N</em> buffers, hence <em>t<sub>k</sub></em> ≥ <em>v<sub>k−<em>N</em></sub></em> for <em>N &lt; k</em> ≤ <em>n</em>.</p>

  <p class="indent">How large does <em>N</em> have to be so that the finishing time <em>v<sub><em>n</em></sub></em> has its minimum possible value, <em>T</em> + <em>C</em> + (<em>n</em> − 1) max(<em>L, C</em>)? Give a general rule for determining the smallest such <em>N</em>. Illustrate your rule when <em>L</em> = 1, <em>P</em> = 100, <em>T</em> = .5, <em>n</em> = 100, and (a) <em>C</em> = .5; (b) <em>C</em> = 1.0; (c) <em>C</em> = 1.01; (d) <em>C</em> = 1.5; (e) <em>C</em> = 2.0; (f) <em>C</em> = 2.5; (g) <em>C</em> = 10.0; (h) <em>C</em> = 50.0; (i) <em>C</em> = 200.0.</p>

  <div class="heading">
    <h4 id="ch01lev2sec19"><a id="page_229"></a>1.4.5. History and Bibliography</h4>

    <p>Most of the fundamental techniques described in <a href="../Text/ch01c.html#ch01lev1sec4">Section 1.4</a> have been developed independently by a number of different people, and the exact history of the ideas will probably never be known. An attempt has been made to record here the most important contributions to the history, and to put them in perspective.</p>
  </div>

  <p class="indent">Subroutines were the first labor-saving devices invented for programmers. In the 19th century, Charles Babbage envisioned a library of routines for his Analytical Engine [see <em>Charles Babbage and His Calculating Engines</em>, edited by Philip and Emily Morrison (Dover, 1961), 56]; and we might say that his dream came true in 1944 when Grace M. Hopper wrote a subroutine for computing sin <em>x</em> on the Harvard Mark I calculator [see <em>Mechanisation of Thought Processes</em> (London: Nat. Phys. Lab., 1959), 164]. However, these were essentially “open subroutines,” meant to be inserted into a program where needed instead of being linked up dynamically. Babbage’s planned machine was controlled by sequences of punched cards, as on the Jacquard loom; the Mark I was controlled by a number of paper tapes. Thus they were quite different from today’s stored-program computers.</p>

  <p class="indent">Subroutine linkage appropriate to stored-program machines, with the return address supplied as a parameter, was discussed by Herman H. Goldstine and John von Neumann in their widely circulated monograph on programming, written during 1946 and 1947; see von Neumann’s <em>Collected Works</em> <strong>5</strong> (New York: Macmillan, 1963), 215–235. The main routine of their programs was responsible for storing parameters into the body of the subroutine, instead of passing the necessary information in registers. In England, A. M. Turing had designed hardware and software for subroutine linkage as early as 1945; see <em>Proceedings of a Second Symposium on Large-Scale Digital Calculating Machinery</em> (Cambridge, Mass.: Harvard University, 1949), 87–90; B. E. Carpenter and R. W. Doran, editors, <em>A. M. Turing’s ACE Report of 1946 and Other Papers</em> (Cambridge, Mass.: <code>MIT</code> Press, 1986), 35–36, 76, 78–79. The use and construction of a very versatile subroutine library is the principal topic of the first textbook of computer programming, <em>The Preparation of Programs for an Electronic Digital Computer</em>, by M. V. Wilkes, D. J. Wheeler, and S. Gill, 1st ed. (Reading, Mass.: Addison–Wesley, 1951).</p>

  <p class="indent">The word “coroutine” was coined by M. E. Conway in 1958, after he had developed the concept, and he first applied it to the construction of an assembly program. Coroutines were independently studied by J. Erdwinn and J. Merner, at about the same time; they wrote a paper entitled “Bilateral Linkage,” which was not then considered sufficiently interesting to merit publication, and unfortunately no copies of that paper seem to exist today. The first published explanation of the coroutine concept appeared much later in Conway’s article “Design of a Separable Transition-Diagram Compiler,” <em>CACM</em> <strong>6</strong> (1963), 396– 408. Actually a primitive form of coroutine linkage had already been noted briefly as a “programming tip” in an early UNIVAC publication [<em>The Programmer</em> <strong>1</strong>, 2 (February 1954), 4]. A suitable notation for coroutines in ALGOL-like languages was introduced in Dahl and Nygaard’s SIMULA I [<em>CACM</em> <strong>9</strong> (1966), 671–678], <a id="page_230"></a>and several excellent examples of coroutines (including replicated coroutines) appear in the book <em>Structured Programming</em> by O.-J. Dahl, E. W. Dijkstra, and C. A. R. Hoare, Chapter 3.</p>

  <p class="indent">The first interpretive routine may be said to be the “Universal Turing Machine,” a Turing machine capable of simulating any other Turing machines. Turing machines are not actual computers; they are theoretical constructions used to prove that certain problems are unsolvable by algorithms. Interpretive routines in the conventional sense were mentioned by John Mauchly in his lectures at the Moore School in 1946. The most notable early interpreters, chiefly intended to provide a convenient means of doing floating point arithmetic, were certain routines for the Whirlwind I (by C. W. Adams and others) and for the ILLIAC I (by D. J. Wheeler and others). Turing took a part in this development also; interpretive systems for the Pilot ACE computer were written under his direction. For references to the state of interpreters in the early fifties, see the article “Interpretative Sub-routines” by J. M. Bennett, D. G. Prinz, and M. L. Woods, <em>Proc. ACM</em> (Toronto: 1952), 81–87; see also various papers in the <em>Proceedings of the Symposium on Automatic Programming for Digital Computers</em> (1954), published by the Office of Naval Research, Washington, D.C.</p>

  <p class="indent">The most extensively used early interpretive routine was probably John Backus’s “IBM 701 Speedcoding system” [see <em>JACM</em> <strong>1</strong> (1954), 4–6]. This interpreter was slightly modified and skillfully rewritten for the IBM 650 by V. M. Wolontis and others of the Bell Telephone Laboratories; their routine, called the “Bell Interpretive System,” became extremely popular. The IPL interpretive systems, which were designed beginning in 1956 by A. Newell, J. C. Shaw, and H. A. Simon for applications to quite different problems (see <a href="../Text/ch02c.html#ch02lev1sec6">Section 2.6</a>), were used extensively for list processing. Modern uses of interpreters, as mentioned in the introduction to <a href="../Text/ch01c.html#ch01lev2sec17">Section 1.4.3</a>, are often mentioned in passing in the computer literature; see the references listed in that section for articles that discuss interpreters in somewhat more detail.</p>

  <p class="indent">The first tracing routine was developed by Stanley Gill in 1950; see his interesting article in <em>Proceedings of the Royal Society of London</em>, series A, <strong>206</strong> (1951), 538–554. The text by Wilkes, Wheeler, and Gill mentioned above includes several programs for tracing. Perhaps the most interesting of them is subroutine C-10 by D. J. Wheeler, which includes a provision for suppressing the trace upon entry to a library subroutine, executing the subroutine at full speed, then continuing the trace. Published information about trace routines is quite rare in the general computer literature, primarily because the methods are inherently oriented to a particular machine. The only other early reference known to the author is H. V. Meek, “An Experimental Monitoring Routine for the IBM 705,” <em>Proc. Western Joint Computer Conf.</em> (1956), 68–70, which discusses a trace routine for a machine on which the problem was particularly difficult. See also the trace routine for IBM’s System/360 architecture, presented in <em>A Compiler Generator</em> by W. M. McKeeman, J. J. Horning, and D. B. Wortman (Prentice– Hall, 1970), 305–363. Nowadays the emphasis on trace routines has shifted to software that provides selective symbolic output and measurements of program <a id="page_231"></a>performance; one of the best such systems was developed by E. Satterthwaite, and described in <em>Software Practice &amp; Experience</em> <strong>2</strong> (1972), 197–217.</p>

  <p class="indent">Buffering was originally performed by computer hardware, in a manner analogous to the code <a href="../Text/ch01c.html#ch01lev2sec18">1.4.4</a>–(<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>); an internal buffer area inaccessible to the programmer played the role of locations 2000–2099, and the instructions <a href="../Text/ch01c.html#ch01lev2sec18">1.4.4</a>–(<a href="../Text/ch01c.html#ch01eq-lev2sec18-3">3</a>) were implicitly performed behind the scenes when an input command was given. During the late 1940s, software buffering techniques that are especially useful for sorting were developed by early programmers of the UNIVAC (see Section 5.5). For a good survey of the prevailing philosophy towards I/O in 1952, see the proceedings of the Eastern Joint Computer Conference held in that year.</p>

  <p class="indent">The DYSEAC computer [Alan L. Leiner, <em>JACM</em> <strong>1</strong> (1954), 57–81] introduced the idea of input-output devices communicating directly with memory while a program is running, then interrupting the program upon completion. Such a system implies that buffering algorithms had been developed, but the details went unpublished. The first published reference to buffering techniques in the sense we have described gives a highly sophisticated approach; see O. Mock and C. J. Swift, “Programmed Input-Output Buffering,” <em>Proc. ACM Nat. Meeting</em> <strong>13</strong> (1958), paper 19, and <em>JACM</em> <strong>6</strong> (1959), 145–151. (The reader is cautioned that both articles contain a good deal of local jargon, which may take some time to understand, but neighboring articles in <em>JACM</em> <strong>6</strong> will help.) An interrupt system that enabled buffering of input and output was independently developed by E. W. Dijkstra in 1957 and 1958, in connection with B. J. Loopstra’s and C. S. Scholten’s X1 computer [see <em>Comp. J.</em> <strong>2</strong> (1959), 39–43]. Dijkstra’s doctoral thesis, “Communication with an Automatic Computer” (1959), discussed primitive synchronization operations by which users could create long chains of buffers with respect to paper tape and typewriter I/O; each buffer contained either a single character or a single number. He later developed the ideas into the important general notion of <em>semaphores</em>, which are basic to the control of all sorts of concurrent processes, not just input-output [see <em>Programming Languages</em>, ed. by F. Genuys (Academic Press, 1968), 43–112; <em>BIT</em> <strong>8</strong> (1968), 174–186; <em>Acta Informatica</em> <strong>1</strong> (1971), 115–138]. The paper “Input-Output Buffering and FORTRAN” by David E. Ferguson, <em>JACM</em> <strong>7</strong> (1960), 1–9, describes buffer circles and gives a detailed description of simple buffering with many units at once.</p>

  <p class="blockquote"><em>About 1,000 instructions is a reasonable upper limit<br>
  for the complexity of problems now envisioned.</em></p>

  <p class="attribution">— HERMAN GOLDSTINE and JOHN VON NEUMANN (1946)</p>
</body>
</html>