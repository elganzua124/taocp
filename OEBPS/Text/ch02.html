<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$","$"]],
        displayMath: [["$$","$$"]],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
  <script src="MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>

  <title></title>
  <link href="../Styles/caps.css" rel="stylesheet" type="text/css">
</head>

<body>
  <h2 id="ch02"><a id="page_232"></a>Chapter Two. Information Structures</h2>

  <p class="blockquote"><span class="roman_italic">I think that I shall never see<br>
  A poem lovely as a tree</span>.</p>

  <p class="attribution">— JOYCE KILMER (1913)</p>

  <p class="blockquote"><span class="roman_italic">Yea, from the table of my memory<br>
  I’ll wipe away all trivial fond records</span>.</p>

  <p class="attribution">— HAMLET (Act I, Scene 5, Line 98)</p>

  <div class="heading">
    <h3 id="ch02lev1sec1">2.1. Introduction</h3>

    <p>C<small>OMPUTER PROGRAMS</small> usually operate on tables of information. In most cases these tables are not simply amorphous masses of numerical values; they involve important <em>structural relationships</em> between the data elements.</p>
  </div>

  <p class="indent">In its simplest form, a table might be a linear list of elements, when its relevant structural properties might include the answers to such questions as: Which element is first in the list? Which is last? Which elements precede and follow a given one? How many elements are in the list? A lot can be said about structure even in this apparently simple case (see <a href="../Text/ch02.html#ch02lev1sec2">Section 2.2</a>).</p>

  <p class="indent">In more complicated situations, the table might be a two-dimensional array (a matrix or grid, having both a row and a column structure), or it might be an <em>n</em>-dimensional array for higher values of <em>n</em>; it might be a tree structure, representing hierarchical or branching relationships; or it might be a complex multilinked structure with a great many interconnections, such as we may find in a human brain.</p>

  <p class="indent">In order to use a computer properly, we need to understand the structural relationships present within data, as well as the basic techniques for representing and manipulating such structure within a computer.</p>

  <p class="indent">The present chapter summarizes the most important facts about information structures: the static and dynamic properties of different kinds of structure; means for storage allocation and representation of structured data; and efficient algorithms for creating, altering, accessing, and destroying structural information. In the course of this study, we will also work out several important examples that illustrate the application of such methods to a wide variety of problems. The examples include topological sorting, polynomial arithmetic, discrete system simulation, sparse matrix transformation, algebraic formula manipulation, and applications to the writing of compilers and operating systems. Our concern will be almost entirely with structure as represented <em>inside</em> a computer; the <a id="page_233"></a>conversion from external to internal representations is the subject of Chapters 9 and 10.</p>

  <p class="indent">Much of the material we will discuss is often called “List processing,” since a number of programming systems such as LISP have been designed to facilitate working with general kinds of structures called <em>Lists</em>. (When the word “list” is capitalized in this chapter, it is being used in a technical sense to denote a particular type of structure that is highlighted in <a href="../Text/ch02c.html#ch02lev2sec11">Section 2.3.5</a>.) Although List processing systems are useful in a large number of situations, they impose constraints on the programmer that are often unnecessary; it is usually better to use the methods of this chapter directly in one’s own programs, tailoring the data format and the processing algorithms to the particular application. Many people unfortunately still feel that List processing techniques are quite complicated (so that it is necessary to use someone else’s carefully written interpretive system or a prefabricated set of subroutines), and that List processing must be done only in a certain fixed way. We will see that there is nothing magic, mysterious, or difficult about the methods for dealing with complex structures; these techniques are an important part of every programmer’s repertoire, and we can use them easily whether we are writing a program in assembly language or in an algebraic language like <small>FORTRAN, C</small>, or Java.</p>

  <p class="indent">We will illustrate methods of dealing with information structures in terms of the <code>MIX</code> computer. A reader who does not care to look through detailed <code>MIX</code> programs should at least study the ways in which structural information is represented in <code>MIX</code>’s memory.</p>

  <p class="indent">It is important at this point to define several terms and notations that we will be using frequently from now on. The information in a table consists of a set of <em>nodes</em> (called “records,” “entities,” or “beads” by some authors); we will occasionally say “item” or “element” instead of “node.” Each node consists of one or more consecutive words of the computer memory, divided into named parts called <em>fields</em>. In the simplest case, a node is just one word of memory, and it has just one field comprising that whole word. As a more interesting example, suppose the elements of our table are intended to represent playing cards; we might have two-word nodes broken into five fields, <code>TAG</code>, <code>SUIT</code>, <code>RANK</code>, <code>NEXT</code>, and <code>TITLE</code>:</p>

  <div class="equation"><a id="ch02eq-lev1sec1-1"></a><img src="../Images/ch02/233equ01.jpg"></div>

  <p>(This format reflects the contents of two <code>MIX</code> words. Recall that a <code>MIX</code> word consists of five bytes and a sign; see <a href="../Text/ch01b.html#ch01lev2sec12">Section 1.3.1</a>. In this example we assume that the signs are + in each word.) The <em>address</em> of a node, also called a <em>link</em>, <em>pointer</em>, or <em>reference</em> to that node, is the memory location of its first word. The address is often taken relative to some base location, but in this chapter for simplicity we will take the address to be an absolute memory location.</p>

  <p class="indent">The contents of any field within a node may represent numbers, alphabetic characters, links, or anything else the programmer may desire. In connection with the example above, we might wish to represent a pile of cards that might <a id="page_234"></a>appear in a game of solitaire: <code>TAG</code> = 1 means that the card is face down, <code>TAG</code> = 0 means that it is face up; <code>SUIT</code> = 1, 2, 3, or 4 for clubs, diamonds, hearts, or spades, respectively; <code>RANK</code> = 1, 2, . . ., 13 for ace, deuce, . . ., king; <code>NEXT</code> is a <em>link</em> to the card <em>below</em> this one in the pile; and <code>TITLE</code> is a five-character alphabetic name of this card, for use in printouts. A typical pile might look like this:</p>

  <div class="equation"><a id="ch02eq-lev1sec1-2"></a><img src="../Images/ch02/234equ01.jpg"></div>

  <p>The memory locations in the computer representation are shown here as 100, 386, and 242; they could have been any other numbers as far as this example is concerned, since each card links to the one below it. Notice the special link <em>“Λ”</em> in node 100; <em>we use the capital Greek letter Lambda to denote the null link</em>, the link to no node. The null link <em>Λ</em> appears in node 100 since the 10 of clubs is the bottom card of the pile. Within the machine, <em>Λ</em> is represented by some easily recognizable value that cannot be the address of a node. We will generally assume that no node appears in location 0; consequently, <em>Λ</em> will almost always be represented as the link value 0 in <code>MIX</code> programs.</p>

  <p class="indent">The introduction of links to other elements of data is an extremely important idea in computer programming; links are the key to the representation of complex structures. When displaying computer representations of nodes it is usually convenient to represent links by arrows, so that example (<a href="../Text/ch02.html#ch02eq-lev1sec1-2">2</a>) would appear thus:</p>

  <div class="equation"><a id="ch02eq-lev1sec1-3"></a><img src="../Images/ch02/234equ02.jpg"></div>

  <p>The actual locations 242, 386, and 100 (which are irrelevant anyway) no longer appear in representation (<a href="../Text/ch02.html#ch02eq-lev1sec1-3">3</a>). Electrical circuit notation for a “grounded” wire is used to indicate a null link, shown here at the right of the diagram. Notice also that (<a href="../Text/ch02.html#ch02eq-lev1sec1-3">3</a>) indicates the top card by an arrow from “<code>TOP</code>”; here <code>TOP</code> is a <em>link variable</em>, often called a pointer variable, namely a variable whose value is a link. All references to nodes in a program are made directly through link variables (or link constants), or indirectly through link fields in other nodes.</p>

  <p class="indent"><a id="page_235"></a>Now we come to the most important part of the notation, the means of referring to fields within nodes. This is done simply by giving the name of the field followed by a link to the desired node in parentheses; for example, in (<a href="../Text/ch02.html#ch02eq-lev1sec1-2">2</a>) and (<a href="../Text/ch02.html#ch02eq-lev1sec1-3">3</a>) with the fields of (<a href="../Text/ch02.html#ch02eq-lev1sec1-1">1</a>) we have</p>

  <div class="equation"><a id="ch02eq-lev1sec1-4"></a><img src="../Images/ch02/235equ01.jpg"></div>

  <p class="indent">The reader should study these examples carefully, since such field notations will be used in many algorithms of this chapter and the following chapters. To make the ideas clearer, we will now state a simple algorithm for placing a new card face up on top of the pile, assuming that <code>NEWCARD</code> is a link variable whose value is a link to the new card:</p>

  <p class="indenthanging"><strong>A1.</strong> Set <code>NEXT</code>(<code>NEWCARD</code>) ← <code>TOP</code>. (This puts the appropriate link into the new card node.)</p>

  <p class="indenthanging"><strong>A2.</strong> Set <code>TOP</code> ← <code>NEWCARD</code>. (This keeps <code>TOP</code> pointing to the top of the pile.)</p>

  <p class="indenthanging"><strong>A3.</strong> Set <code>TAG</code>(<code>TOP</code>) ← 0. (This marks the card as “face up.”) <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p>Another example is the following algorithm, which counts the number of cards currently in the pile:</p>

  <p class="indenthanging"><strong>B1.</strong> Set <code>N</code> ← 0, <code>X</code> ← <code>TOP</code>. (Here <code>N</code> is an integer variable, <code>X</code> is a link variable.)</p>

  <p class="indenthanging"><strong>B2.</strong> If <code>X</code> = <em>Λ</em>, stop; <code>N</code> is the number of cards in the pile.</p>

  <p class="indenthanging"><strong>B3.</strong> Set <code>N</code> ← <code>N</code> + 1, <code>X</code> ← <code>NEXT</code>(<code>X</code>), and go back to step B2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">Notice that we are using symbolic names for two quite different things in these algorithms: as names of <em>variables</em> (<code>TOP</code>, <code>NEWCARD</code>, <code>N</code>, <code>X</code>) and as names of <em>fields</em> (<code>TAG</code>, <code>NEXT</code>). These two usages must not be confused. If <code>F</code> is a field name and <code>L</code> ≠ <em>Λ</em> is a link, then <code>F</code>(<code>L</code>) is a variable; but <code>F</code> itself is not a variable — it does not possess a value unless it is qualified by a nonnull link.</p>

  <p class="indent">Two further notations are used, to convert between addresses and the values stored there, when we are discussing low-level machine details:</p>

  <p class="indentsub">a) <code>CONTENTS</code> always denotes a full-word field of a one-word node. Thus <code>CONTENTS</code>(1000) denotes the value stored in memory location 1000; it is a variable having this value. If <code>V</code> is a link variable, <code>CONTENTS</code>(<code>V</code>) denotes the value pointed to by <code>V</code> (not the value <code>V</code> itself).</p>

  <p class="indentsub1">b) If <code>V</code> is the name of some value held in a memory cell, <code>LOC</code>(<code>V</code>) denotes the address of that cell. Consequently, if <code>V</code> is a variable whose value is stored in a full word of memory, we have <code>CONTENTS</code>(<code>LOC</code>(<code>V</code>)) = <code>V</code>.</p>

  <p class="indent">It is easy to transform this notation into <code>MIXAL</code> assembly language code, although <code>MIXAL</code>’s notation is somewhat backwards. The values of link variables are put into index registers, and the partial-field capability of <code>MIX</code> is used to refer <a id="page_236"></a>to the desired field. For example, <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> above could be written thus:</p>

  <div class="equation"><a id="ch02eq-lev1sec1-5"></a><img src="../Images/ch02/236equ01.jpg"></div>

  <p>The ease and efficiency with which these operations can be carried out in a computer is the primary reason for the importance of the “linked memory” concept.</p>

  <p class="indent">Sometimes we have a single variable that denotes a whole node; its value is a sequence of fields instead of just one field. Thus we might write</p>

  <div class="equation"><a id="ch02eq-lev1sec1-6"></a><img src="../Images/ch02/236equ02.jpg"></div>

  <p>where <code>NODE</code> is a field specification just like <code>CONTENTS</code>, except that it refers to an entire node, and where <code>CARD</code> is a variable that assumes structured values like those in (<a href="../Text/ch02.html#ch02eq-lev1sec1-1">1</a>). If there are <em>c</em> words in a node, the notation (<a href="../Text/ch02.html#ch02eq-lev1sec1-6">6</a>) is an abbreviation for the <em>c</em> low-level assignments</p>

  <div class="equation"><a id="ch02eq-lev1sec1-7"></a><img src="../Images/ch02/236equ03.jpg"></div>

  <p class="indent">There is an important distinction between assembly language and the notation used in algorithms. Since assembly language is close to the machine’s internal language, the symbols used in <code>MIXAL</code> programs stand for addresses instead of values. Thus in the left-hand columns of (<a href="../Text/ch02.html#ch02eq-lev1sec1-5">5</a>), the symbol <code>TOP</code> actually denotes the <em>address</em> where the pointer to the top card appears in memory; but in (<a href="../Text/ch02.html#ch02eq-lev1sec1-6">6</a>) and (<a href="../Text/ch02.html#ch02eq-lev1sec1-7">7</a>) and in the remarks at the right of (<a href="../Text/ch02.html#ch02eq-lev1sec1-5">5</a>), it denotes the <em>value</em> of <code>TOP</code>, namely the address of the top card node. This difference between assembly language and higher-level language is a frequent source of confusion for beginning programmers, so the reader is urged to work <a href="../Text/ch02.html#ch02ex_1_1_7">exercise 7</a>. The other exercises also provide useful drills on the notational conventions introduced in this section.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_1a" id="ch02ex_1_1_1">1</a>.</strong> [<em>04</em>] In the situation depicted in (<a href="../Text/ch02.html#ch02eq-lev1sec1-3">3</a>), what is the value of (a) <code>SUIT</code>(<code>NEXT</code>(<code>TOP</code>)); (b) <code>NEXT</code>(<code>NEXT</code>(<code>NEXT</code>(<code>TOP</code>))) ?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_2a" id="ch02ex_1_1_2">2</a>.</strong> [<em>10</em>] The text points out that in many cases <code>CONTENTS</code>(<code>LOC</code>(<code>V</code>)) = <code>V</code>. Under what conditions do we have <code>LOC</code>(<code>CONTENTS</code>(<code>V</code>)) = <code>V</code>?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_3a" id="ch02ex_1_1_3">3</a>.</strong> [<em>11</em>] Give an algorithm that essentially undoes the effect of <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>: It removes the top card of the pile (if the pile is not empty) and sets <code>NEWCARD</code> to the address of this card.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_4a" id="ch02ex_1_1_4">4</a>.</strong> [<em>18</em>] Give an algorithm analogous to <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>, except that it puts the new card <em>face down</em> at the <em>bottom</em> of the pile. (The pile may be empty.)</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_1_1_5a" id="ch02ex_1_1_5">5</a>.</strong> [<em>21</em>] Give an algorithm that essentially undoes the effect of <a href="../Text/ch02.html#ch02ex_1_1_4">exercise 4</a>: Assuming that the pile is not empty and that its bottom card is face down, your algorithm should <a id="page_237"></a>remove the bottom card and make <code>NEWCARD</code> link to it. (This algorithm is sometimes called “cheating” in solitaire games.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_6a" id="ch02ex_1_1_6">6</a>.</strong> [<em>06</em>] In the playing card example, suppose that <code>CARD</code> is the name of a variable whose value is an entire node as in (<a href="../Text/ch02.html#ch02eq-lev1sec1-6">6</a>). The operation <code>CARD</code> ← <code>NODE</code>(<code>TOP</code>) sets the fields of <code>CARD</code> respectively equal to those of the top of the pile. After this operation, which of the following notations stands for the suit of the top card? (a) <code>SUIT</code>(<code>CARD</code>); (b) <code>SUIT</code>(<code>LOC</code>(<code>CARD</code>)); (c) <code>SUIT</code>(<code>CONTENTS</code>(<code>CARD</code>)); (d) <code>SUIT</code>(<code>TOP</code>) ?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_1_1_7a" id="ch02ex_1_1_7">7</a>.</strong> [<em>04</em>] In the text’s example <code>MIX</code> program, (<a href="../Text/ch02.html#ch02eq-lev1sec1-5">5</a>), the link variable <code>TOP</code> is stored in the <code>MIX</code> computer word whose assembly language name is <code>TOP</code>. Given the field structure (<a href="../Text/ch02.html#ch02eq-lev1sec1-1">1</a>), which of the following sequences of code brings the quantity <code>NEXT</code>(<code>TOP</code>) into register A? Explain why the other sequence is incorrect.</p>

  <p class="left">a) <code>LDA</code>&nbsp;&nbsp;&nbsp;<code>TOP(NEXT)</code></p>

  <p class="left">b) <code>LD1</code>&nbsp;&nbsp;&nbsp;<code>TOP</code><br>
  &nbsp;&nbsp;&nbsp;&nbsp;<code>LDA</code>&nbsp;&nbsp;&nbsp;<code>0,1(NEXT)</code></p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_1_1_8a" id="ch02ex_1_1_8">8</a>.</strong> [<em>18</em>] Write a <code>MIX</code> program corresponding to steps B1–B3.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_1_1_9a" id="ch02ex_1_1_9">9</a>.</strong> [<em>23</em>] Write a <code>MIX</code> program that prints out the alphabetic names of the current contents of the card pile, starting at the top card, with one card per line, and with parentheses around cards that are face down.</p>

  <div class="heading">
    <h3 id="ch02lev1sec2"><a id="page_238"></a>2.2. Linear Lists</h3>

    <div class="heading">
      <h4 id="ch02lev2sec1">2.2.1. Stacks, Queues, and Deques</h4>

      <p>D<small>ATA USUALLY</small> has much more structural information than we actually want to represent directly in a computer. For example, each “playing card” node in the preceding section had a <code>NEXT</code> field to specify what card was beneath it in the pile, but we provided no direct way to find what card, if any, was <em>above</em> a given card, or to find what pile a given card was in. And of course we totally suppressed most of the characteristic features of <em>real</em> playing cards: the details of the design on the back, the relation to other objects in the room where the game was being played, the individual molecules within the cards, etc. It is conceivable that such structural information would be relevant in certain computer applications, but obviously we never want to store <em>all</em> of the structure that is present in every situation. Indeed, for most card-playing situations we would not need all of the facts retained in the earlier example; the <code>TAG</code> field, which tells whether a card is face up or face down, will often be unnecessary.</p>
    </div>
  </div>

  <p class="indent">We must decide in each case how much structure to represent in our tables, and how accessible to make each piece of information. To make such decisions, we need to know what operations are to be performed on the data. For each problem considered in this chapter, therefore, <em>we consider not only the data structure but also the class of operations to be done on the data;</em> the design of computer representations depends on the desired function of the data as well as on its intrinsic properties. Indeed, an emphasis on function as well as form is basic to design problems in general.</p>

  <p class="indent">In order to illustrate this point further, let’s consider a related aspect of computer hardware design. A computer memory is often classified as a “random access memory,” like <code>MIX</code>’s main memory; or as a “read-only memory,” which is supposed to contain essentially constant information; or a “secondary bulk memory,” like <code>MIX</code>’s disk units, which cannot be accessed at high speed although large quantities of information can be stored; or an “associative memory,” more properly called a “content-addressed memory,” for which information is addressed by its value rather than by its location; and so on. The intended function of each kind of memory is so important that it enters into the name of the particular memory type; all of these devices are “memory” units, but the purposes to which they are put profoundly influence their design and their cost.</p>

  <p class="indent">A <em>linear list</em> is a sequence of <em>n</em> ≥ 0 nodes <code>X</code>[1], <code>X</code>[2], . . ., <code>X</code>[<em>n</em>] whose essential structural properties involve only the relative positions between items as they appear in a line. The only things we care about in such structures are the facts that, if <em>n</em> &gt; 0, <code>X</code>[1] is the first node and <code>X</code>[<em>n</em>] is the last; and if 1 <em>&lt; k &lt; n</em>, the <em>k</em>th node <code>X</code>[<em>k</em>] is preceded by <code>X</code>[<em>k</em> − 1] and followed by <code>X</code>[<em>k</em> + 1].</p>

  <p class="indent">The operations we might want to perform on linear lists include, for example, the following.</p>

  <p class="indenti">i) Gain access to the <em>k</em>th node of the list to examine and/or to change the contents of its fields.</p>

  <p class="indenti"><a id="page_239"></a>ii) Insert a new node just before or after the <em>k</em>th node.</p>

  <p class="indenti">iii) Delete the <em>k</em>th node.</p>

  <p class="indenti">iv) Combine two or more linear lists into a single list.</p>

  <p class="indenti">v) Split a linear list into two or more lists.</p>

  <p class="indenti">vi) Make a copy of a linear list.</p>

  <p class="indenti">vii) Determine the number of nodes in a list.</p>

  <p class="indenti">viii) Sort the nodes of the list into ascending order based on certain fields of the nodes.</p>

  <p class="indenti">ix) Search the list for the occurrence of a node with a particular value in some field.</p>

  <p>In operations (i), (ii), and (iii) the special cases <em>k</em> = 1 and <em>k</em> = <em>n</em> are of principal importance, since the first and last items of a linear list may be easier to get at than a general element is. We will not discuss operations (viii) and (ix) in this chapter, since those topics are the subjects of Chapters 5 and 6, respectively.</p>

  <p class="indent">A computer application rarely calls for all nine of these operations in their full generality, so we find that there are many ways to represent linear lists depending on the class of operations that are to be done most frequently. It is difficult to design a single representation method for linear lists in which all of these operations are efficient; for example, the ability to gain access to the <em>k</em>th node of a long list for random <em>k</em> is comparatively hard to do if at the same time we are inserting and deleting items in the middle of the list. Therefore we distinguish between types of linear lists depending on the principal operations to be performed, just as we have noted that computer memories are distinguished by their intended applications.</p>

  <p class="indent">Linear lists in which insertions, deletions, and accesses to values occur almost always at the first or the last node are very frequently encountered, and we give them special names:</p>

  <p class="indentii">A <em>stack</em> is a linear list for which all insertions and deletions (and usually all accesses) are made at one end of the list.</p>

  <p class="indentii">A <em>queue</em> is a linear list for which all insertions are made at one end of the list; all deletions (and usually all accesses) are made at the other end.</p>

  <p class="indentii">A <em>deque</em> (“double-ended queue”) is a linear list for which all insertions and deletions (and usually all accesses) are made at the ends of the list.</p>

  <p>A deque is therefore more general than a stack or a queue; it has some properties in common with a deck of cards, and it is pronounced the same way. We also distinguish <em>output-restricted</em> or <em>input-restricted</em> deques, in which deletions or insertions, respectively, are allowed to take place at only one end.</p>

  <p class="indent">In some disciplines the word “queue” has been used in a much broader sense, to describe any kind of list that is subject to insertions and deletions; the special cases identified above are then called various “queuing disciplines.” Only the restricted use of the term “queue” is intended in this book, however, by analogy with orderly queues of people waiting in line for service.</p>

  <p class="indent"><a id="page_240"></a>Sometimes it helps to understand the mechanism of a stack in terms of an analogy from the switching of railroad cars, as suggested by E. W. Dijkstra (see <a href="../Text/ch02.html#ch02fig01">Fig. 1</a>). A corresponding picture for deques is shown in <a href="../Text/ch02.html#ch02fig02">Fig. 2</a>.</p>

  <div class="image">
    <a id="ch02fig01"></a><img src="../Images/ch02/02fig01.jpg">

    <p class="fig-caption"><strong>Fig. 1.</strong> A stack represented as a railway switching network.</p>
  </div>

  <div class="image">
    <a id="ch02fig02"></a><img src="../Images/ch02/02fig02.jpg">

    <p class="fig-caption"><strong>Fig. 2.</strong> A deque represented as a railway switching network.</p>
  </div>

  <p class="indent">With a stack we always remove the “youngest” item currently in the list, namely the one that has been inserted more recently than any other. With a queue just the opposite is true: The “oldest” item is always removed; the nodes leave the list in the same order as they entered it.</p>

  <p class="indent">Many people who have independently realized the importance of stacks and queues have given them other names: Stacks have been called push-down lists, reversion storages, cellars, nesting stores, piles, last-in-first-out (“LIFO”) lists, and even yo-yo lists. Queues are sometimes called circular stores or first-in-first-out (“FIFO”) lists. The terms LIFO and FIFO have been used for many years by accountants, as names of methods for pricing inventories. Still another term, “shelf,” has been applied to output-restricted deques, and input-restricted deques have been called “scrolls” or “rolls.” This multiplicity of names is interesting in itself, since it is evidence for the importance of the concepts. The words stack and queue are gradually becoming standard terminology; of all the other words listed above, only “push-down list” is still reasonably common, particularly in connection with automata theory.</p>

  <p class="indent">Stacks arise quite frequently in practice. We might, for example, go through a set of data and keep a list of exceptional conditions or things to do later; after we’re done with the original set, we can then do the rest of the processing by<a id="page_241"></a> coming back to the list, removing entries until it becomes empty. (The “saddle point” problem, <a href="../Text/ch01b.html#ch01ex_2_13_10">exercise 1.3.2–10</a>, is an instance of this situation.) Either a stack or a queue will be suitable for such a list, but a stack is generally more convenient. We all have “stacks” in our minds when we are solving problems: One problem leads to another and this leads to another; we stack up problems and subproblems and remove them as they are solved. Similarly, the process of entering and leaving subroutines during the execution of a computer program has a stack-like behavior. Stacks are particularly useful for the processing of languages with a nested structure, like programming languages, arithmetic expressions, and the literary German “Schachtelsätze.” In general, stacks occur most frequently in connection with explicitly or implicitly recursive algorithms, and we will discuss this connection thoroughly in Chapter 8.</p>

  <p class="indent">Special terminology is generally used when algorithms refer to these structures: We put an item onto the <em>top</em> of a stack, or take the top item off (see <a href="../Text/ch02.html#ch02fig03">Fig. 3a</a>). The <em>bottom</em> of the stack is the least accessible item, and it will not be removed until all other items have been deleted. (People often say that they <em>push</em> an item <em>down</em> onto a stack, and <em>pop</em> the stack <em>up</em> when the top item is deleted. This terminology comes from an analogy with the stacks of plates often found in cafeterias. The brevity of the words “push” and “pop” has its advantages, but these terms falsely imply a motion of the whole list within computer memory. Nothing is physically pushed down; items are added onto the top, as in haystacks or stacks of boxes.) With queues, we speak of the <em>front</em> and the <em>rear</em> of the queue; things enter at the rear and are removed when they ultimately reach the front position (see <a href="../Text/ch02.html#ch02fig03">Fig. 3b</a>). When referring to deques, we speak of the <em>left</em> and <em>right</em> ends (<a href="../Text/ch02.html#ch02fig03">Fig. 3c</a>). The concepts of top, bottom, front, and rear are sometimes applied to<a id="page_242"></a>deques that are being used as stacks or queues, with no standard conventions as to whether top, bottom, front, and rear should appear at the left or the right.</p>

  <div class="image">
    <a id="ch02fig03"></a><img src="../Images/ch02/02fig03.jpg">

    <p class="fig-caption"><strong>Fig. 3.</strong> Three important classes of linear lists.</p>
  </div>

  <p class="indent">Thus we find it easy to use a rich variety of descriptive words from English in our algorithms: “up-down” terminology for stacks, “waiting in line” terminology for queues, and “left-right” terminology for deques.</p>

  <p class="indent">A little bit of additional notation has proved to be convenient for dealing with stacks and queues: We write</p>

  <div class="equation"><a id="ch02eq-lev2sec1-1"></a><img src="../Images/ch02/242equ01.jpg"></div>

  <p>(when <em>A</em> is a stack) to mean that the value <em>x</em> is <em>inserted</em> on top of stack <em>A</em>, or (when <em>A</em> is a queue) to mean that <em>x</em> is <em>inserted</em> at the rear of the queue. Similarly, the notation</p>

  <div class="equation"><a id="ch02eq-lev2sec1-2"></a><img src="../Images/ch02/242equ02.jpg"></div>

  <p>is used to mean that the variable <em>x</em> is set equal to the value at the top of stack <em>A</em> or at the front of queue <em>A</em>, and this value is <em>deleted</em> from <em>A</em>. Notation (<a href="../Text/ch02.html#ch02eq-lev2sec1-2">2</a>) is meaningless when <em>A</em> is empty — that is, when <em>A</em> contains no values.</p>

  <p class="indent">If <em>A</em> is a nonempty stack, we may write</p>

  <div class="equation"><a id="ch02eq-lev2sec1-3"></a><img src="../Images/ch02/242equ03.jpg"></div>

  <p>to denote its top element.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_1a" id="ch02ex_2_1_1">1</a>.</strong> [<em>06</em>] An input-restricted deque is a linear list in which items may be inserted at one end but removed from either end; clearly an input-restricted deque can operate either as a stack or as a queue, if we consistently remove all items from one of the two ends. Can an output-restricted deque also be operated either as a stack or as a queue?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_1_2a" id="ch02ex_2_1_2">2</a>.</strong> [<em>15</em>] Imagine four railroad cars positioned on the input side of the track in <a href="../Text/ch02.html#ch02fig01">Fig. 1</a>, numbered 1, 2, 3, and 4, from left to right. Suppose we perform the following sequence of operations (which is compatible with the direction of the arrows in the diagram and does not require cars to “jump over” other cars): (i) move car 1 into the stack; (ii) move car 2 into the stack; (iii) move car 2 into the output; (iv) move car 3 into the stack; (v) move car 4 into the stack; (vi) move car 4 into the output; (vii) move car 3 into the output; (viii) move car 1 into the output.</p>

  <p class="exercises1N">As a result of these operations the original order of the cars, 1234, has been changed into 2431. <em>It is the purpose of this exercise and the following exercises to examine what permutations are obtainable in such a manner from stacks, queues, or deques.</em></p>

  <p class="exercises1N">If there are six railroad cars numbered 123456, can they be permuted into the order 325641? Can they be permuted into the order 154623? (In case it is possible, show how to do it.)</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_3a" id="ch02ex_2_1_3">3</a>.</strong> [<em>25</em>] The operations (i) through (viii) in the previous exercise can be much more concisely described by the code SSXSSXXX, where S stands for “move a car from the input into the stack,” and X stands for “move a car from the stack into the output.” Some sequences of S’s and X’s specify meaningless operations, since there may be no cars available on the specified track; for example, the sequence SXXSSXXS cannot be carried out, since we assume that the stack is initially empty.</p>

  <p class="exercises1N"><a id="page_243"></a>Let us call a sequence of S’s and X’s <em>admissible</em> if it contains <em>n</em> S’s and <em>n</em> X’s, and if it specifies no operations that cannot be performed. Formulate a rule by which it is easy to distinguish between admissible and inadmissible sequences; show furthermore that no two different admissible sequences give the same output permutation.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_4a" id="ch02ex_2_1_4">4</a>.</strong> [<em>M34</em>] Find a simple formula for <em>a<sub>n</sub></em>, the number of permutations on <em>n</em> elements that can be obtained with a stack like that in <a href="../Text/ch02.html#ch02ex_2_1_2">exercise 2</a>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_1_5a" id="ch02ex_2_1_5">5</a>.</strong> [<em>M28</em>] Show that it is possible to obtain a permutation <em>p</em><sub>1</sub><em>p</em><sub>2</sub>. . . <em>p</em><sub><em>n</em></sub> from 12 . . . <em>n</em> using a stack if and only if there are no indices <em>i</em> &lt; <em>j</em> &lt; <em>k</em> such that <em>p</em><sub><em>j</em></sub> &lt; <em>p</em><sub><em>k</em></sub> &lt; <em>p</em><sub><em>i</em></sub>.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_6a" id="ch02ex_2_1_6">6</a>.</strong> [<em>00</em>] Consider the problem of <a href="../Text/ch02.html#ch02ex_2_1_2">exercise 2</a>, with a queue substituted for a stack. What permutations of 12 <em>. . . n</em> can be obtained with use of a queue?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_1_7a" id="ch02ex_2_1_7">7</a>.</strong> [<em>25</em>] Consider the problem of <a href="../Text/ch02.html#ch02ex_2_1_2">exercise 2</a>, with a deque substituted for a stack. (a) Find a permutation of 1234 that can be obtained with an input-restricted deque, but it cannot be obtained with an output-restricted deque. (b) Find a permutation of 1234 that can be obtained with an output-restricted deque but not with an input-restricted deque. [As a consequence of (a) and (b), there is definitely a difference between input-restricted and output-restricted deques.] (c) Find a permutation of 1234 that cannot be obtained with either an input-restricted or an output-restricted deque.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_8a" id="ch02ex_2_1_8">8</a>.</strong> [<em>22</em>] Are there any permutations of 12 <em>. . . n</em> that cannot be obtained with the use of a deque that is neither input-nor output-restricted?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_1_9a" id="ch02ex_2_1_9">9</a>.</strong> [<em>M20</em>] Let <em>b</em><sub><em>n</em></sub> be the number of permutations on <em>n</em> elements obtainable by the use of an input-restricted deque. (Note that <em>b</em><sub>4</sub> = 22, as shown in <a href="../Text/ch02.html#ch02ex_2_1_7">exercise 7</a>.) Show that <em>b</em><sub><em>n</em></sub> is also the number of permutations on <em>n</em> elements with an <em>output</em>-restricted deque.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_1_10a" id="ch02ex_2_1_10">10</a>.</strong> [<em>M25</em>] (See <a href="../Text/ch02.html#ch02ex_2_1_3">exercise 3</a>.) Let S, <code>Q</code>, and <code>X</code> denote respectively the operations of in-serting an element at the left, inserting an element at the right, and emitting an element from the left, of an output-restricted deque. For example, the sequence QQXSXSXX will transform the input sequence 1234 into 1342. The sequence SXQSXSXX gives the same transformation.</p>

  <p class="exercises1N">Find a way to define the concept of an <em>admissible</em> sequence of the symbols S, Q, and X, so that the following property holds: Every permutation of <em>n</em> elements that is attainable with an output-restricted deque corresponds to precisely one admissible sequence.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_1_11a" id="ch02ex_2_1_11">11</a>.</strong> [<em>M40</em>] As a consequence of <a href="../Text/ch02.html#ch02ex_2_1_9">exercises 9</a> and <a href="../Text/ch02.html#ch02ex_2_1_10">10</a>, the number <em>b</em><sup>n</sup> is the number of admissible sequences of length 2<em>n</em>. Find a closed form for the generating function ∑<sub><em>n</em>≥0</sub><em>b</em><sub><em>n</em></sub><em>z</em><sup><em>n</em></sup>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_1_12a" id="ch02ex_2_1_12">12</a>.</strong> [<em>HM34</em>] Compute the asymptotic values of the quantities <em>a</em><sub><em>n</em></sub> and <em>b</em><sub><em>n</em></sub> in <a href="../Text/ch02.html#ch02ex_2_1_4">exercises 4</a> and <a href="../Text/ch02.html#ch02ex_2_1_11">11</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_1_13a" id="ch02ex_2_1_13">13</a>.</strong> [<em>M48</em>] How many permutations of <em>n</em> elements are obtainable with the use of a general deque? [See Rosenstiehl and Tarjan, <em>J. Algorithms</em> <strong>5</strong> (1984), 389–390, for an algorithm that decides in <em>O</em>(<em>n</em>) steps whether or not a given permutation is obtainable.]</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_1_14a" id="ch02ex_2_1_14">14</a>.</strong> [<em>26</em>] Suppose you are allowed to use only stacks as data structures. How can you implement a queue efficiently with two stacks?</p>

  <div class="heading">
    <h4 id="ch02lev2sec2"><a id="page_244"></a>2.2.2. Sequential Allocation</h4>

    <p>The simplest and most natural way to keep a linear list inside a computer is to put the list items in consecutive locations, one node after the other. Then we will have</p>
  </div>

  <p class="center"><code>LOC</code>(<code>X</code>[ <em>j</em> + 1]) = <code>LOC</code>(<code>X</code>[ <em>j</em>]) + <em>c,</em></p>

  <p>where <em>c</em> is the number of words per node. (Usually <em>c</em> = 1. When <em>c</em> &gt; 1, it is sometimes more convenient to split a single list into <em>c</em> “parallel” lists, so that the <em>k</em>th word of node <code>X</code>[<em>j</em>] is stored a fixed distance from the location of the first word of <code>X</code>[ <em>j</em>], depending on <em>k</em>. We will continually assume, however, that adjacent groups of <em>c</em> words form a single node.) In general,</p>

  <div class="equation"><a id="ch02eq-lev2sec2-1"></a><img src="../Images/ch02/244equ01.jpg"></div>

  <p>where <code>L</code><sub>0</sub> is a constant called the <em>base address</em>, the location of an artificially assumed node <code>X</code>[0].</p>

  <p class="indent">This technique for representing a linear list is so obvious and well-known that there seems to be no need to dwell on it at any length. But we will be seeing many other “more sophisticated” methods of representation later on in this chapter, and it is a good idea to examine the simple case first to see just how far we can go with it. It is important to understand the limitations as well as the power of the use of sequential allocation.</p>

  <p class="indent">Sequential allocation is quite convenient for dealing with a <em>stack</em>. We simply have a variable <code>T</code> called the <em>stack pointer</em>. When the stack is empty, we let <code>T</code> = 0. To place a new element <code>Y</code> on top of the stack, we set</p>

  <div class="equation"><a id="ch02eq-lev2sec2-2"></a><img src="../Images/ch02/244equ02.jpg"></div>

  <p>And when the stack is not empty, we can set <code>Y</code> equal to the top node and delete that node by reversing the actions of (<a href="../Text/ch02.html#ch02eq-lev2sec2-2">2</a>):</p>

  <div class="equation"><a id="ch02eq-lev2sec2-3"></a><img src="../Images/ch02/244equ03.jpg"></div>

  <p>(Inside a computer it is usually most efficient to maintain the value <em>c</em><code>T</code> instead of <code>T</code>, because of (<a href="../Text/ch02.html#ch02eq-lev2sec2-1">1</a>). Such modifications are easily made, so we will continue our discussion as though <em>c</em> = 1.)</p>

  <p class="indent">The representation of a <em>queue</em> or a more general <em>deque</em> is a little trickier. An obvious solution is to keep two pointers, say <code>F</code> and <code>R</code> (for the front and rear of the queue), with <code>F</code> = <code>R</code> = 0 when the queue is empty. Then inserting an element at the rear of the queue would be</p>

  <div class="equation"><a id="ch02eq-lev2sec2-4"></a><img src="../Images/ch02/244equ04.jpg"></div>

  <p>Removing the front node (<code>F</code> points just below the front) would be</p>

  <div class="equation"><a id="ch02eq-lev2sec2-5"></a><img src="../Images/ch02/244equ05.jpg"></div>

  <p>But note what can happen: If <code>R</code> always stays ahead of <code>F</code> (so that there is always at least one node in the queue) the table entries used are <code>X</code>[1], <code>X</code>[2], . . ., <code>X</code>[1000], . . ., ad infinitum, and this is terribly wasteful of storage space. The simple method of (<a href="../Text/ch02.html#ch02eq-lev2sec2-4">4</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec2-5">5</a>) should therefore be used only in the situation <a id="page_245"></a>when <code>F</code> is known to catch up to <code>R</code> quite regularly — for example, if all deletions come in spurts that empty the queue.</p>

  <p class="indent">To circumvent the problem of the queue overrunning memory, we can set aside <code>M</code> nodes <code>X</code>[1]<em>, . . .,</em> <code>X</code>[<code>M</code>] arranged implicitly in a circle with <code>X</code>[1] following <code>X</code>[<code>M</code>]. Then processes (<a href="../Text/ch02.html#ch02eq-lev2sec2-4">4</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec2-5">5</a>) above become</p>

  <div class="equation"><a id="ch02eq-lev2sec2-6"></a><img src="../Images/ch02/245equ01.jpg"></div>

  <div class="equation"><a id="ch02eq-lev2sec2-7"></a><img src="../Images/ch02/245equ02.jpg"></div>

  <p>We have, in fact, already seen circular queuing action like this, when we looked at input-output buffering in <a href="../Text/ch01c.html#ch01lev2sec18">Section 1.4.4</a>.</p>

  <p class="indent">Our discussion so far has been very unrealistic, because we have tacitly assumed that nothing could go wrong. When we deleted a node from a stack or queue, we assumed that there was at least one node present. When we inserted a node into a stack or queue, we assumed that there was room for it in memory. But clearly the method of (<a href="../Text/ch02.html#ch02eq-lev2sec2-6">6</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec2-7">7</a>) allows at most <code>M</code> nodes in the entire queue, and methods (<a href="../Text/ch02.html#ch02eq-lev2sec2-2">2</a>), (<a href="../Text/ch02.html#ch02eq-lev2sec2-3">3</a>), (<a href="../Text/ch02.html#ch02eq-lev2sec2-4">4</a>), (<a href="../Text/ch02.html#ch02eq-lev2sec2-5">5</a>) allow <code>T</code> and <code>R</code> to reach only a certain maximum amount within any given computer program. The following specifications show how the actions should be rewritten for the common case where we do not assume that these restrictions are automatically satisfied:</p>

  <div class="equation"><a id="ch02eq1"></a><img src="../Images/ch02/245equ03.jpg"></div>

  <div class="equation"><a id="ch02eq2"></a><img src="../Images/ch02/245equ04.jpg"></div>

  <div class="equation"><a id="ch02eq3"></a><img src="../Images/ch02/245equ05.jpg"></div>

  <div class="equation"><a id="ch02eq4"></a><img src="../Images/ch02/245equ06.jpg"></div>

  <p>Here we assume that <code>X</code>[1]<em>, . . .,</em> <code>X</code>[<code>M</code>] is the total amount of space allowed for the list; <code>OVERFLOW</code> and <code>UNDERFLOW</code> mean an excess or deficiency of items. The initial setting <code>F</code> = <code>R</code> = 0 for the queue pointers is no longer valid when we use (<a href="../Text/ch02.html#ch02eq3">6a</a>) and (<a href="../Text/ch02.html#ch02eq4">7a</a>), because overflow will not be detected when <code>F</code> = 0; we should start with <code>F</code> = <code>R</code> = 1, say.</p>

  <p class="indent">The reader is urged to work <a href="../Text/ch02.html#ch02ex_2_2_1">exercise 1</a>, which discusses a nontrivial aspect of this simple queuing mechanism.</p>

  <p class="indent">The next question is, “What do we do when <code>UNDERFLOW</code> or <code>OVERFLOW</code> occurs?” In the case of <code>UNDERFLOW</code>, we have tried to remove a nonexistent item; this is usually a meaningful condition — not an error situation — that can be used to govern the flow of a program. For example, we might want to delete items repeatedly until <code>UNDERFLOW</code> occurs. An <code>OVERFLOW</code> situation, however, is <a id="page_246"></a>usually an error; it means that the table is full already, yet there is still more information waiting to be put in. The usual policy in case of <code>OVERFLOW</code> is to report reluctantly that the program cannot go on because its storage capacity has been exceeded; then the program terminates.</p>

  <p class="indent">Of course we hate to give up in an <code>OVERFLOW</code> situation when only one list has gotten too large, while other lists of the same program may very well have plenty of room remaining. In the discussion above we were primarily thinking of a program with only one list. However, we frequently encounter programs that involve several stacks, each of which has a dynamically varying size. In such a situation we don’t want to impose a maximum size on each stack, since the size is usually unpredictable; and even if a maximum size has been determined for each stack, we will rarely find <em>all</em> stacks simultaneously filling their maximum capacity.</p>

  <p class="indent">When there are just two variable-size lists, they can coexist together very nicely if we let the lists grow toward each other:</p>

  <div class="image"><img src="../Images/ch02/246fig01.jpg"></div>

  <p>Here list 1 expands to the right, and list 2 (stored in reverse order) expands to the left. <code>OVERFLOW</code> will not occur unless the total size of both lists exhausts all memory space. The lists may independently expand and contract so that the effective maximum size of each one could be significantly more than half of the available space. This layout of memory space is used very frequently.</p>

  <p class="indent">We can easily convince ourselves, however, that there is no way to store three or more variable-size sequential lists in memory so that (a) <code>OVERFLOW</code> will occur only when the total size of all lists exceeds the total space, and (b) each list has a fixed location for its “bottom” element. When there are, say, ten or more variable-size lists — and this is not unusual — the storage allocation problem becomes very significant. If we wish to satisfy condition (a), we must give up condition (b); that is, we must allow the “bottom” elements of the lists to change their positions. This means that the location <code>L</code><sub>0</sub> of Eq. (<a href="../Text/ch02.html#ch02eq-lev2sec2-1">1</a>) is not constant any longer; no reference to the table may be made to an absolute memory address, since all references must be relative to the base address <code>L</code><sub>0</sub>. In the case of <code>MIX</code>, the coding to bring the <code>I</code>th one-word node into register A is changed from</p>

  <div class="equation"><a id="ch02eq-lev2sec2-8"></a><img src="../Images/ch02/246equ01.jpg"></div>

  <p>where <code>BASE</code> contains <span class="image"><img src="../Images/ch02/e246_01.jpg"></span>. Such relative addressing evidently takes longer than fixed-base addressing, although it would be only slightly slower if <code>MIX</code> had an “indirect addressing” feature (see <a href="../Text/ch02.html#ch02ex_2_2_3">exercise 3</a>).</p>

  <p class="indent"><a id="page_247"></a>An important special case occurs when each of the variable-size lists is a stack. Then, since only the top element of each stack is relevant at any time, we can proceed almost as efficiently as before. Suppose that we have <em>n</em> stacks; the insertion and deletion algorithms above become the following, if <code>BASE</code>[<em>i</em>] and <code>TOP</code>[<em>i</em>] are link variables for the <em>i</em>th stack, and if each node is one word long:</p>

  <div class="equation"><a id="ch02eq-lev2sec2-9"></a><img src="../Images/ch02/247equ01.jpg"></div>

  <div class="equation"><a id="ch02eq-lev2sec2-10"></a><img src="../Images/ch02/247equ02.jpg"></div>

  <p>Here <code>BASE</code>[<em>i</em> + 1] is the base location of the (<em>i</em> + 1)st stack. The condition <code>TOP</code>[<em>i</em>] = <code>BASE</code>[<em>i</em>] means that stack <em>i</em> is empty.</p>

  <p class="indent">In (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>), <code>OVERFLOW</code> is no longer such a crisis as it was before; we can “repack memory,” making room for the table that overflowed by taking some away from tables that aren’t yet filled. Several ways to do the repacking suggest themselves; we will now consider some of them in detail, since they can be quite important when linear lists are allocated sequentially. We will start by giving the simplest of the methods, and will then consider some of the alternatives.</p>

  <p class="indent">Assume that there are <em>n</em> stacks, and that the values <code>BASE</code>[<em>i</em>] and <code>TOP</code>[<em>i</em>] are to be treated as in (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec2-10">10</a>). These stacks are all supposed to share a common memory area consisting of all locations <code>L</code> with <code>L</code><sub>0</sub> &lt; <code>L</code> ≤ <code>L</code><sub>∞</sub>. (Here <code>L</code><sub>0</sub> and <code>L</code><sub>∞</sub> are constants that specify the total number of words available for use.) We might start out with all stacks empty, and</p>

  <div class="equation"><a id="ch02eq-lev2sec2-11"></a><img src="../Images/ch02/247equ03.jpg"></div>

  <p>We also set <code>BASE</code>[<em>n</em> + 1] = <code>L</code><sub>∞</sub> so that (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>) will work properly for <em>i</em> = <em>n</em>.</p>

  <p class="indent">When <code>OVERFLOW</code> occurs with respect to stack <em>i</em>, there are three possibilities:</p>

  <p class="indentB">a) We find the smallest <em>k</em> for which <em>i</em> &lt; <em>k</em> ≤ <em>n</em> and <code>TOP</code>[<em>k</em>] &lt; <code>BASE</code>[<em>k</em> + 1], if any such <em>k</em> exist. Now move things <em>up</em> one notch:</p>

  <p class="center">Set <code>CONTENTS</code>(<code>L</code> + 1) ← <code>CONTENTS</code>(<code>L</code>),&nbsp;&nbsp;&nbsp;for <code>TOP</code>[<em>k</em>] ≥ <code>L</code> &gt; <code>BASE</code>[<em>i</em> + 1].</p>

  <p class="indenthangingAP">(This must be done for decreasing, not increasing, values of <code>L</code> to avoid losing information. It is possible that <code>TOP</code>[<em>k</em>] = <code>BASE</code>[<em>i</em> + 1], in which case nothing needs to be moved.) Finally we set <code>BASE</code>[ <em>j</em>] ← <code>BASE</code>[ <em>j</em>] + 1 and <code>TOP</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] + 1, for <em>i</em> &lt; <em>j</em> ≤ <em>k</em>.</p>

  <p class="indentB">b) No <em>k</em> can be found as in (a), but we find the largest <em>k</em> for which 1 ≤ <em>k &lt; i</em> and <code>TOP</code>[<em>k</em>] &lt; <code>BASE</code>[<em>k</em> + 1]. Now move things <em>down</em> one notch:</p>

  <p class="center">Set <code>CONTENTS</code>(<code>L</code> − 1) ← <code>CONTENTS</code>(<code>L</code>),&nbsp;&nbsp;&nbsp;for <code>BASE</code>[<em>k</em> + 1] &lt; <code>L</code> &lt; <code>TOP</code>[<em>i</em>].</p>

  <p class="indenthangingAP">(This must be done for increasing values of <code>L</code>.) Then set <code>BASE</code>[ <em>j</em>] ← <code>BASE</code>[ <em>j</em>] − 1 and <code>TOP</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] − 1, for <em>k &lt; j</em> ≤ <em>i</em>.</p>

  <p class="indentB">c) We have <code>TOP</code>[<em>k</em>] = <code>BASE</code>[<em>k</em> + 1] for all <em>k</em> ≠ <em>i</em>. Then obviously we cannot find room for the new stack entry, and we must give up.</p>

  <p class="indent"><a id="page_248"></a><a href="../Text/ch02.html#ch02fig04">Figure 4</a> illustrates the configuration of memory for the case <em>n</em> = 4, <code>L</code><sub>o</sub> = 0, <code>L</code><sub>∞</sub> = 20, after the successive actions</p>

  <div class="equation"><a id="ch02eq-lev2sec2-12"></a><img src="../Images/ch02/248equ01.jpg"></div>

  <div class="image">
    <a id="ch02fig04"></a><img src="../Images/ch02/02fig04.jpg">

    <p class="fig-caption"><strong>Fig. 4.</strong> Example of memory configuration after several insertions and deletions.</p>
  </div>

  <p>(Here I<sub><em>j</em></sub> and D<sub><em>j</em></sub> refer to insertion and deletion in stack <em>j</em>, and an asterisk refers to an occurrence of <code>OVERFLOW</code>, assuming that no space is initially allocated to stacks 1, 2, and 3.)</p>

  <p class="indent">It is clear that many of the first stack overflows that occur with this method could be eliminated if we chose our initial conditions wisely, instead of allocating all space initially to the <em>n</em>th stack as suggested in (<a href="../Text/ch02.html#ch02eq-lev2sec2-11">11</a>). For example, if we expect each stack to be of the same size, we can start out with</p>

  <div class="equation"><a id="ch02eq-lev2sec2-13"></a><img src="../Images/ch02/248equ02.jpg"></div>

  <p>Operating experience with a particular program may suggest better starting values; however, no matter how well the initial allocation is set up, it can save at most a fixed number of overflows, and the effect is noticeable only in the early stages of a program run. (See <a href="../Text/ch02.html#ch02ex_2_2_17">exercise 17</a>.)</p>

  <p class="indent">Another possible way to improve the method above would be to make room for more than one new entry each time memory is repacked. This idea has been exploited by J. Garwick, who suggests a complete repacking of memory when overflow occurs, based on the change in size of each stack since the last repacking. His algorithm uses an additional array, called <code>OLDTOP</code> [<em>j</em>], 1 ≤ <em>j</em> ≤ <em>n</em>, which retains the value that <code>TOP</code> [<em>j</em>] had just after the previous allocation of memory. Initially, the tables are set as before, with <code>OLDTOP</code> [<em>j</em>] = <code>TOP</code> [<em>j</em>] . The algorithm proceeds as follows:</p>

  <p><a id="ch02alg-lev2sec2-G"></a><strong>Algorithm G</strong> <em>(Reallocate sequential tables).</em> Assume that <code>OVERFLOW</code> has occurred in stack <em>i</em>, according to (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>). After <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> has been performed, either we will find the memory capacity exceeded or the memory will have been rearranged so that the action <code>CONTENTS</code> (<code>TOP</code> [<em>i</em>]) ← <code>Y</code> may be done. (Notice that <code>TOP</code> [<em>i</em>] has already been increased in (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>) before <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> takes place.)</p>

  <p class="indenthanging"><strong>G1.</strong> [Initialize.] Set <code>SUM</code> ← <code>L</code><sub>∞</sub> - <code>L</code><sub>0</sub>, <code>INC</code> ← 0. Then do step G2 for 1 ≤ <em>j</em> ≤ <em>n</em>. (The effect will be to make <code>SUM</code> equal to the total amount of memory space left, and <code>INC</code> equal to the total amount of increases in table sizes since the last allocation.) After this has been done, go on to step G3.</p>

  <p class="indenthanging"><a id="page_249"></a><strong>G2.</strong> [Gather statistics.] Set <code>SUM</code> ← <code>SUM</code> − (<code>TOP</code>[ <em>j</em>] − <code>BASE</code>[ <em>j</em>]). If <code>TOP</code>[ <em>j</em>] &gt; <code>OLDTOP</code>[ <em>j</em>], set <code>D</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] − <code>OLDTOP</code>[ <em>j</em>] and <code>INC</code> ← <code>INC</code> + <code>D</code>[ <em>j</em>]; otherwise set <code>D</code>[ <em>j</em>] ← 0.</p>

  <p class="indenthanging"><strong>G3.</strong> [Is memory full?] If <code>SUM</code> &lt; 0, we cannot proceed.</p>

  <p class="indenthanging"><strong>G4.</strong> [Compute allocation factors.] Set <em>α</em> ← 0.1 × <code>SUM</code><em>/n</em>, <em>β</em> ← 0.9 × <code>SUM</code>/<code>INC</code>. (Here <em>α</em> and <em>β</em> are fractions, not integers, which are to be computed to reasonable accuracy. The following step awards the available space to individual lists as follows: Approximately 10 percent of the memory presently available will be shared equally among the <em>n</em> lists, and the other 90 percent will be divided proportionally to the amount of increase in table size since the previous allocation.)</p>

  <p class="indenthanging"><strong>G5.</strong> [Compute new base addresses.] Set <code>NEWBASE[</code>1<code>]</code> ← <code>BASE[</code>1<code>]</code> and σ ← 0; then for <em>j</em> = 2, 3, . . ., <em>n</em> set τ ← σ + α + <code>D</code>[ <em>j</em> − 1]β, <code>NEWBASE</code>[ <em>j</em>] ← <code>NEWBASE</code>[ <em>j</em> − 1] + <code>TOP</code>[ <em>j</em> − 1] − <code>BASE</code>[ <em>j</em> − 1] + \lfloor{τ}\rfloor − \lfloor{σ}\rfloor, and σ ← τ .</p>

  <p class="indenthanging"><strong>G6.</strong> [Repack.] Set <code>TOP</code>[<em>i</em>] ← <code>TOP</code>[<em>i</em>] − 1. (This reflects the true size of the <em>i</em>th list, so that no attempt will be made to move information from beyond the list boundary.) Perform <a href="../Text/ch02.html#ch02alg-lev2sec2-R">Algorithm R</a> below, and then reset <code>TOP</code>[<em>i</em>] ←<code>TOP</code>[<em>i</em>] + 1. Finally set <code>OLDTOP</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] for 1 ≤ <em>j</em> ≤ <em>n</em>. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">Perhaps the most interesting part of this whole algorithm is the general repacking process, which we shall now describe. Repacking is not trivial, since some portions of memory shift up and others shift down; it is obviously important not to overwrite any of the good information in memory while it is being moved.</p>

  <p><a id="ch02alg-lev2sec2-R"></a><strong>Algorithm R</strong> <em>(Relocate sequential tables)</em>. For 1 ≤ <em>j</em> ≤ <em>n</em>, the information specified by <code>BASE</code>[<em>j</em>] and <code>TOP</code>[<em>j</em>] in accord with the conventions stated above is moved to new positions specified by <code>NEWBASE</code>[<em>j</em>], and the values of <code>BASE</code>[<em>j</em>] and <code>TOP</code>[<em>j</em>] are suitably adjusted. This algorithm is based on the easily verified fact that the data to be moved downward cannot overlap with any data that is to be moved upward, nor with any data that is supposed to stay put.</p>

  <p class="indenthanging"><strong>R1.</strong> [Initialize.] Set <em>j</em> ← 1.</p>

  <p class="indenthanging"><strong>R2.</strong> [Find start of shift.] (Now all lists from 1 to <em>j</em> that were to be moved down have been shifted into the desired position.) Increase <em>j</em> in steps of 1 until finding either</p>

  <p class="indenthanging-A">a) <code>NEWBASE</code>[ <em>j</em>] &lt; <code>BASE</code>[ <em>j</em>]: Go to R3; or</p>

  <p class="indenthanging-A">b) <em>j &gt; n</em>: Go to R4.</p>

  <p class="indenthanging"><strong>R3.</strong> [Shift list down.] Set δ ← <code>BASE</code>[ <em>j</em>] − <code>NEWBASE</code>[ <em>j</em>]. Set <code>CONTENTS</code>(<code>L</code> − δ) ← <code>CONTENTS</code>(<code>L</code>), for <code>L</code> = <code>BASE</code>[ <em>j</em>] + 1, <code>BASE</code>[ <em>j</em>] + 2, . . ., <code>TOP</code>[ <em>j</em>]. (It is possible for <code>BASE</code>[ <em>j</em>] to equal <code>TOP</code>[ <em>j</em>], in which case no action is required.) Set <code>BASE</code>[ <em>j</em>] ← <code>NEWBASE</code>[ <em>j</em>], <code>TOP</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] − δ. Go back to R2.</p>

  <p class="indenthanging"><strong>R4.</strong> [Find start of shift.] (Now all lists from <em>j</em> to <em>n</em> that were to be moved up have been shifted into the desired position.) Decrease <em>j</em> in steps of 1 until finding either</p>

  <p class="indenthanging-A">a) <code>NEWBASE</code>[ <em>j</em>] &gt; <code>BASE</code>[ <em>j</em>]: Go to R5; or</p>

  <p class="indenthanging-A">b) <em>j</em> = 1: The algorithm terminates.</p>

  <p class="indenthanging"><a id="page_250"></a><strong>R5.</strong> [Shift list up.] Set δ ← <code>NEWBASE</code>[ <em>j</em>] − <code>BASE</code>[ <em>j</em>]. Set <code>CONTENTS</code>(<code>L</code> + δ) ← <code>CONTENTS</code>(<code>L</code>), for <code>L</code> = <code>TOP</code>[ <em>j</em>], <code>TOP</code>[ <em>j</em>] − 1, . . ., <code>BASE</code>[ <em>j</em>] + 1. (As in step R3, no action may actually be needed here.) Set <code>BASE</code>[ <em>j</em>] ← <code>NEWBASE</code>[ <em>j</em>], <code>TOP</code>[ <em>j</em>] ← <code>TOP</code>[ <em>j</em>] + δ. Go back to R4. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">Notice that stack 1 never needs to be moved. Therefore we should put the largest stack first, if we know which one will be largest.</p>

  <p class="indent">In <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithms G</a> and <a href="../Text/ch02.html#ch02alg-lev2sec2-R">R</a> we have purposely made it possible to have</p>

  <p class="center"><code>OLDTOP</code>[ <em>j</em>] ≡ <code>D</code>[ <em>j</em>] ≡ <code>NEWBASE</code>[ <em>j</em> + 1]</p>

  <p>for 1 ≤ <em>j</em> ≤ <em>n</em>; that is, these three tables can share common memory locations since their values are never needed at conflicting times.</p>

  <p class="indent">We have described these repacking algorithms for stacks, but it is clear that they can be adapted to any relatively addressed tables in which the current information is contained between <code>BASE</code>[ <em>j</em>] and <code>TOP</code>[ <em>j</em>]. Other pointers (for example, <code>FRONT</code>[ <em>j</em>] and <code>REAR</code>[ <em>j</em>]) could also be attached to the lists, making them serve as a queue or deque. See <a href="../Text/ch02.html#ch02ex_2_2_8">exercise 8</a>, which considers the case of a queue in detail.</p>

  <p class="indent">The mathematical analysis of dynamic storage-allocation algorithms like those above is extremely difficult. Some interesting results appear in the exercises below, although they only begin to scratch the surface as far as the general behavior is concerned.</p>

  <p class="indent">As an example of the theory that <em>can</em> be derived, suppose we consider the case when the tables grow only by insertion; deletions and subsequent insertions that cancel their effect are ignored. Let us assume further that each table is expected to fill at the same rate. This situation can be modeled by imagining a sequence of <em>m</em> insertion operations <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . ., <em>a<sub>m</sub></em>, where each <em>a<sub>i</sub></em> is an integer between 1 and <em>n</em> (representing an insertion on top of stack <em>a<sub>i</sub></em>). For example, the sequence 1, 1, 2, 2, 1 means two insertions to stack 1, followed by two to stack 2, followed by another onto stack 1. We can regard each of the <em>n<sup>m</sup></em> possible specifications <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . ., <em>a<sub>m</sub></em> as equally likely, and then we can ask for the average number of times it is necessary to move a word from one location to another during the repacking operations as the entire table is built. For the first algorithm, starting with all available space given to the <em>n</em>th stack, this question is analyzed in <a href="../Text/ch02.html#ch02ex_2_2_9">exercise 9</a>. We find that the average number of move operations required is</p>

  <div class="equation"><a id="ch02eq-lev2sec2-14"></a><img src="../Images/ch02/250equ01.jpg"></div>

  <p>Thus, as we might expect, the number of moves is essentially proportional to the <em>square</em> of the number of times the tables grow. The same is true if the individual stacks aren’t equally likely (see <a href="../Text/ch02.html#ch02ex_2_2_10">exercise 10</a>).</p>

  <p class="indent">The moral of the story seems to be that a very large number of moves will be made if a reasonably large number of items is put into the tables. This is the price we must pay for the ability to pack a large number of sequential tables together tightly. No theory has been developed to analyze the average <a id="page_251"></a>behavior of <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a>, and it is unlikely that any simple model will be able to describe the characteristics of real-life tables in such an environment. However, <a href="../Text/ch02.html#ch02ex_2_2_18">exercise 18</a> provides a worst-case guarantee that the running time will not be too bad if the memory doesn’t get too full.</p>

  <p class="indent">Experience shows that when memory is only half loaded (that is, when the available space equals half the total space), we need very little rearranging of the tables with <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a>. The important thing is perhaps that the algorithm behaves well in the half-full case and that it at least delivers the right answers in the almost-full case.</p>

  <p class="indent">But let us think about the almost-full case more carefully. When the tables nearly fill memory, <a href="../Text/ch02.html#ch02alg-lev2sec2-R">Algorithm R</a> takes rather long to perform its job. And to make matters worse, <code>OVERFLOW</code> is much more frequent just before the memory space is used up. There are very few programs that will come <em>close</em> to filling memory without soon thereafter completely overflowing it; and those that do overflow memory will probably waste enormous amounts of time in <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithms G</a> and <a href="../Text/ch02.html#ch02alg-lev2sec2-R">R</a> just before memory is overrun. Unfortunately, undebugged programs will frequently overflow memory capacity. To avoid wasting all this time, a possible suggestion would be to stop <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> in step G3 if <code>SUM</code> is less than <em>S</em><sub>min</sub>, where the latter is chosen by the programmer to prevent excessive repacking. When there are many variable-size sequential tables, we should <em>not</em> expect to make use of 100 percent of the memory space before storage is exceeded.</p>

  <p class="indent">Further study of <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> has been made by D. S. Wise and D. C. Watson, <em>BIT</em> <strong>16</strong> (1976), 442–450. See also A. S. Fraenkel, <em>Inf. Proc. Letters</em> <strong>8</strong> (1979), 9–10, who suggests working with pairs of stacks that grow towards each other.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_1a" id="ch02ex_2_2_1">1</a>.</strong> [<em>15</em>] In the queue operations given by (<a href="../Text/ch02.html#ch02eq3">6a</a>) and (<a href="../Text/ch02.html#ch02eq4">7a</a>), how many items can be in the queue at one time without <code>OVERFLOW</code> occurring?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_2a" id="ch02ex_2_2_2">2</a>.</strong> [<em>22</em>] Generalize the method of (<a href="../Text/ch02.html#ch02eq3">6a</a>) and (<a href="../Text/ch02.html#ch02eq4">7a</a>) so that it will apply to any deque with fewer than <code>M</code> elements. In other words, give specifications for the other two operations, “delete from rear” and “insert at front.”</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_2_3a" id="ch02ex_2_2_3">3</a>.</strong> [<em>21</em>] Suppose that <code>MIX</code> is extended as follows: The <code>I</code>-field of each instruction is to have the form 8<code>I</code><sub>1</sub> + <code>I</code><sub>2</sub>, where 0 ≤ <code>I</code><sub>1</sub> &lt; 8, 0 ≤ <code>I</code><sub>2</sub> &lt; 8. In assembly language one writes ‘<code>OP ADDRESS</code>,<code>I</code><sub>1</sub> :<code>I</code><sub>2</sub>’ or (as presently) ‘<code>OP ADDRESS</code>,<code>I</code><sub>2</sub>’ if <code>I</code><sub>1</sub> = 0. The meaning is to perform first the “address modification” <code>I</code><sub>1</sub> on <code>ADDRESS</code>, then to perform the “address modification” <code>I</code><sub>2</sub> on the resulting address, and finally to perform the <code>OP</code> with the new address. The address modifications are defined as follows:</p>

  <p class="uln-indent">0: M = A</p>

  <p class="uln-indent">1: M = A + rI1</p>

  <p class="uln-indent">2: M = A + rI2</p>

  <p class="uln-indent">. . .</p>

  <p class="uln-indent">6: M = A + rI6</p>

  <p class="uln-indenta">7: M = resulting address defined from the ‘<code>ADDRESS</code>,<code>I</code><sub>1</sub> :<code>I</code><sub>2</sub>’ fields found in location A. The case <code>I</code><sub>1</sub> = <code>I</code><sub>2</sub> = 7 in location A is not allowed. (The reason for the latter restriction is discussed in <a href="../Text/ch02.html#ch02ex_2_2_5">exercise 5</a>.)</p>

  <p><a id="page_252"></a>Here A denotes the address before the operation, and M denotes the resulting address after the address modification. In all cases the result is undefined if the value of M does not fit in two bytes and a sign. The execution time is increased by one unit for each “indirect-addressing” (modification 7) operation performed.</p>

  <p class="indent">As a nontrivial example, suppose that location 1000 contains ‘<code>NOP 1000,1:7</code>’; location 1001 contains ‘<code>NOP 1000,2</code>’; and index registers 1 and 2 respectively contain 1 and 2. Then the command ‘<code>LDA 1000,7:2</code>’ is equivalent to ‘<code>LDA 1004</code>’, because</p>

  <p class="center"><code>1000,7:2</code> = <code>(1000,1:7),2</code> = <code>(1001,7),2</code> = <code>(1000,2),2</code> = <code>1002,2</code> = <code>1004</code>.</p>

  <p class="indentsub">a) Using this indirect addressing feature (if necessary), show how to simplify the coding on the right-hand side of (<a href="../Text/ch02.html#ch02eq-lev2sec2-8">8</a>) so that two instructions are saved per reference to the table. How much faster is your code than (<a href="../Text/ch02.html#ch02eq-lev2sec2-8">8</a>)?</p>

  <p class="indentsub1">b) Suppose there are several tables whose base addresses are stored in locations <code>BASE</code> + 1, <code>BASE</code> + 2, <code>BASE</code> + 3, . . .; how can the indirect addressing feature be used to bring the <code>I</code>th element of the <code>J</code>th table into register A in one instruction, assuming that <code>I</code> is in rI1 and J is in rI2?</p>

  <p class="indentsub2">c) What is the effect of the instruction ‘<code>ENT4 X,7</code>’, assuming that the (3 : 3)-field in location <code>X</code> is zero?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_2_4a" id="ch02ex_2_2_4">4</a>.</strong> [<em>25</em>] Assume that <code>MIX</code> has been extended as in <a href="../Text/ch02.html#ch02ex_2_2_3">exercise 3</a>. Show how to give a <em>single instruction</em> (plus auxiliary constants) for each of the following actions:</p>

  <p class="indenthangingA">a) To loop indefinitely because indirect addressing never terminates.</p>

  <p class="indenthangingA">b) To bring into register A the value <code>LINK</code>(<code>LINK</code>(<em>x</em>)), where the value of link variable <em>x</em> is stored in the (0:2) field of the location whose symbolic address is <code>X</code>, the value of <code>LINK</code>(<em>x</em>) is stored in the (0 : 2) field of location <em>x</em>, etc., assuming that the (3 : 3) fields in these locations are zero.</p>

  <p class="indenthangingA">c) To bring into register A the value <code>LINK</code>(<code>LINK</code>(<code>LINK</code>(<em>x</em>))), under assumptions like those in (b).</p>

  <p class="indenthangingA">d) To bring into register A the contents of location rI1 + rI2 + rI3 + rI4 + rI5 + rI6.</p>

  <p class="indenthangingA">e) To quadruple the current value of rI6.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_5a" id="ch02ex_2_2_5">5</a>.</strong> [<em>35</em>] The extension of <code>MIX</code> suggested in <a href="../Text/ch02.html#ch02ex_2_2_3">exercise 3</a> has an unfortunate restriction that “7 : 7” is not allowed in an indirectly addressed location.</p>

  <p class="indenthangingA">a) Give an example to indicate that, without this restriction, it would probably be necessary for the <code>MIX</code> hardware to be capable of maintaining a long internal stack of three-bit items. (This would be prohibitively expensive hardware, even for a mythical computer like <code>MIX</code>.)</p>

  <p class="indenthangingA">b) Explain why such a stack is not needed under the present restriction; in other words, design an algorithm with which the hardware of a computer could perform the desired address modifications without much additional register capacity.</p>

  <p class="indenthangingA">c) Give a milder restriction than that of <a href="../Text/ch02.html#ch02ex_2_2_3">exercise 3</a> on the use of 7:7 that alleviates the difficulties of <a href="../Text/ch02.html#ch02ex_2_2_4">exercise 4</a>(c), yet can be cheaply implemented in computer hardware.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_2_6a" id="ch02ex_2_2_6">6</a>.</strong> [<em>10</em>] Starting with the memory configuration shown in <a href="../Text/ch02.html#ch02fig04">Fig. 4</a>, determine which of the following sequences of operations causes overflow or underflow:</p>

  <p class="center">(a) <code>I</code><sub>1</sub>;&nbsp;&nbsp;&nbsp;&nbsp;(b) <code>I</code><sub>2</sub>;&nbsp;&nbsp;&nbsp;(c) <code>I</code><sub>3</sub>;&nbsp;&nbsp;&nbsp;(d) <code>I</code><sub>4</sub><code>I</code><sub>4</sub><code>I</code><sub>4</sub><code>I</code><sub>4</sub><code>I</code><sub>4</sub>;&nbsp;&nbsp;&nbsp;(e) <code>D</code><sub>2</sub><code>D</code><sub>2</sub><code>I</code><sub>2</sub><code>I</code><sub>2</sub><code>I</code><sub>2</sub>.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_2_7a" id="ch02ex_2_2_7">7</a>.</strong> [<em>12</em>] Step G4 of <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> indicates a division by the quantity <code>INC</code>. Can <code>INC</code> ever be zero at that point in the algorithm?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_8a" id="ch02ex_2_2_8">8</a>.</strong> [<em>26</em>] Explain how to modify (<a href="../Text/ch02.html#ch02eq-lev2sec2-9">9</a>), (<a href="../Text/ch02.html#ch02eq-lev2sec2-10">10</a>), and the repacking algorithms for the case that one or more of the lists is a queue being handled circularly as in (<a href="../Text/ch02.html#ch02eq3">6a</a>) and (<a href="../Text/ch02.html#ch02eq4">7a</a>).</p>

  <p class="exercises2"><a id="page_253"></a><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_9a" id="ch02ex_2_2_9">9</a>.</strong> [<em>M27</em>] Using the mathematical model described near the end of the text, prove that Eq. (<a href="../Text/ch02.html#ch02eq-lev2sec2-14">14</a>) is the expected number of moves. (Note that the sequence 1, 1, 4, 2, 3, 1, 2, 4, 2, 1 specifies 0 + 0 + 0 + 1 + 1 + 3 + 2 + 0 + 3 + 6 = 16 moves.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_10a" id="ch02ex_2_2_10">10</a>.</strong> [<em>M28</em>] Modify the mathematical model of <a href="../Text/ch02.html#ch02ex_2_2_9">exercise 9</a> so that some tables are expected to be larger than others: Let <em>p<sub>k</sub></em> be the probability that <em>a</em><sub><em>j</em></sub> = <em>k</em>, for 1 ≤ <em>j</em> ≤ <em>m</em>, 1 ≤ <em>k</em> ≤ <em>n</em>. Thus <em>p</em><sub>1</sub> + <em>p</em><sub>2</sub> + · · · + <em>p</em><sub><em>n</em></sub> = 1; the previous exercise considered the special case <em>p</em><sub>k</sub> = 1<em>/n</em> for all <em>k</em>. Determine the expected number of moves, as in Eq. (<a href="../Text/ch02.html#ch02eq-lev2sec2-14">14</a>), for this more general case. It is possible to rearrange the relative order of the <em>n</em> lists so that the lists expected to be longer are put to the right (or to the left) of the lists that are expected to be shorter; what relative order for the <em>n</em> lists will minimize the expected number of moves, based on <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, . . ., <em>p</em><sub><em>n</em></sub> ?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_11a" id="ch02ex_2_2_11">11</a>.</strong> [<em>M30</em>] Generalize the argument of <a href="../Text/ch02.html#ch02ex_2_2_9">exercise 9</a> so that the first <em>t</em> insertions in any stack cause no movement, while subsequent insertions are unaffected. Thus if <em>t</em> = 2, the sequence in <a href="../Text/ch02.html#ch02ex_2_2_9">exercise 9</a> specifies 0 + 0 + 0 + 0 + 0 + 3 + 0 + 0 + 3 + 6 = 12 moves. What is the average total number of moves under this assumption? [This is an approximation to the behavior of the algorithm when each stack starts with <em>t</em> available spaces.]</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_12a" id="ch02ex_2_2_12">12</a>.</strong> [<em>M28</em>] The advantage of having two tables coexist in memory by growing towards each other, rather than by having them kept in separate independently bounded areas, may be quantitatively estimated (to a certain extent) as follows. Use the model of <a href="../Text/ch02.html#ch02ex_2_2_9">exercise 9</a> with <em>n</em> = 2; for each of the 2<sup><em>m</em></sup> equally probable sequences <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, . . ., <em>a<sub>m</sub></em>, let there be <em>k</em><sub>1</sub> 1s and <em>k</em><sub>2</sub> 2s. (Here <em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> are the respective sizes of the two tables after the memory is full. We are able to run the algorithm with <em>m</em> = <em>k</em><sub>1</sub> + <em>k</em><sub>2</sub> locations when the tables are adjacent, instead of 2 max(<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>) locations to get the same effect with separate tables.)</p>

  <p class="exercises1N">What is the average value of max(<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>)?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_13a" id="ch02ex_2_2_13">13</a>.</strong> [<em>HM42</em>] The value max(<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>) investigated in <a href="../Text/ch02.html#ch02ex_2_2_12">exercise 12</a> will be even greater if larger fluctuations in the tables are introduced by allowing random <em>deletions</em> as well as random insertions. Suppose we alter the model so that with probability <em>p</em> the sequence value <em>a</em><sub><em>j</em></sub> is interpreted as a deletion instead of an insertion; the process continues until <em>k</em><sub>1</sub> + <em>k</em><sub>2</sub> (the total number of table locations in use) equals <em>m</em>. A deletion from an empty list causes no effect.</p>

  <p class="exercises1N">For example, if <em>m</em> = 4 it can be shown that we get the following probability distribution when the process stops:</p>

  <div class="image"><img src="../Images/ch02/e253_01.jpg"></div>

  <p class="exercisesp">Thus as <em>p</em> increases, the difference between <em>k</em><sub>1</sub> and <em>k</em><sub>2</sub> tends to increase. It is not difficult to show that in the limit as <em>p</em> approaches unity, the distribution of <em>k</em><sub>1</sub> becomes essentially uniform, and the limiting expected value of max(<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>) is exactly <span class="middle"><img src="../Images/ch02/e253_02.jpg"></span>. This behavior is quite different from that in the previous exercise (when <em>p</em> = 0); however, it may not be extremely significant, since when <em>p</em> approaches unity, the amount of time taken to terminate the process rapidly approaches infinity. The problem posed in this exercise is to examine the dependence of max(<em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>) on <em>p</em> and <em>m</em>, and to determine asymptotic formulas for fixed <em>p</em> (like <span class="middle"><img src="../Images/ch02/e253_03.jpg"></span>) as <em>m</em> approaches infinity. The case <span class="middle"><img src="../Images/ch02/e253_04.jpg"></span> is particularly interesting.</p>

  <p class="exercises1"><a id="page_254"></a><strong><a href="../Text/app01a.html#ch02ex_2_2_14a" id="ch02ex_2_2_14">14</a>.</strong> [<em>HM43</em>] Generalize the result of <a href="../Text/ch02.html#ch02ex_2_2_12">exercise 12</a> to arbitrary <em>n</em> ≥ 2, by showing that, when <em>n</em> is fixed and <em>m</em> approaches infinity, the quantity</p>

  <div class="image"><img src="../Images/ch02/e254_01.jpg"></div>

  <p class="exercisesp">has the asymptotic form <em>m/n+c<sub>n</sub><span class="image"><img src="../Images/ch02/root-m.jpg"></span>+O</em>(1). Determine the constants <em>c</em><sub>2</sub>, <em>c</em><sub>3</sub>, <em>c</em><sub>4</sub>, and <em>c</em><sub>5</sub>.</p>

  <p class="exercises1"><strong>15.</strong> [<em>40</em>] Using a Monte Carlo method, simulate the behavior of <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a> under varying distributions of insertions and deletions. What do your experiments imply about the efficiency of <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithm G</a>? Compare its performance with the algorithm given earlier that shifts up and down one node at a time.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_16a" id="ch02ex_2_2_16">16</a>.</strong> [<em>20</em>] The text illustrates how two stacks can be located so they grow towards each other, thereby making efficient use of a common memory area. Can two <em>queues</em>, or a stack and a queue, make use of a common memory area with the same efficiency?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_2_17a" id="ch02ex_2_2_17">17</a>.</strong> [<em>30</em>] If σ is any sequence of insertions and deletions such as (<a href="../Text/ch02.html#ch02eq-lev2sec2-12">12</a>), let <em>s</em><sub>0</sub> (σ) be the number of stack overflows that occur when the simple method of <a href="../Text/ch02.html#ch02fig04">Fig. 4</a> is applied to σ with initial conditions (<a href="../Text/ch02.html#ch02eq-lev2sec2-11">11</a>), and let <em>s</em><sub>1</sub> (σ) be the corresponding number of overflows with respect to other initial conditions such as (<a href="../Text/ch02.html#ch02eq-lev2sec2-13">13</a>). Prove that <em>s</em><sub>0</sub> (σ) ≤ <em>s</em><sub>1</sub> (σ)+<code>L</code><sub>∞</sub> − <code>L</code><sub>0</sub>.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_18a" id="ch02ex_2_2_18">18</a>.</strong> [<em>M30</em>] Show that the total running time for any sequence of <em>m</em> insertions and/or deletions by <a href="../Text/ch02.html#ch02alg-lev2sec2-G">Algorithms G</a> and <a href="../Text/ch02.html#ch02alg-lev2sec2-R">R</a> is <span class="middle"><img src="../Images/ch02/e254_03.jpg"></span>, where α<sub>k</sub> is the fraction of memory occupied on the most recent repacking previous to the <em>k</em>th operation; α<sub><em>k</em></sub> = 0 before the first repacking. (Therefore if the memory never gets more than, say, 90% full, each operation takes at most <em>O</em>(<em>n</em>) units of time in an amortized sense, regardless of the total memory size.) Assume that <code>L</code><sub>∞</sub> – <code>L</code><sub>0</sub> ≥ <em>n</em><sup>2</sup>.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_2_19a" id="ch02ex_2_2_19">19</a>.</strong> [<em>16</em>] (<em>0-origin indexing</em>.) Experienced programmers learn that it is generally wise to denote the elements of a linear list by <code>X</code>[0], <code>X</code>[1], . . ., <code>X</code>[<em>n</em> − 1], instead of using the more traditional notation <code>X</code>[1], <code>X</code>[2], . . ., <code>X</code>[<em>n</em>]. Then, for example, the base address <code>L</code><sub>0</sub> in (<a href="../Text/ch02.html#ch02eq-lev2sec2-1">1</a>) points to the smallest cell of the array.</p>

  <p class="exercises1N">Revise the insertion and deletion methods (<a href="../Text/ch02.html#ch02eq1">2a</a>), (<a href="../Text/ch02.html#ch02eq2">3a</a>), (<a href="../Text/ch02.html#ch02eq3">6a</a>), and (<a href="../Text/ch02.html#ch02eq4">7a</a>) for stacks and queues so that they conform to this convention. In other words, change them so that the list elements will appear in the array <code>X</code>[0], <code>X</code>[1], . . ., <code>X</code>[<code>M</code> − 1], instead of <code>X</code>[1], <code>X</code>[2], . . ., <code>X</code>[<code>M</code>].</p>

  <div class="heading">
    <h4 id="ch02lev2sec3">2.2.3. Linked Allocation</h4>

    <p>Instead of keeping a linear list in sequential memory locations, we can make use of a much more flexible scheme in which each node contains a link to the next node of the list.</p>
  </div>

  <div class="image"><img src="../Images/ch02/e254_04.jpg"></div>

  <p><a id="page_255"></a>Here A, B, C, D, and E are arbitrary locations in the memory, and <em>Λ</em> is the null link (see <a href="../Text/ch02.html#ch02lev1sec1">Section 2.1</a>). The program that uses this table in the case of sequential allocation would have an additional variable or constant whose value indicates that the table is five items in length, or else this information would be specified by a sentinel code within item 5 or in the following location. A program for linked allocation would have a link variable or link constant that points to A; all the other items of the list can be found from address A.</p>

  <p class="indent">Recall from <a href="../Text/ch02.html#ch02lev1sec1">Section 2.1</a> that links are often shown simply by arrows, since the actual memory locations occupied are usually irrelevant. The linked table above might therefore be shown as follows:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-1"></a><img src="../Images/ch02/255equ01.jpg"></div>

  <p>Here <code>FIRST</code> is a link variable pointing to the first node of the list.</p>

  <p class="indent">We can make several obvious comparisons between these two basic forms of storage:</p>

  <p class="indent">1) Linked allocation takes up additional memory space for the links. This can be the dominating factor in some situations. However, we frequently find that the information in a node does not take up a whole word anyway, so there is already space for a link field present. Also, it is possible in many applications to combine several items into one node so that there is only one link for several items of information (see <a href="../Text/ch02c.html#ch02ex_1_5_2">exercise 2.5–2</a>). But even more importantly, there is often an implicit <em>gain</em> in storage by the linked memory approach, since tables can overlap, sharing common parts; and in many cases, sequential allocation will not be as efficient as linked allocation unless a rather large number of additional memory locations are left vacant anyway. For example, the discussion at the end of the previous section explains why the systems described there are necessarily inefficient when memory is densely loaded.</p>

  <p class="indent">2) It is easy to delete an item from within a linked list. For example, to delete item 3 we need only change the link associated with item 2. But with sequential allocation such a deletion generally implies moving a large part of the list up into different locations.</p>

  <p class="indent">3) It is easy to insert an item into the midst of a list when the linked scheme is being used. For example, to insert an item 2<span class="middle"><img src="../Images/ch02/1by2.jpg"></span> into (<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>) we need to change only two links:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-2"></a><img src="../Images/ch02/255equ02.jpg"></div>

  <p>By comparison, this operation would be extremely time-consuming in a long sequential table.</p>

  <p class="indent">4) References to random parts of the list are much faster in the sequential case. To gain access to the <em>k</em>th item in the list, when <em>k</em> is a variable, takes a fixed time in the sequential case, but we need <em>k</em> iterations to march down to the right <a id="page_256"></a>place in the linked case. Thus the usefulness of linked memory is predicated on the fact that in the large majority of applications we want to walk through lists sequentially, not randomly; if items in the middle or at the bottom of the list are needed, we try to keep an additional link variable or list of link variables pointing to the proper places.</p>

  <p class="indent">5) The linked scheme makes it easier to join two lists together, or to break one apart into two that will grow independently.</p>

  <p class="indent">6) The linked scheme lends itself immediately to more intricate structures than simple linear lists. We can have a variable number of variable-size lists; any node of the list may be a starting point for another list; the nodes may simultaneously be linked together in several orders corresponding to different lists; and so on.</p>

  <p class="indent">7) Simple operations, like proceeding sequentially through a list, are slightly faster for sequential lists on many computers. For <code>MIX</code>, the comparison is between ‘<code>INC1</code> <em>c</em>’ and ‘<code>LD1 0,1(</code><code>LINK)</code>’, which is only one cycle different, but many machines do not enjoy the property of being able to load an index register from an indexed location. If the elements of a linked list belong to different pages in a bulk memory, the memory accesses might take significantly longer.</p>

  <p class="indent">Thus we see that the linking technique, which frees us from any constraints imposed by the consecutive nature of computer memory, gives us a good deal more efficiency in some operations, while we lose some capabilities in other cases. It is usually clear which allocation technique will be most appropriate in a given situation, and both methods are often used in different lists of the same program.</p>

  <p class="indent">In the next few examples we will assume for convenience that a node has one word and that it is broken into the two fields <code>INFO</code> and <code>LINK</code>:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-3"></a><img src="../Images/ch02/256equ01.jpg"></div>

  <p class="indent">The use of linked allocation generally implies the existence of some mechanism for finding empty space available for a new node, when we wish to insert some newly created information onto a list. This is usually done by having a special list called the <em>list of available space</em>. We will call it the <code>AVAIL</code> list (or the <code>AVAIL</code> stack, since it is usually treated in a last-in-first-out manner). The set of all nodes not currently in use is linked together in a list just like any other list; the link variable <code>AVAIL</code> refers to the top element of this list. Thus, if we want to set link variable <code>X</code> to the address of a new node, and to reserve that node for future use, we can proceed as follows:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-4"></a><img src="../Images/ch02/256equ02.jpg"></div>

  <p>This effectively removes the top of the <code>AVAIL</code> stack and makes <code>X</code> point to the node just removed. <em>Operation</em> (<a href="../Text/ch02.html#ch02eq-lev2sec3-4">4</a>) <em>occurs so often that we have a special notation for it:</em> “X <span class="ent">⇐</span> <code>AVAIL</code>” will mean <code>X</code> is set to point to a new node.</p>

  <p class="indent">When a node is deleted and no longer needed, process (<a href="../Text/ch02.html#ch02eq-lev2sec3-4">4</a>) can be reversed:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-5"></a><img src="../Images/ch02/256equ03.jpg"></div>

  <p><a id="page_257"></a>This operation puts the node addressed by <code>X</code> back onto the list of raw material; we denote (<a href="../Text/ch02.html#ch02eq-lev2sec3-5">5</a>) by “<code>AVAIL</code> <span class="ent">⇐</span> <code>X</code>”.</p>

  <p class="indent">Several important things have been omitted from this discussion of the <code>AVAIL</code> stack. We did not say how to set it up at the beginning of a program; clearly this can be done by (a) linking together all nodes that are to be used for linked memory, (b) setting <code>AVAIL</code> to the address of the first of these nodes, and (c) making the last node link to <em>Λ</em>. The set of all nodes that can be allocated is called the <em>storage pool</em>.</p>

  <p class="indent">A more important omission in our discussion was the test for overflow: We neglected to check in (<a href="../Text/ch02.html#ch02eq-lev2sec3-4">4</a>) if all available memory space has been taken. The operation <code>X</code> <span class="ent">⇐</span> <code>AVAIL</code> should really be defined as follows:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-6"></a><img src="../Images/ch02/257equ01.jpg"></div>

  <p>The possibility of overflow must always be considered. Here <code>OVERFLOW</code> generally means that we terminate the program with regrets; or else we can go into a “garbage collection” routine that attempts to find more available space. Garbage collection is discussed in <a href="../Text/ch02c.html#ch02lev2sec11">Section 2.3.5</a>.</p>

  <p class="indent">There is another important technique for handling the <code>AVAIL</code> stack: We often do not know in advance how much memory space should be used for the storage pool. There may be a sequential table of variable size that wants to coexist in memory with the linked tables; in such a case we do not want the linked memory area to take any more space than is absolutely necessary. So suppose that we wish to place the linked memory area in ascending locations beginning with <code>L</code><sub>0</sub> and that this area is never to extend past the value of variable <code>SEQMIN</code> (which represents the current lower bound of the sequential table). Then we can proceed as follows, using a new variable <code>POOLMAX</code>:</p>

  <p class="indenthangingA">a) Initially set <code>AVAIL</code> ← <em>Λ</em> and <code>POOLMAX</code> ← <code>L</code><sub>0</sub>.</p>

  <p class="indenthangingA">b) The operation <code>X</code> <span class="ent">⇐</span> <code>AVAIL</code> becomes the following:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-7"></a><img src="../Images/ch02/257equ02.jpg"></div>

  <p class="indenthangingA">c) When other parts of the program attempt to decrease the value of <code>SEQMIN</code>, they should sound the <code>OVERFLOW</code> alarm if <code>SEQMIN</code> &lt; <code>POOLMAX</code>.</p>

  <p class="indenthangingA">d) The operation <code>AVAIL</code> <span class="ent">⇐</span> <code>X</code> is unchanged from (<a href="../Text/ch02.html#ch02eq-lev2sec3-5">5</a>).</p>

  <p>This idea actually represents little more than the previous method with a special recovery procedure substituted for the <code>OVERFLOW</code> situation in (<a href="../Text/ch02.html#ch02eq-lev2sec3-6">6</a>). The net effect is to keep the storage pool as small as possible. Many people like to use this idea even when <em>all</em> lists occupy the storage pool area (so that <code>SEQMIN</code> is constant), since it avoids the rather time-consuming operation of initially linking all available cells together and it facilitates debugging. We could, of course, put the sequential list on the bottom and the pool on the top, having <code>POOLMIN</code> and <code>SEQMAX</code> instead of <code>POOLMAX</code> and <code>SEQMIN</code>.</p>

  <p class="indent"><a id="page_258"></a>Thus it is quite easy to maintain a pool of available nodes, in such a way that free nodes can efficiently be found and later returned. These methods give us a source of raw material to use in linked tables. Our discussion was predicated on the implicit assumption that all nodes have a fixed size, <em>c</em>; the cases that arise when different sizes of nodes are present are very important, but we will defer that discussion until <a href="../Text/ch02c.html#ch02lev1sec5">Section 2.5</a>. Now we will consider a few of the most common list operations in the special case where stacks and queues are involved.</p>

  <p class="indent">The simplest kind of linked list is a stack. <a href="../Text/ch02.html#ch02fig05">Figure 5</a> shows a typical stack, with a pointer <code>T</code> to the top of the stack. When the stack is empty, this pointer will have the value <em>Λ</em>.</p>

  <div class="image">
    <a id="ch02fig05"></a><img src="../Images/ch02/02fig05.jpg">

    <p class="fig-caption"><strong>Fig. 5.</strong> A linked stack.</p>
  </div>

  <p class="indent">It is clear how to insert (“push down”) new information <code>Y</code> onto the top of such a stack, using an auxiliary pointer variable <code>P</code>.</p>

  <div class="equation"><a id="ch02eq-lev2sec3-8"></a><img src="../Images/ch02/258equ01.jpg"></div>

  <p>Conversely, to set <code>Y</code> equal to the information at the top of the stack and to “pop up” the stack:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-9"></a><img src="../Images/ch02/258equ02.jpg"></div>

  <p>These operations should be compared with the analogous mechanisms for sequentially allocated stacks, (<a href="../Text/ch02.html#ch02eq1">2a</a>) and (<a href="../Text/ch02.html#ch02eq2">3a</a>) in <a href="../Text/ch02.html#ch02lev2sec2">Section 2.2.2</a>. The reader should study (<a href="../Text/ch02.html#ch02eq-lev2sec3-8">8</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-9">9</a>) carefully, since they are extremely important operations.</p>

  <p class="indent">Before looking at the case of queues, let us see how the stack operations can be expressed conveniently in programs for <code>MIX</code>. A program for insertion, with <code>P</code> ≡ rI1, can be written as follows:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-10"></a><img src="../Images/ch02/258equ03.jpg"></div>

  <p>This takes 17 units of time, compared to 12 units for the comparable operation with a sequential table (although <code>OVERFLOW</code> in the sequential case would in many cases take considerably longer). In this program, as in others to follow in this chapter, <code>OVERFLOW</code> denotes either an ending routine or a subroutine that finds more space and returns to location rJ − 2.</p>

  <p class="indent"><a id="page_259"></a>A program for deletion is equally simple:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-11"></a><img src="../Images/ch02/259equ01.jpg"></div>

  <p class="indent">It is interesting to observe that each of these operations involves a cyclic permutation of three links. For example, in the insertion operation let <code>P</code> be the value of <code>AVAIL</code> before the insertion; if <code>P</code> ≠ <em>Λ</em>, we find that after the operation</p>

  <p class="indent">the value of <code>AVAIL</code> has become the previous value of <code>LINK</code>(<code>P</code>),</p>

  <p class="indent">the value of <code>LINK</code>(<code>P</code>) has become the previous value of <code>T</code>, and</p>

  <p class="indent">the value of <code>T</code> has become the previous value of <code>AVAIL</code>.</p>

  <p>So the insertion process (except for setting <code>INFO</code>(<code>P</code>) ← <code>Y</code>) is the cyclic permutation</p>

  <div class="image"><img src="../Images/ch02/259fig01.jpg"></div>

  <p>Similarly in the case of deletion, where <code>P</code> has the value of <code>T</code> before the operation and we assume that <code>P</code> ≠ <em>Λ</em>, we have <code>Y</code> ← <code>INFO</code>(<code>P</code>) and</p>

  <div class="image"><img src="../Images/ch02/259fig02.jpg"></div>

  <p>The fact that the permutation is cyclic is not really a relevant issue, since <em>any</em> permutation of three elements that moves every element is cyclic. The important point is rather that precisely three links are permuted in these operations.</p>

  <p class="indent">The insertion and deletion algorithms of (<a href="../Text/ch02.html#ch02eq-lev2sec3-8">8</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-9">9</a>) have been described for stacks, but they apply much more generally to insertion and deletion in <em>any</em> linear list. Insertion, for example, is performed just before the node pointed to by link variable <code>T</code>. The insertion of item 2<span class="middle"><img src="../Images/ch02/1by2.jpg"></span> in (<a href="../Text/ch02.html#ch02eq-lev2sec3-2">2</a>) above would be done by using operation (<a href="../Text/ch02.html#ch02eq-lev2sec3-8">8</a>) with <code>T</code> = <code>LINK</code>(<code>LINK</code>(<code>FIRST</code>)).</p>

  <p class="indent">Linked allocation applies in a particularly convenient way to queues. In this case it is easy to see that the links should run from the front of the queue towards the rear, so that when a node is removed from the front, the new front node is directly specified. We will make use of pointers <code>F</code> and <code>R</code>, to the front and rear:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-12"></a><img src="../Images/ch02/259equ02.jpg"></div>

  <p>Except for <code>R</code>, this diagram is abstractly identical to <a href="../Text/ch02.html#ch02fig05">Fig. 5</a> on page <a href="../Text/ch02.html#page_258">258</a>.</p>

  <p class="indent"><a id="page_260"></a>Whenever the layout of a list is designed, it is important to specify all conditions carefully, particularly for the case when the list is empty. One of the most common programming errors connected with linked allocation is the failure to handle empty lists properly; the other common error is to forget about changing some of the links when a structure is being manipulated. In order to avoid the first type of error, we should always examine the “boundary conditions” carefully. To avoid making the second type of error, it is helpful to draw “before and after” diagrams and to compare them, in order to see which links must change.</p>

  <p class="indent">Let’s illustrate the remarks of the preceding paragraph by applying them to the case of queues. First consider the insertion operation: If (<a href="../Text/ch02.html#ch02eq-lev2sec3-12">12</a>) is the situation before insertion, the picture after insertion at the rear of the queue should be</p>

  <div class="equation"><a id="ch02eq-lev2sec3-13"></a><img src="../Images/ch02/260equ01.jpg"></div>

  <p>(The notation used here implies that a new node has been obtained from the <code>AVAIL</code> list.) Comparing (<a href="../Text/ch02.html#ch02eq-lev2sec3-12">12</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-13">13</a>) shows us how to proceed when inserting the information <code>Y</code> at the rear of the queue:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-14"></a><img src="../Images/ch02/260equ02.jpg"></div>

  <p class="indent">Let us now consider the “boundary” situation when the queue is empty: In this case the situation before insertion is yet to be determined, and the situation “after” is</p>

  <div class="equation"><a id="ch02eq-lev2sec3-15"></a><img src="../Images/ch02/260equ03.jpg"></div>

  <p>It is desirable to have operations (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) apply in this case also, even if insertion into an empty queue means that we must change <em>both</em> <code>F</code> and <code>R</code>, not only <code>R</code>. We find that (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) will work properly if <code>R</code> = <code>LOC</code>(<code>F</code>) when the queue is empty, <em>assuming that</em> <code>F</code> ≡ <code>LINK</code>(<code>LOC</code>(<code>F</code>)); the value of variable <code>F</code> must be <em>stored in the</em> <code>LINK</code> <em>field of its location</em> if this idea is to work. In order to make the testing for an empty queue as efficient as possible, we will let <code>F</code> = <em>Λ</em> in this case. Our policy is therefore that</p>

  <p class="center"><em>an empty queue is represented by</em> <code>F</code> = <em>Λ and</em> <code>R</code> = <code>LOC</code>(<code>F</code>).</p>

  <p>If the operations (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) are applied under these circumstances, we obtain (<a href="../Text/ch02.html#ch02eq-lev2sec3-15">15</a>).</p>

  <p class="indent">The deletion operation for queues is derived in a similar fashion. If (<a href="../Text/ch02.html#ch02eq-lev2sec3-12">12</a>) is the situation before deletion, the situation afterwards is</p>

  <div class="equation"><a id="ch02eq-lev2sec3-16"></a><img src="../Images/ch02/260equ04.jpg"></div>

  <p>For the boundary conditions we must make sure that the deletion operation works when the queue is empty either before or after the operation. These <a id="page_261"></a>considerations lead us to the following way to do queue deletion in general:</p>

  <div class="equation"><a id="ch02eq-lev2sec3-17"></a><img src="../Images/ch02/261equ01.jpg"></div>

  <p>Notice that <code>R</code> must be changed when the queue becomes empty; this is precisely the type of “boundary condition” we should always be watching for.</p>

  <p class="indent">These suggestions are not the only way to represent queues in a linearly linked fashion; <a href="../Text/ch02.html#ch02ex_2_3_30">exercise 30</a> describes a somewhat more natural alternative, and we will give other methods later in this chapter. Indeed, none of the operations above are meant to be prescribed as the only way to do something; they are intended as examples of the basic means of operating with linked lists. The reader who has had only a little previous experience with such techniques will find it helpful to reread the present section up to this point before going on.</p>

  <p class="indent">So far in this chapter we have discussed how to perform certain operations on tables, but our discussions have always been “abstract,” in the sense that we never exhibited actual programs in which the particular techniques were useful. People aren’t generally motivated to study abstractions of a problem until they’ve seen enough special instances of the problem to arouse their interest. The operations discussed so far — manipulations of variable-size lists of information by insertion and deletion, and the use of tables as stacks or queues — are of such wide application, it is hoped that the reader will have encountered them often enough already to grant their importance. But now we will leave the realm of the abstract as we begin to study a series of significant practical examples of the techniques of this chapter.</p>

  <p class="indent">Our first example is a problem called <em>topological sorting</em>, which is an important process needed in connection with network problems, with so-called PERT charts, and even with linguistics; in fact, it is of potential use whenever we have a problem involving a <em>partial ordering</em>. A partial ordering of a set <em>S</em> is a relation between the objects of <em>S</em>, which we may denote by the symbol “<span class="ent">≼</span>”, satisfying the following properties for any objects <em>x</em>, <em>y</em>, and <em>z</em> (not necessarily distinct) in <em>S</em>:</p>

  <p class="indenti">i) If <em>x</em> <span class="ent">≼</span> <em>y</em> and <em>y</em> <span class="ent">≼</span> <em>z</em>, then <em>x</em> <span class="ent">≼</span> <em>z</em>. (Transitivity.)</p>

  <p class="indenti">ii) If <em>x</em> <span class="ent">≼</span> <em>y</em> and <em>y</em> <span class="ent">≼</span> <em>x</em>, then <em>x</em> = <em>y</em>. (Antisymmetry.)</p>

  <p class="indenti">iii) <em>x</em> <span class="ent">≼</span> <em>x</em>. (Reflexivity.)</p>

  <p>The notation <em>x</em> <span class="ent">≼</span> <em>y</em> may be read “<em>x</em> precedes or equals <em>y</em>.” If <em>x</em> <span class="ent">≼</span> <em>y</em> and <em>x</em> ≠ <em>y</em>, we write <em>x</em> <span class="ent">≺</span> <em>y</em> and say “<em>x</em> precedes <em>y</em>.” It is easy to see from (i), (ii), and (iii) that we always have</p>

  <p class="indenti">i′) If <em>x</em> <span class="ent">≺</span> <em>y</em> and <em>y</em> <span class="ent">≺</span> <em>z</em>, then <em>x</em> <span class="ent">≺</span> <em>z</em>. (Transitivity.)</p>

  <p class="indenti">ii′) If <em>x</em> <span class="ent">≺</span> <em>y</em>, then <em>y</em> <span class="ent">⊀</span> <em>x</em>. (Asymmetry.)</p>

  <p class="indenti">iii′) <em>x</em> <span class="ent">⊀</span> <em>x</em>. (Irreflexivity.)</p>

  <p><a id="page_262"></a>The relation denoted by <em>y</em> <span class="ent">⊀</span> <em>x</em> means “<em>y</em> does not precede <em>x</em>.” If we start with a relation <span class="ent">≺</span> satisfying properties (i′), (ii′), and (iii′), we can reverse the process above and define <em>x</em> <span class="ent">≼</span> <em>y</em> if <em>x</em> <span class="ent">≺</span> <em>y</em> or <em>x</em> = <em>y</em>; then properties (i), (ii), and (iii) are true. Therefore we may regard either properties (i), (ii), (iii) or properties (i′),(ii′), (iii′) as the definition of partial order. Notice that property (ii′) is actually a consequence of (i′) and (iii′), although (ii) does not follow from (i) and (iii).</p>

  <p class="indent">Partial orderings occur quite frequently in everyday life as well as in mathematics. As examples from mathematics we can mention the relation <em>x</em> ≤ <em>y</em> between real numbers <em>x</em> and <em>y</em>; the relation <em>x</em> <span class="ent">⊆</span> <em>y</em> between sets of objects; the relation <em>x\backslash y</em> (<em>x</em> divides <em>y</em>) between positive integers. In the case of PERT networks, <em>S</em> is a set of jobs that must be done, and the relation “<em>x</em> <span class="ent">≺</span> <em>y</em>” means “<em>x</em> must be done before <em>y</em>.”</p>

  <p class="indent">We will naturally assume that <em>S</em> is a finite set, since we want to work with <em>S</em> inside a computer. A partial ordering on a finite set can always be illustrated by drawing a diagram such as <a href="../Text/ch02.html#ch02fig06">Fig. 6</a>, in which the objects are represented by small boxes and the relation is represented by arrows between these boxes; <em>x</em> <span class="ent">≺</span> <em>y</em> means there is a path from the box labeled <em>x</em> to box <em>y</em> that follows the direction of the arrows. Property (ii) of partial ordering means there are <em>no closed loops</em> (no paths that close on themselves) in the diagram. If an arrow were drawn from 4 to 1 in <a href="../Text/ch02.html#ch02fig06">Fig. 6</a>, we would no longer have a partial ordering.</p>

  <div class="image">
    <a id="ch02fig06"></a><img src="../Images/ch02/02fig06.jpg">

    <p class="fig-caption"><strong>Fig. 6.</strong> A partial ordering.</p>
  </div>

  <p class="indent">The problem of topological sorting is to <em>embed the partial order in a linear order</em>; that is, to arrange the objects into a linear sequence <em>a</em><sub>1</sub><em>a</em><sub>2</sub> . . . <em>a</em><sub><em>n</em></sub> such that whenever <em>a</em><sub><em>j</em></sub><span class="ent">≺</span> <em>a</em><sub><em>k</em></sub>, we have <em>j</em> &lt; <em>k</em>. Graphically, this means that the boxes are to be rearranged into a line so that all arrows go towards the right (see <a href="../Text/ch02.html#ch02fig07">Fig. 7</a>). It is not immediately obvious that such a rearrangement is possible in every case, although such a rearrangement certainly could not be done if any loops were present. Therefore the algorithm we will give is interesting not only because it does a useful operation, but also because it proves that this operation is <em>possible</em> for every partial ordering.</p>

  <div class="image">
    <a id="ch02fig07"></a><img src="../Images/ch02/02fig07.jpg">

    <p class="fig-caption"><strong>Fig. 7.</strong> The ordering relation of <a href="../Text/ch02.html#ch02fig06">Fig. 6</a> after topological sorting.</p>
  </div>

  <p class="indent">As an example of topological sorting, imagine a large glossary containing definitions of technical terms. We can write <em>w</em><sub>2</sub><span class="ent">≺</span> <em>w</em><sub>1</sub> if the definition of word <em>w</em><sub>1</sub><a id="page_263"></a>depends directly or indirectly on that of word <em>w</em><sub>2</sub> . This relation is a partial ordering provided that there are no “circular” definitions. The problem of topological sorting in this case is to <em>find a way to arrange the words in the glossary so that no term is used before it has been defined</em>. Analogous problems arise in writing programs to process the declarations in certain assembly and compiler languages; they also arise in writing a user’s manual describing a computer language or in writing textbooks about information structures.</p>

  <p class="indent">There is a very simple way to do topological sorting: We start by taking an object that is not preceded by any other object in the ordering. This object may be placed first in the output. Now we remove this object from the set <em>S</em>; the resulting set is again partially ordered, and the process can be repeated until the whole set has been sorted. For example, in <a href="../Text/ch02.html#ch02fig06">Fig. 6</a> we could start by removing 1 or 9; after 1 has been removed, 3 can be taken, and so on. The only way in which this algorithm could fail would be if there were a nonempty partially ordered set in which every element was preceded by another; for in such a case the algorithm would find nothing to do. But if every element is preceded by another, we could construct an arbitrarily long sequence <em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, <em>b</em><sub>3</sub>, . . . in which <em>b</em><sub><em>j</em>+1</sub><span class="ent">≺</span> <em>b</em><sub><em>j</em></sub> . Since <em>S</em> is finite, we must have <em>b</em><sub><em>j</em></sub> = <em>b</em><sub><em>k</em></sub> for some <em>j</em> &lt; <em>k</em>; but <em>j</em> &lt; <em>k</em> implies that <em>b</em><sub><em>k</em></sub><span class="ent">≼</span> <em>b</em><sub><em>j</em>+1</sub>, hence <em>b</em><sub><em>j</em></sub> = <em>b</em><sub><em>k</em></sub> contradicts (ii).</p>

  <p class="indent">In order to implement this process efficiently by computer, we need to be ready to perform the actions described above, namely to locate objects that are not preceded by any others, and to remove them from the set. Our implementation is also influenced by the desired input and output characteristics. The most general program would accept alphabetic names for the objects and would allow gigantic sets of objects to be sorted — more than could possibly fit in the computer memory at once. Such complications would obscure the main points we are trying to make here, however; the handling of alphabetic data can be done efficiently by using the methods of Chapter 6, and the handling of large networks is left as an interesting project for the reader.</p>

  <p class="indent">Therefore we will assume that the objects to be sorted are numbered from 1 to <em>n</em> in any order. The input of the program will be on tape unit 1: Each tape record contains 50 pairs of numbers, where the pair (<em>j, k</em>) means that object <em>j</em> precedes object <em>k</em>. The first pair, however, is (0, <em>n</em>), where <em>n</em> is the number of objects. The pair (0,0) terminates the input. We shall assume that <em>n</em> plus the number of relation pairs will fit comfortably in memory; and we shall assume that it is not necessary to check the input for validity. The output is to be the numbers of the objects in sorted order, followed by the number 0, on tape unit 2.</p>

  <p class="indent"><a id="page_264"></a>As an example of the input, we might have the relations</p>

  <div class="equation"><a id="ch02eq-lev2sec3-18"></a><img src="../Images/ch02/264equ01.jpg"></div>

  <p>It is not necessary to give any more relations than are needed to characterize the desired partial ordering. Thus, additional relations like 9 <span class="ent">≺</span> 8 (which can be deduced from 9 <span class="ent">≺</span> 5 and 5 <span class="ent">≺</span> 8) may be omitted from or added to the input without harm. In general, it is necessary to give only the relations corresponding to arrows on a diagram such as <a href="../Text/ch02.html#ch02fig06">Fig. 6</a>.</p>

  <p class="indent">The algorithm that follows uses a sequential table <code>X</code>[1], <code>X</code>[2], . . ., <code>X</code>[<em>n</em>], and each node <code>X</code>[<em>k</em>] has the form</p>

  <div class="image"><img src="../Images/ch02/e264_002.jpg"></div>

  <p>Here <code>COUNT</code>[<em>k</em>] is the <em>number of direct predecessors</em> of object <em>k</em> (the number of relations <em>j</em> <span class="ent">≺</span> <em>k</em> that have appeared in the input), and <code>TOP</code>[<em>k</em>] is a link to the beginning of the <em>list of direct successors</em> of object <em>k</em>. The latter list contains entries in the format</p>

  <div class="image"><img src="../Images/ch02/e264_003.jpg"></div>

  <p>where <code>SUC</code> is a direct successor of <em>k</em> and <code>NEXT</code> is the next item of the list. As an example of these conventions, <a href="../Text/ch02.html#ch02fig08">Fig. 8</a> shows the schematic contents of memory corresponding to the input (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>).</p>

  <div class="image">
    <a id="ch02fig08"></a><img src="../Images/ch02/02fig08.jpg">

    <p class="fig-caption"><strong>Fig. 8.</strong> Computer representation of <a href="../Text/ch02.html#ch02fig06">Fig. 6</a> corresponding to the relations (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>).</p>
  </div>

  <p class="indent">Using this memory layout, it is not difficult to work out the algorithm. We want to output the nodes whose <code>COUNT</code> field is zero, then to decrease the <code>COUNT</code> fields of all successors of those nodes by one. The trick is to avoid doing any “searching” for nodes whose <code>COUNT</code> field is zero, and this can be done by maintaining a queue containing those nodes. The links for this queue are kept in the <code>COUNT</code> field, which by now has served its previous purpose; for clarity in the algorithm below, we use the notation <code>QLINK</code>[<em>k</em>] to stand for <code>COUNT</code>[<em>k</em>] when that field is no longer being used to keep a count.</p>

  <p><a id="page_265"></a><a id="ch02alg-lev2sec3-T"></a><strong>Algorithm T</strong> (<em>Topological sort</em>). This algorithm inputs a sequence of relations <em>j</em> <span class="ent">≺</span> <em>k</em>, indicating that object <em>j</em> precedes object <em>k</em> in a certain partial ordering, assuming that 1 ≤ <em>j</em>, <em>k</em> ≤ <em>n</em>. The output is the set of <em>n</em> objects embedded in a linear order. The internal tables used are: <code>QLINK[0]</code>, <code>COUNT[1]</code> = <code>QLINK[1]</code>, <code>COUNT[2]</code> = <code>QLINK[2]</code>, . . ., <code>COUNT</code>[<em>n</em>] = <code>QLINK</code>[<em>n</em>]; <code>TOP[1]</code>, <code>TOP[2]</code>, . . ., <code>TOP</code>[<em>n</em>]; a storage pool with one node for each input relation and with <code>SUC</code> and <code>NEXT</code> fields as shown above; <code>P</code>, a Link variable used to refer to the nodes in the storage pool; <code>F</code> and <code>R</code>, integer-valued variables used to refer to the front and rear of a queue whose links are in the <code>QLINK</code> table; and <code>N</code>, a variable that counts how many objects have yet to be output.</p>

  <p class="indenthanging"><strong>T1.</strong> [Initialize.] Input the value of <em>n</em>. Set <code>COUNT</code>[<em>k</em>] ← 0 and <code>TOP</code>[<em>k</em>] ← <em>Λ</em> for 1 ≤ <em>k</em> ≤ <em>n</em>. Set <code>N</code> ← <em>n</em>.</p>

  <p class="indenthanging"><strong>T2.</strong> [Next relation.] Get the next relation “<em>j</em> <span class="ent">≺</span> <em>k</em>” from the input; if the input has been exhausted, however, go to T4.</p>

  <p class="indenthanging"><strong>T3.</strong> [Record the relation.] Increase <code>COUNT</code>[<em>k</em>] by one. Set</p>

  <p class="center"><code>P</code> <span class="ent">⇐</span> <code>AVAIL</code><em>,</em> <code>SUC</code>(<code>P</code>) ← <em>k,</em> <code>NEXT</code>(<code>P</code>) ← <code>TOP</code>[<em>j</em>]<em>,</em> <code>TOP</code>[<em>j</em>] ← <code>P</code>.</p>

  <p class="indenthangingP">(This is operation (<a href="../Text/ch02.html#ch02eq-lev2sec3-8">8</a>).) Go back to T2.</p>

  <p class="indenthanging"><strong>T4.</strong> [Scan for zeros.] (At this point we have completed the input phase; the input (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>) would now have been transformed into the computer representation shown in <a href="../Text/ch02.html#ch02fig08">Fig. 8</a>. The next job is to initialize the queue of output, which is linked together in the <code>QLINK</code> field.) Set <code>R</code> ← 0 and <code>QLINK</code>[0] ← 0. For 1 ≤ <em>k</em> ≤ <em>n</em> examine <code>COUNT</code>[<em>k</em>], and if it is zero, set <code>QLINK</code>[R] ← <em>k</em> and <code>R</code> ← <em>k</em>. After this has been done for all <em>k</em>, set <code>F</code> ← <code>QLINK</code>[0] (which will contain the first value <em>k</em> encountered for which <code>COUNT</code>[<em>k</em>] was zero).</p>

  <p class="indenthanging"><strong>T5.</strong> [Output front of queue.] Output the value of <code>F</code>. If <code>F</code> = 0, go to T8; otherwise, set <code>N</code> ← <code>N</code> − 1, and set <code>P</code> ← <code>TOP</code>[<code>F</code>]. (Since the <code>QLINK</code> and <code>COUNT</code> tables overlap, we have <code>QLINK</code>[<code>R</code>] = 0; therefore the condition <code>F</code> = 0 occurs when the queue is empty.)</p>

  <p class="indenthanging"><strong>T6.</strong> [Erase relations.] If <code>P</code> = Λ, go to T7. Otherwise decrease <code>COUNT</code>[<code>SUC</code>(<code>P</code>)] by one, and if it has thereby gone down to zero, set <code>QLINK</code>[<code>R</code>] ← <code>SUC</code>(<code>P</code>) and <code>R</code> ← <code>SUC</code>(<code>P</code>). Set <code>P</code> ← <code>NEXT</code>(<code>P</code>) and repeat this step. (We are removing all relations of the form “<code>F</code> <span class="ent">≺</span> <em>k</em>” for some <em>k</em> from the system, and putting new nodes into the queue when all their predecessors have been output.)</p>

  <p class="indenthanging"><strong>T7.</strong> [Remove from queue.] Set <code>F</code> ← <code>QLINK</code>[<code>F</code>] and go back to T5.</p>

  <p class="indenthanging"><strong>T8.</strong> [End of process.] The algorithm terminates. If <code>N</code> = 0, we have output all of the object numbers in the desired “topological order,” followed by a zero. Otherwise the <code>N</code> object numbers not yet output contain a loop, in violation of the hypothesis of partial order. (See <a href="../Text/ch02.html#ch02ex_2_3_23">exercise 23</a> for an algorithm that prints out the contents of one such loop.) <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">The reader will find it helpful to try this algorithm by hand on the input (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>). <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> shows a nice interplay between sequential memory and linked <a id="page_266"></a>memory techniques. Sequential memory is used for the main table <code>X</code><code>[</code>1<code>]</code>, . . .,<code>X</code>[<em>n</em>], which contains the <code>COUNT</code>[<em>k</em>] and <code>TOP</code>[<em>k</em>] entries, because we want to make references to “random” parts of this table in step T3. (If the input were alphabetic, however, another type of table would be used for speedier search, as in Chapter 6.) Linked memory is used for the tables of “immediate successors,” since those table entries have no particular order in the input. The queue of nodes waiting to be output is kept in the midst of the sequential table by linking the nodes together in output order. This linking is done by table index instead of by address; in other words, when the front of the queue is <code>X</code>[<em>k</em>], we have <code>F</code> = <em>k</em> instead of <code>F</code> = <code>LOC</code>(<code>X</code>[<em>k</em>]). The queue operations used in steps T4, T6, and T7 are not identical to those in (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-17">17</a>), since we are taking advantage of special properties of the queue in this system; no nodes need to be created or returned to available space during this part of the algorithm.</p>

  <p class="indent">The coding of <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> in <code>MIX</code> assembly language has a few additional points of interest. Since no deletion from tables is made in the algorithm (because no storage must be freed for later use), the operation <code>P</code> <span class="ent">⇐</span> <code>AVAIL</code> can be done in an extremely simple way, as shown in lines 19 and 32 below; we need not keep any linked pool of memory, and we can choose new nodes consecutively. The program includes complete input and output with magnetic tape, according to the conventions mentioned above, but buffering is omitted for the sake of simplicity. The reader should not find it very difficult to follow the details of the coding in this program, since it corresponds directly to <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> but with slight changes for efficiency. The efficient use of index registers, which is an important aspect of linked memory processing, is illustrated here.</p>

  <p><a id="ch02pro_01"></a><strong>Program T</strong> (<em>Topological sort</em>). In this program, the following equivalences should be noted: rI6 ≡ <code>N</code>, rI5 ≡ buffer pointer, rI4 ≡ <em>k</em>, rI3 ≡ <em>j</em> and <code>R</code>, rI2 ≡ <code>AVAIL</code> and <code>P</code>, rI1 ≡ <code>F</code>, <code>TOP</code>[ <em>j</em>] ≡ X + <em>j</em> (4:5), <code>COUNT</code>[<em>k</em>] ≡ <code>QLINK</code>[<em>k</em>] ≡ <code>X</code> + <em>k</em> (2 : 3).</p>

  <div class="image"><img src="../Images/ch02/266pro01.jpg"></div>

  <div class="image4">
    <a id="ch02fig09"></a><img class="img1" src="../Images/ch02/02fig09.jpg">

    <p class="fig-caption"><strong>Fig. 9</strong>. Topological sorting.</p>
  </div>

  <div class="image"><a id="page_267"></a><img src="../Images/ch02/267pro01.jpg"></div>

  <div class="image"><a id="page_268"></a><img src="../Images/ch02/267pro01a.jpg"></div>

  <p class="indent">The analysis of <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> is quite simple with the aid of Kirchhoff’s law; the execution time has the approximate form <em>c</em><sub>1</sub><em>m</em> + <em>c</em><sub>2</sub><em>n</em>, where <em>m</em> is the number of input relations, <em>n</em> is the number of objects, and <em>c</em><sub>1</sub> and <em>c</em><sub>2</sub> are constants. It is hard to imagine a faster algorithm for this problem! The exact quantities in the analysis are given with <a href="../Text/ch02.html#ch02pro_01">Program T</a> above, where <em>a</em> = number of objects with no predecessor, <em>b</em> = number of tape records in input = \lceil{(<em>m</em> + 2)/50}\rceil, and <em>c</em> = number of tape records in output = \lceil{(<em>n</em> + 1)/100}\rceil. Exclusive of input-output operations, the total running time in this case is only (32<em>m</em> + 24<em>n</em> + 7<em>b</em> + 2<em>c</em> + 16)<em>u</em>.</p>

  <p class="indent">A topological sorting technique similar to <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> (but without the important feature of the queue links) was first published by A. B. Kahn, <em>CACM</em> <strong>5</strong> (1962), 558–562. The fact that topological sorting of a partial ordering is always possible was first proved in print by E. Szpilrajn, <em>Fundamenta Mathematica</em> <strong>16</strong> (1930), 386–389; he proved it for infinite sets as well as finite sets, and mentioned that the result was already known to several of his colleagues.</p>

  <p class="indent">In spite of the fact that <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> is so efficient, we will study an even better algorithm for topological sorting in Section 7.4.1.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_1a" id="ch02ex_2_3_1">1</a>.</strong> [<em>10</em>] Operation (<a href="../Text/ch02.html#ch02eq-lev2sec3-9">9</a>) for popping up a stack mentions the possibility of <code>UNDERFLOW</code>; why doesn’t operation (<a href="../Text/ch02.html#ch02eq-lev2sec3-8">8</a>), pushing down a stack, mention the possibility of <code>OVERFLOW</code>?</p>

  <p class="exercises"><a id="page_269"></a><strong><a href="../Text/app01a.html#ch02ex_2_3_2a" id="ch02ex_2_3_2">2</a>.</strong> [<em>22</em>] Write a “general purpose” <code>MIX</code> subroutine to do the insertion operation, (<a href="../Text/ch02.html#ch02eq-lev2sec3-10">10</a>). This subroutine should have the following specifications (as in <a href="../Text/ch01c.html#ch01lev2sec15">Section 1.4.1</a>):</p>

  <div class="imageL"><img src="../Images/ch02/p0269_01.jpg"></div>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_3_3a" id="ch02ex_2_3_3">3</a>.</strong> [<em>22</em>] Write a “general purpose” <code>MIX</code> subroutine to do the deletion operation, (<a href="../Text/ch02.html#ch02eq-lev2sec3-11">11</a>). This subroutine should have the following specifications:</p>

  <div class="imageL"><img src="../Images/ch02/p0269_02.jpg"></div>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_3_4a" id="ch02ex_2_3_4">4</a>.</strong> [<em>22</em>] The program in (<a href="../Text/ch02.html#ch02eq-lev2sec3-10">10</a>) is based on the operation <code>P</code> <span class="ent">⇐</span> <code>AVAIL</code>, as given in (<a href="../Text/ch02.html#ch02eq-lev2sec3-6">6</a>). Show how to write an <code>OVERFLOW</code> subroutine so that, without <em>any</em> change in the coding (<a href="../Text/ch02.html#ch02eq-lev2sec3-10">10</a>), the operation <code>P</code> <span class="ent">⇐</span> <code>AVAIL</code> makes use of <code>SEQMIN</code>, as given by (<a href="../Text/ch02.html#ch02eq-lev2sec3-7">7</a>). For general purpose use, your subroutine should not change the contents of any registers, except rJ and possibly the comparison indicator. It should exit to location rJ − 2, instead of the usual rJ.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_5a" id="ch02ex_2_3_5">5</a>.</strong> [<em>24</em>] Operations (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-17">17</a>) give the effect of a queue; show how to define the further operation “insert at front” so as to obtain all the actions of an output-restricted deque. How could the operation “delete from rear” be defined (so that we would have a general deque)?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_3_6a" id="ch02ex_2_3_6">6</a>.</strong> [<em>21</em>] In operation (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) we set <code>LINK</code>(<code>P</code>) ← <em>Λ</em>, while the very next insertion at the rear of the queue will change the value of this same link field. Show how the setting of <code>LINK</code>(<code>P</code>) in (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) could be avoided if we make a change to the testing of “<code>F</code> = <em>Λ</em>” in (<a href="../Text/ch02.html#ch02eq-lev2sec3-17">17</a>).</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_7a" id="ch02ex_2_3_7">7</a>.</strong> [<em>23</em>] Design an algorithm to “invert” a linked linear list such as (<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>), that is, to change its links so that the items appear in the opposite order. [If, for example, the list (<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>) were inverted, we would have <code>FIRST</code> linking to the node containing item 5; that node would link to the one containing item 4; etc.] Assume that the nodes have the form (<a href="../Text/ch02.html#ch02eq-lev2sec3-3">3</a>).</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_3_8a" id="ch02ex_2_3_8">8</a>.</strong> [<em>24</em>] Write a <code>MIX</code> program for the problem of <a href="../Text/ch02.html#ch02ex_2_3_7">exercise 7</a>, attempting to design your program to operate as fast as possible.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_3_9a" id="ch02ex_2_3_9">9</a>.</strong> [<em>20</em>] Which of the following relations is a partial ordering on the specified set <em>S</em>? <em>[Note:</em> If the relation “<em>x</em> <span class="ent">≺</span> <em>y</em>” is defined below, the intent is to define the relation “<em>x</em> <span class="ent">≼</span> <em>y</em> ≡ (<em>x</em> <span class="ent">≺</span> <em>y</em> or <em>x</em> = <em>y</em>),” and then to determine whether <span class="ent">≼</span> is a partial ordering.] (a) <em>S</em> = all rational numbers, <em>x</em> <span class="ent">≺</span> <em>y</em> means <em>x</em> &gt; <em>y</em>. (b) <em>S</em> = all people, <em>x</em> <span class="ent">≺</span> <em>y</em> means <em>x</em> is an ancestor of <em>y</em>. (c) <em>S</em> = all integers, <em>x</em> <span class="ent">≼</span> <em>y</em> means <em>x</em> is a multiple of <em>y</em> (that is, <em>x</em> mod <em>y</em> = 0). (d) <em>S</em> = all the mathematical results proved in this book, <em>x</em> <span class="ent">≺</span> <em>y</em> means the proof of <em>y</em> depends upon the truth of <em>x</em>. (e) <em>S</em> = all positive integers, <em>x</em> <span class="ent">≼</span> <em>y</em> means <em>x</em> + <em>y</em> is even. (f) <em>S</em> = a set of subroutines, <em>x</em> <span class="ent">≺</span> <em>y</em> means “<em>x</em> calls <em>y</em>,” that is, <em>y</em> may be in operation while <em>x</em> is in operation, with recursion not allowed.</p>

  <p class="exercises1"><a id="page_270"></a><strong><a href="../Text/app01a.html#ch02ex_2_3_10a" id="ch02ex_2_3_10">10</a>.</strong> [<em>M21</em>] Given that “<span class="ent">⊂</span>” is a relation that satisfies properties (i) and (ii) of a partial ordering, prove that the relation “<span class="ent">≼</span>”, defined by the rule “<em>x</em> <span class="ent">≼</span> <em>y</em> if and only if <em>x</em> = <em>y</em> or <em>x</em> <span class="ent">⊂</span> <em>y</em>,” satisfies all three properties of a partial ordering.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_11a" id="ch02ex_2_3_11">11</a>.</strong> [<em>24</em>] The result of topological sorting is not always completely determined, since there may be several ways to arrange the nodes and to satisfy the conditions of topological order. Find all possible ways to arrange the nodes of <a href="../Text/ch02.html#ch02fig06">Fig. 6</a> into topological order.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_12a" id="ch02ex_2_3_12">12</a>.</strong> [<em>M20</em>] There are 2<sup><em>n</em></sup> subsets of a set of <em>n</em> elements, and these subsets are partially ordered by the set-inclusion relation. Give two interesting ways to arrange these subsets in topological order.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_13a" id="ch02ex_2_3_13">13</a>.</strong> [<em>M48</em>] How many ways are there to arrange the 2<sup>n</sup> subsets described in <a href="../Text/ch02.html#ch02ex_2_3_12">exercise 12</a> into topological order? (Give the answer as a function of <em>n</em>.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_14a" id="ch02ex_2_3_14">14</a>.</strong> [<em>M21</em>] A <em>linear ordering</em> of a set <em>S</em>, also called a <em>total ordering</em>, is a partial ordering that satisfies the additional “comparability” condition</p>

  <p class="center">(iv) For any two objects <em>x</em>, <em>y</em> in <em>S</em>, either <em>x</em> <span class="ent">≼</span> <em>y</em> or <em>y</em> <span class="ent">≼</span> <em>x</em>.</p>

  <p class="exercisesp">Prove directly from the definitions given that a topological sort can result in only one possible output if and only if the relation <span class="ent">≼</span> is a linear ordering. (You may assume that the set <em>S</em> is finite.)</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_15a" id="ch02ex_2_3_15">15</a>.</strong> [<em>M25</em>] Show that for any partial ordering on a finite set <em>S</em> there is a <em>unique</em> set of irredundant relations that characterizes this ordering, as in (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>) and <a href="../Text/ch02.html#ch02fig06">Fig. 6</a>. Is the same fact true also when <em>S</em> is an infinite set?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_16a" id="ch02ex_2_3_16">16</a>.</strong> [<em>M22</em>] Given any partial ordering on a set <em>S</em> = \{<em>x</em><sub>1</sub>, . . ., <em>x</em><sub><em>n</em></sub>\}, we can construct its <em>incidence matrix</em> (<em>a</em><sub><em>ij</em></sub>), where <em>a</em><sub><em>ij</em></sub> = 1 if <em>x</em><sub><em>i</em></sub><span class="ent">≼</span> <em>x</em><sub><em>j</em></sub>, and <em>a</em><sub><em>ij</em></sub> = 0 otherwise. Show that there is a way to permute the rows and columns of this matrix so that all entries below the diagonal are zero.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_17a" id="ch02ex_2_3_17">17</a>.</strong> [<em>21</em>] What output does <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> produce if it is presented with the input (<a href="../Text/ch02.html#ch02eq-lev2sec3-18">18</a>)?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_18a" id="ch02ex_2_3_18">18</a>.</strong> [<em>20</em>] What, if anything, is the significance of the values of <code>QLINK[</code>0<code>]</code>, <code>QLINK[1]</code>, . . ., <code>QLINK</code>[<em>n</em>] when <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> terminates?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_19a" id="ch02ex_2_3_19">19</a>.</strong> [<em>18</em>] In <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> we examine the front position of the queue in step T5, but do not remove that element from the queue until step T7. What would happen if we set <code>F</code> ← <code>QLINK</code>[<code>F</code>] at the conclusion of step T5, instead of in T7?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_20a" id="ch02ex_2_3_20">20</a>.</strong> [<em>24</em>] <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> uses <code>F</code>, <code>R</code>, and the <code>QLINK</code> table to obtain the effect of a queue that contains those nodes whose <code>COUNT</code> field has become zero but whose successor relations have not yet been removed. Could a stack be used for this purpose instead of a queue? If so, compare the resulting algorithm with <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_21a" id="ch02ex_2_3_21">21</a>.</strong> [<em>21</em>] Would <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> still perform a valid topological sort if one of the relations “<em>j</em> <span class="ent">≺</span> <em>k</em>” were repeated several times in the input? What if the input contained a relation of the form “<em>j</em> <span class="ent">≺</span> <em>j</em>”?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_22a" id="ch02ex_2_3_22">22</a>.</strong> [<em>23</em>] <a href="../Text/ch02.html#ch02pro_01">Program T</a> assumes that its input tape contains valid information, but a program that is intended for general use should always make careful tests on its input so that clerical errors can be detected, and so that the program cannot “destroy itself.” For example, if one of the input relations for <em>k</em> were negative, <a href="../Text/ch02.html#ch02pro_01">Program T</a> may erroneously change one of its own instructions when storing into <code>X</code>[<em>k</em>]. Suggest ways to modify <a href="../Text/ch02.html#ch02pro_01">Program T</a> so that it is suitable for general use.</p>

  <p class="exercises3"><a id="page_271"></a><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_23a" id="ch02ex_2_3_23">23</a>.</strong> [<em>27</em>] When the topological sort algorithm cannot proceed because it has detected a loop in the input (see step T8), it is usually of no use to stop and say, “There was a loop.” It is helpful to print out one of the loops, thereby showing part of the input that was in error. Extend <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> so that it will do this additional printing of a loop when necessary. [<em>Hint:</em> The text gives a proof for the existence of a loop when <code>N</code> &gt; 0 in step <code>T</code>8; that proof suggests an algorithm.]</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_24a" id="ch02ex_2_3_24">24</a>.</strong> [<em>24</em>] Incorporate the extensions of <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a> made in <a href="../Text/ch02.html#ch02ex_2_3_23">exercise 23</a> into <a href="../Text/ch02.html#ch02pro_01">Program T</a>.</p>

  <p class="exercises1"><strong><a id="ch02ex_2_3_25"></a>25.</strong> [<em>47</em>] Design as efficient an algorithm as possible for doing a topological sort of very large sets <em>S</em> having considerably more nodes than the computer memory can contain. Assume that the input, output, and temporary working space are done with magnetic tape. [<em>Possible hint:</em> A conventional sort of the input allows us to assume that all relations for a given node appear together. But then what can be done? In particular, we must consider the worst case in which the given ordering is already a linear ordering that has been wildly permuted; <a href="../Text/ch02.html#ch02ex_2_3_24">exercise 24</a> in the introduction to Chapter 5 explains how to handle this case with <em>O</em>(log <em>n</em>)<sup>2</sup> passes over the data.]</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_26a" id="ch02ex_2_3_26">26</a>.</strong> [<em>29</em>] (<em>Subroutine allocation.</em>) Suppose that we have a tape containing the main subroutine library in relocatable form, for a 1960s-style computer installation. The loading routine wants to determine the amount of relocation for each subroutine used, so that it can make one pass through the tape to load the necessary routines. The problem is that some subroutines require others to be present in memory. Infrequently used subroutines (which appear toward the end of the tape) may call on frequently used subroutines (which appear toward the beginning of the tape), and we want to know all of the subroutines that are required, before passing through the tape.</p>

  <p class="exercises1N">One way to tackle this problem is to have a “tape directory” that fits in memory. The loading routine has access to two tables:</p>

  <p class="exercises1N">a) The tape directory. This table is composed of variable-length nodes having the form</p>

  <div class="image"><img src="../Images/ch02/271fig01.jpg"></div>

  <p class="exercisesp">where <code>SPACE</code> is the number of words of memory required by the subroutine; <code>LINK</code> is a link to the directory entry for the subroutine that appears on the tape following this subroutine; <code>SUB1</code>, <code>SUB2</code>, . . ., <code>SUB</code><em>n</em> (<em>n</em> ≥ 0) are links to the directory entries for any other subroutines required by this one; <code>B = 0</code> on all words except the last, <code>B =</code> −1 on the last word of a node. The address of the directory entry for the first subroutine on the library tape is specified by the link variable <code>FIRST</code>.</p>

  <p class="exercises1N">b) The list of subroutines directly referred to by the program to be loaded. This is stored in consecutive locations <code>X[</code>1<code>]</code>, <code>X[</code>2<code>]</code>, . . ., <code>X[N]</code>, where <code>N</code> ≥ 0 is a variable known to the loading routine. Each entry in this list is a link to the directory entry for the subroutine desired.</p>

  <p class="exercises1N">The loading routine also knows <code>MLOC</code>, the amount of relocation to be used for the first subroutine loaded.</p>

  <p class="exercises1N"><a id="page_272"></a>As a small example, consider the following configuration:</p>

  <div class="image"><img src="../Images/ch02/272pro01.jpg"></div>

  <p class="exercisesp">The tape directory in this case shows that the subroutines on tape are 1002, 1010, 1006, 1000, 1005, 1003, and 1007 in that order. Subroutine 1007 takes 200 locations and implies the use of subroutines 1005, 1002, and 1006; etc. The program to be loaded requires subroutines 1003 and 1010, which are to be placed into locations ≥ 2400. These subroutines in turn imply that 1000, 1006, and 1002 must also be loaded.</p>

  <p class="exercises1N">The subroutine allocator is to change the <code>X</code>-table so that each entry <code>X[1]</code>, <code>X[2]</code>, <code>X[3]</code>, . . . has the form</p>

  <div class="image"><img src="../Images/ch02/e272_01.jpg"></div>

  <p class="exercisesp">(except the last entry, which is explained below), where <code>SUB</code> is a subroutine to be loaded, and <code>BASE</code> is the amount of relocation. These entries are to be in the order in which the subroutines appear on tape. One possible answer for the example above would be</p>

  <div class="image"><img src="../Images/ch02/272pro02.jpg"></div>

  <p class="exercisesp">The last entry contains the first unused memory address.</p>

  <p class="exercises1N">(Clearly, this is not the only way to treat a library of subroutines. The proper way to design a library is heavily dependent upon the computer used and the applications to be handled. Large modern computers require an entirely different approach to subroutine libraries. But this is a nice exercise anyway, because it involves interesting manipulations on both sequential and linked data.)</p>

  <p class="exercises1N">The problem in this exercise is to design an algorithm for the stated task. Your allocator may transform the tape directory in any way as it prepares its answer, since the tape directory can be read in anew by the subroutine allocator on its next assignment, and the tape directory is not needed by other parts of the loading routine.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_27a" id="ch02ex_2_3_27">27</a>.</strong> [<em>25</em>] Write a <code>MIX</code> program for the subroutine allocation algorithm of <a href="../Text/ch02.html#ch02ex_2_3_26">exercise 26</a>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_28a" id="ch02ex_2_3_28">28</a>.</strong> [<em>40</em>] The following construction shows how to “solve” a fairly general type of two-person game, including chess, nim, and many simpler games: Consider a finite set of nodes, each of which represents a possible position in the game. For each position there are zero or more moves that transform that position into some other position. We say that position <em>x</em> is a predecessor of position <em>y</em> (and <em>y</em> is a successor of <em>x</em>) if there is a move from <em>x</em> to <em>y</em>. Certain positions that have no successors are classified as <em>won</em> or <a id="page_273"></a><em>lost</em> positions. The player to move in position <em>x</em> is the opponent of the player to move in the successors of position <em>x</em>.</p>

  <p class="exercises1N">Given such a configuration of positions, we can compute the complete set of won positions (those in which the next player to move can force a victory) and the complete set of lost positions (those in which the player must lose against an expert opponent) by repeatedly doing the following operation until it yields no change: Mark a position “lost” if all its successors are marked “won”; mark a position “won” if at least one of its successors is marked “lost.”</p>

  <p class="exercises1N">After this operation has been repeated as many times as possible, there may be some positions that have not been marked at all; a player in such a position can neither force a victory nor be compelled to lose.</p>

  <p class="exercises1N">This procedure for obtaining the complete set of won and lost positions can be adapted to an efficient algorithm for computers that closely resembles <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm T</a>. We may keep with each position a count of the number of its successors that have not been marked “won,” and a list of all its predecessors.</p>

  <p class="exercises1N">The problem in this exercise is to work out the details of the algorithm that has just been so vaguely described, and to apply it to some interesting games that do not involve too many possible positions [like the “military game”: É. Lucas, <em>Récréations Mathématiques</em> <strong>3</strong> (Paris: 1893) 105–116; E. R. Berlekamp, J. H. Conway, and R. K. Guy, <em>Winning Ways</em> <strong>3</strong> (A. K. Peters, 2003), Chapter 21].</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_3_29a" id="ch02ex_2_3_29">29</a>.</strong> [<em>21</em>] (a) Give an algorithm to “erase” an entire list like (<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>), by putting all of its nodes on the <code>AVAIL</code> stack, given only the value of <code>FIRST</code>. The algorithm should operate as fast as possible. (b) Repeat part (a) for a list like (<a href="../Text/ch02.html#ch02eq-lev2sec3-12">12</a>), given the values of <code>F</code> and <code>R</code>.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_3_30a" id="ch02ex_2_3_30">30</a>.</strong> [<em>17</em>] Suppose that queues are represented as in (<a href="../Text/ch02.html#ch02eq-lev2sec3-12">12</a>), but with an empty queue represented by <code>F</code> = <em>Λ</em> and <code>R</code> <em>undefined</em>. What insertion and deletion procedures should replace (<a href="../Text/ch02.html#ch02eq-lev2sec3-14">14</a>) and (<a href="../Text/ch02.html#ch02eq-lev2sec3-17">17</a>)?</p>

  <div class="heading">
    <h4 id="ch02lev2sec4">2.2.4. Circular Lists</h4>

    <p>A slight change in the manner of linking furnishes us with an important alternative to the methods of the preceding section.</p>
  </div>

  <p class="indent">A <em>circularly linked list</em> (briefly: a circular list) has the property that its last node links back to the first instead of to <em>Λ</em>. It is then possible to access all of the list starting at any given point; we also achieve an extra degree of symmetry, and if we choose we need not think of the list as having a last or first node.</p>

  <p class="indent">The following situation is typical:</p>

  <div class="equation"><a id="ch02eq-lev2sec4-1"></a><img src="../Images/ch02/273equ01.jpg"></div>

  <p>Assume that the nodes have two fields, <code>INFO</code> and <code>LINK</code>, as in the preceding section. There is a link variable <code>PTR</code> that points to the rightmost node of the list, and <code>LINK</code>(<code>PTR</code>) is the address of the leftmost node. The following primitive operations are most important:</p>

  <p class="indenthangingA">a) Insert <code>Y</code> at left: <code>P</code> <span class="ent">⇐</span> <code>AVAIL</code>, <code>INFO</code>(<code>P</code>) ← <code>Y</code>, <code>LINK</code>(<code>P</code>) ← <code>LINK</code>(<code>PTR</code>), <code>LINK</code>(<code>PTR</code>) ← <code>P</code>.</p>

  <p class="indenthangingA">b) Insert <code>Y</code> at right: Insert <code>Y</code> at left, then <code>PTR</code> ← <code>P</code>.</p>

  <p class="indenthangingA">c) Set <code>Y</code> to left node and delete: <code>P</code> ← <code>LINK</code>(<code>PTR</code>), <code>Y</code> ← <code>INFO</code>(<code>P</code>), <code>LINK</code>(<code>PTR</code>) ← <code>LINK</code>(<code>P</code>), <code>AVAIL</code> <span class="ent">⇐</span> <code>P</code>.</p>

  <p><a id="page_274"></a>Operation (b) is a little surprising at first glance; the operation <code>PTR</code> ← <code>LINK</code>(<code>PTR</code>) effectively moves the leftmost node to the right in the diagram (<a href="../Text/ch02.html#ch02eq-lev2sec4-1">1</a>), and this is quite easy to understand if the list is regarded as a circle instead of as a straight line with connected ends.</p>

  <p class="indent">The alert reader will observe that we have made a serious mistake in operations (a), (b), and (c). What is it? <em>Answer:</em> We have forgotten to consider the possibility of an <em>empty</em> list. If, for example, operation (c) is applied five times to the list (<a href="../Text/ch02.html#ch02eq-lev2sec4-1">1</a>), we will have <code>PTR</code> pointing to a node in the <code>AVAIL</code> list, and this can lead to serious difficulties; for example, imagine applying operation (c) once more! If we take the position that <code>PTR</code> will equal <em>Λ</em> in the case of an empty list, we could remedy the operations by inserting the additional instructions “if <code>PTR</code> = Λ, then <code>PTR</code> ← <code>LINK</code>(<code>P</code>) ← <code>P</code>; otherwise . . .” after “<code>INFO</code>(<code>P</code>) ← <code>Y</code>” in (a); preceding (c) by the test “if <code>PTR</code> = Λ, then <code>UNDERFLOW</code>”; and following (c) by “if <code>PTR</code> = <code>P</code>, then <code>PTR</code> ← Λ”.</p>

  <p class="indent">Notice that operations (a), (b), and (c) give us the actions of an outputrestricted deque, in the sense of <a href="../Text/ch02.html#ch02lev2sec1">Section 2.2.1</a>. Therefore we find in particular that a circular list can be used as either a stack or a queue. Operations (a) and (c) combined give us a stack; operations (b) and (c) give us a queue. These operations are only slightly less direct than their counterparts in the previous section, where we saw that operations (a), (b), and (c) can be performed on linear lists using two pointers <code>F</code> and <code>R</code>.</p>

  <p class="indent">Other important operations become efficient with circular lists. For example, it is very convenient to “erase” a list, that is, to put an entire circular list onto the <code>AVAIL</code> stack at once:</p>

  <div class="equation"><a id="ch02eq-lev2sec4-2"></a><img src="../Images/ch02/274equ01.jpg"></div>

  <p>[Recall that the “↔” operation denotes interchange: <code>P</code> ← <code>AVAIL</code>, <code>AVAIL</code> ← <code>LINK</code>(<code>PTR</code>), <code>LINK</code>(<code>PTR</code>) ← <code>P</code>.] Operation (<a href="../Text/ch02.html#ch02eq-lev2sec4-2">2</a>) is clearly valid if <code>PTR</code> points <em>anywhere</em> in the circular list. Afterwards we should of course set <code>PTR</code> ← <em>Λ</em>.</p>

  <p class="indent">Using a similar technique, if <code>PTR</code><sub>1</sub> and <code>PTR</code><sub>2</sub> point to disjoint circular lists L<sub>1</sub> and <code>L</code><sub>2</sub>, respectively, we can insert the entire list <code>L</code><sub>2</sub> at the right of L<sub>1</sub> :</p>

  <div class="equation"><a id="ch02eq-lev2sec4-3"></a><img src="../Images/ch02/274equ02.jpg"></div>

  <p>Splitting one circular list into two, in various ways, is another simple operation that can be done. These operations correspond to the concatenation and deconcatenation of strings.</p>

  <p class="indent">Thus we see that a circular list can be used not only to represent inherently circular structures, but also to represent linear structures; a circular list with one pointer to the rear node is essentially equivalent to a straight linear list with two pointers to the front and rear. The natural question to ask, in connection with this observation, is “How do we find the end of the list, when there is circular symmetry?” There is no <em>Λ</em> link to signal the end! The answer is that when we <a id="page_275"></a>are operating on an entire list, moving from one node to the next, we should stop when we get back to our starting place (assuming, of course, that the starting place is still present in the list).</p>

  <p class="indent">An alternative solution to the problem just posed is to put a special, recognizable node into each circular list, as a convenient stopping place. This special node is called the <em>list head</em>, and in applications we often find it is quite convenient to insist that every circular list must have exactly one node that is its list head. One advantage is that the circular list will then never be empty. With a list head, diagram (<a href="../Text/ch02.html#ch02eq-lev2sec4-1">1</a>) becomes</p>

  <div class="equation"><a id="ch02eq-lev2sec4-4"></a><img src="../Images/ch02/275equ01.jpg"></div>

  <p>References to lists like (<a href="../Text/ch02.html#ch02eq-lev2sec4-4">4</a>) are usually made via the list head, which is often in a fixed memory location. The disadvantage of list heads is that there is no pointer to the right end, so we must sacrifice operation (b) stated above.</p>

  <p class="indent">Diagram (<a href="../Text/ch02.html#ch02eq-lev2sec4-4">4</a>) may be compared with <a href="../Text/ch02.html#ch02lev2sec3">2.2.3</a>–(<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>) at the beginning of the previous section, in which the link associated with “item 5” now points to <code>LOC</code>(<code>FIRST</code>) instead of to Λ; the variable <code>FIRST</code> is now thought of as a link within a node, namely the link that is in <code>NODE</code>(<code>LOC</code>(<code>FIRST</code>)). The principal difference between (<a href="../Text/ch02.html#ch02eq-lev2sec4-4">4</a>) and <a href="../Text/ch02.html#ch02lev2sec3">2.2.3</a>–(<a href="../Text/ch02.html#ch02eq-lev2sec3-1">1</a>) is that (<a href="../Text/ch02.html#ch02eq-lev2sec4-4">4</a>) makes it possible (though not necessarily efficient) to get to any point of the list from any other point.</p>

  <p class="indent">As an example of the use of circular lists, we will discuss <em>arithmetic on polynomials</em> in the variables <em>x</em>, <em>y</em>, and <em>z</em>, with integer coefficients. There are many problems in which a scientist wants to manipulate polynomials instead of just numbers; we are thinking of operations like the multiplication of</p>

  <p class="center">(<em>x</em><sup>4</sup> + 2<em>x</em><sup>3</sup><em>y</em> + 3<em>x</em><sup>2</sup><em>y</em><sup>2</sup> + 4<em>xy</em><sup>3</sup> + 5<em>y</em><sup>4</sup>)&nbsp;&nbsp;&nbsp;&nbsp;by&nbsp;&nbsp;&nbsp;(<em>x</em><sup>2</sup> − 2<em>xy</em> + <em>y</em><sup>2</sup>)</p>

  <p>to get</p>

  <p class="center">(<em>x</em><sup>6</sup> − 6<em>xy</em><sup>5</sup> + 5<em>y</em><sup>6</sup>).</p>

  <p>Linked allocation is a natural tool for this purpose, since polynomials can grow to unpredictable sizes and we may want to represent many polynomials in memory at the same time.</p>

  <p class="indent">We will consider here the two operations of addition and multiplication. Let us suppose that a polynomial is represented as a list in which each node stands for one nonzero term, and has the two-word form</p>

  <div class="equation"><a id="ch02eq-lev2sec4-5"></a><img src="../Images/ch02/275equ02.jpg"></div>

  <p>Here <code>COEF</code> is the coefficient of the term in <em>x</em><sup>A</sup><em>y</em><sup>B</sup><em>z</em><sup>C</sup>. We will assume that the coefficients and exponents will always lie in the range allowed by this format, and that it is not necessary to check the ranges during our calculations. The notation <code>ABC</code> will be used to stand for the ± <code>A B C</code> fields of the node (<a href="../Text/ch02.html#ch02eq-lev2sec4-5">5</a>), treated as a single unit. The sign of <code>ABC</code>, namely the sign of the second word in (<a href="../Text/ch02.html#ch02eq-lev2sec4-5">5</a>), will always be <a id="page_276"></a>plus, except that there is a <em>special node</em> at the end of every polynomial that has <code>ABC</code> = −1 and <code>COEF</code> = 0. This special node is a great convenience, analogous to our discussion of a list head above, because it provides a convenient sentinel and it avoids the problem of an empty list (corresponding to the polynomial 0). The nodes of the list always appear in <em>decreasing order</em> of the <code>ABC</code> field, if we follow the direction of the links, except that the special node (which has <code>ABC</code> = −1) links to the largest value of <code>ABC</code>. For example, the polynomial <em>x</em><sup>6</sup> − 6<em>xy</em><sup>5</sup> + 5<em>y</em><sup>6</sup> would be represented thus:</p>

  <div class="image"><img src="../Images/ch02/276fig01.jpg"></div>

  <p><a id="ch02alg-lev2sec4-A"></a><strong>Algorithm A</strong> (<em>Addition of polynomials</em>). This algorithm adds polynomial(<code>P</code>) to polynomial(<code>Q</code>), assuming that <code>P</code> and <code>Q</code> are pointer variables pointing to polynomials having the form above. The list <code>P</code> will be unchanged; the list <code>Q</code> will retain the sum. Pointer variables <code>P</code> and <code>Q</code> return to their starting points at the conclusion of this algorithm; auxiliary pointer variables <code>Q1</code> and <code>Q2</code> are also used.</p>

  <p class="indenthanging"><strong>A1.</strong> [Initialize.] Set <code>P</code> ← <code>LINK</code>(<code>P</code>), <code>Q1</code> ← <code>Q</code>, <code>Q</code> ← <code>LINK</code>(<code>Q</code>). (Now both <code>P</code> and <code>Q</code> point to the leading terms of their polynomials. Throughout most of this algorithm the variable <code>Q1</code> will be one step behind <code>Q</code>, in the sense that <code>Q</code> = <code>LINK</code>(<code>Q1</code>).)</p>

  <p class="indenthanging"><strong>A2.</strong> [<code>ABC</code>(<code>P</code>):<code>ABC</code>(<code>Q</code>).] If <code>ABC</code>(<code>P</code>) &lt; <code>ABC</code>(<code>Q</code>), set <code>Q1</code> ← <code>Q</code> and <code>Q</code> ← <code>LINK</code>(<code>Q</code>) and repeat this step. If <code>ABC</code>(<code>P</code>) = <code>ABC</code>(<code>Q</code>), go to step A3. If <code>ABC</code>(<code>P</code>) &gt; <code>ABC</code>(<code>Q</code>), go to step A5.</p>

  <p class="indenthanging"><strong>A3.</strong> [Add coefficients.] (We’ve found terms with equal exponents.) If <code>ABC</code>(<code>P</code>) &lt; 0, the algorithm terminates. Otherwise set <code>COEF</code>(<code>Q</code>) ← <code>COEF</code>(<code>Q</code>) + <code>COEF</code>(<code>P</code>). Now if <code>COEF</code>(<code>Q</code>) = 0, go to A4; otherwise, set <code>P</code> ← <code>LINK</code>(<code>P</code>), <code>Q1</code> ← <code>Q</code>, <code>Q</code> ← <code>LINK</code>(<code>Q</code>), and go to A2. (Curiously the latter operations are identical to step A1.)</p>

  <p class="indenthanging"><strong>A4.</strong> [Delete zero term.] Set <code>Q</code>2 ← <code>Q</code>, <code>LINK</code>(<code>Q</code>1) ← <code>Q</code> ← <code>LINK</code>(<code>Q</code>), and <code>AVAIL</code> <span class="ent">⇐</span> <code>Q</code>2. (A zero term created in step A3 has been removed from polynomial(<code>Q</code>).) Set <code>P</code> ← <code>LINK</code>(<code>P</code>) and go back to A2.</p>

  <p class="indenthanging"><strong>A5.</strong> [Insert new term.] (Polynomial(<code>P</code>) contains a term that is not present in polynomial(<code>Q</code>), so we insert it in polynomial(<code>Q</code>).) Set <code>Q2</code> <span class="ent">⇐</span> <code>AVAIL</code>, <code>COEF</code>(<code>Q2</code>) ← <code>COEF</code>(<code>P</code>), <code>ABC</code>(<code>Q2</code>) ← <code>ABC</code>(<code>P</code>), <code>LINK</code>(<code>Q2</code>) ← <code>Q</code>, <code>LINK</code>(<code>Q1</code>) ← Q2, <code>Q1</code> ← <code>Q2</code>, <code>P</code> ← <code>LINK</code>(<code>P</code>), and return to step A2. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">One of the most noteworthy features of <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> is the manner in which the pointer variable <code>Q1</code> follows the pointer <code>Q</code> around the list. This is very typical of list processing algorithms, and we will see a dozen more algorithms with the same characteristic. Can the reader see why this idea was used in <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>?</p>

  <p class="indent">A reader who has little prior experience with linked lists will find it very instructive to study <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> carefully; as a test case, try adding <em>x</em> + <em>y</em> + <em>z</em> to <em>x</em><sup>2</sup> − 2<em>y</em> − <em>z</em>.</p>

  <p class="indent"><a id="page_277"></a>Given <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>, the multiplication operation is surprisingly easy:</p>

  <p><a id="ch02alg-lev2sec4-M"></a><strong>Algorithm M</strong> (<em>Multiplication of polynomials</em>). This algorithm, analogous to <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>, replaces polynomial(<code>Q</code>) by</p>

  <p class="center">polynomial(<code>Q</code>) + polynomial(<code>M</code>) × polynomial(<code>P</code>).</p>

  <p class="indenthanging"><strong>M1.</strong> [Next multiplier.] Set <code>M</code> ← <code>LINK</code>(<code>M</code>). If <code>ABC</code>(<code>M</code>) &lt; 0, the algorithm terminates.</p>

  <p class="indenthanging"><strong>M2.</strong> [Multiply cycle.] Perform <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>, except that wherever the notation “<code>ABC</code>(<code>P</code>)” appears in that algorithm, replace it by “(if <code>ABC</code>(<code>P</code>) &lt; 0 then −1, otherwise <code>ABC</code>(<code>P</code>) + <code>ABC</code>(<code>M</code>))”; wherever “<code>COEF</code>(<code>P</code>)” appears in that algorithm replace it by “<code>COEF</code>(<code>P</code>) × <code>COEF</code>(<code>M</code>)”. Then go back to step M1. <span class="middle"><img src="../Images/ch02/box.jpg"></span></p>

  <p>The programming of <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> in <code>MIX</code> language shows again the ease with which linked lists are manipulated in a computer. In the following code we assume that <code>OVERFLOW</code> is a subroutine that either terminates the program (due to lack of memory space) or finds further available space and exits to rJ − 2.</p>

  <p><a id="ch02pro_02"></a><strong>Program A</strong> (<em>Addition of polynomials</em>). This is a subroutine written so that it can be used in conjunction with a multiplication subroutine (see <a href="../Text/ch02.html#ch02ex_2_4_15">exercise 15</a>).</p>

  <div class="imageL"><img src="../Images/ch02/p0277_01.jpg"></div>

  <p>In the coding below, <code>P</code> ≡ rI1, <code>Q</code> ≡ r<code>I</code>2, <code>Q</code>1 ≡ r<code>I</code>3, and <code>Q</code>2 ≡ r<code>I</code>6, in the notation of <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>.</p>

  <div class="image"><img src="../Images/ch02/277pro01.jpg"></div>

  <div class="image"><a id="page_278"></a><img src="../Images/ch02/277pro01a.jpg"></div>

  <p class="indent">Note that <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> traverses each of the two lists just once; it is not necessary to loop around several times. Using Kirchhoff’s law, we find that an analysis of the instruction counts presents no difficulties; the execution time depends on four quantities</p>

  <p class="uln-indent1"><em>m</em>′ = number of matching terms that cancel with each other;</p>

  <p class="uln-indent1"><em>m</em><sup>′′</sup> = number of matching terms that do not cancel;</p>

  <p class="uln-indent1"><em>p</em>′ = number of unmatched terms in polynomial(<code>P</code>);</p>

  <p class="uln-indent1"><em>q</em>′ = number of unmatched terms in polynomial(<code>Q</code>).</p>

  <p>The analysis given with <a href="../Text/ch02.html#ch02pro_02">Program A</a> uses the abbreviations</p>

  <p class="uln-indent1"><em>m</em> = <em>m</em>′ + <em>m</em><sup>′′</sup>, <em>p</em> = <em>m</em> + <em>p</em>′, <em>q</em> = <em>m</em> + <em>q</em>′, <em>x</em> = 1 + <em>m</em> + <em>p</em>′ + <em>q</em>′;</p>

  <p class="exercisesp">the running time for <code>MIX</code> is (27<em>m</em>′ + 18<em>m</em><sup>′′</sup> + 27<em>p</em>′ + 8<em>q</em>′ + 13)<em>u</em>. The total number of nodes in the storage pool needed during the execution of the algorithm is at least 2 + <em>p</em> + <em>q</em>, and at most 2 + <em>p</em> + <em>q</em> + <em>p</em>′.</p>

  <p class="ex-title">Exercises</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_4_1a" id="ch02ex_2_4_1">1</a>.</strong> [<em>21</em>] The text suggests at the beginning of this section that an empty circular list could be represented by <code>PTR</code> = <em>Λ</em>. It might be more consistent with the philosophy of circular lists to have <code>PTR</code> = <code>LOC</code>(<code>PTR</code>) indicate an empty list. Does this convention facilitate operations (a), (b), or (c) described at the beginning of this section?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_4_2a" id="ch02ex_2_4_2">2</a>.</strong> [<em>20</em>] Draw “before and after” diagrams illustrating the effect of the concatenation operation (<a href="../Text/ch02.html#ch02eq-lev2sec4-3">3</a>), assuming that <code>PTR</code><sub>1</sub> and <code>PTR</code><sub>2</sub> are ≠ <em>Λ</em>.</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_3a" id="ch02ex_2_4_3">3</a>.</strong> [<em>20</em>] What does operation (<a href="../Text/ch02.html#ch02eq-lev2sec4-3">3</a>) do if <code>PTR</code><sub>1</sub> and <code>PTR</code><sub>2</sub> are both pointing to nodes in the <em>same</em> circular list?</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_4_4a" id="ch02ex_2_4_4">4</a>.</strong> [<em>20</em>] State insertion and deletion operations that give the effect of a <em>stack</em>, using representation (<a href="../Text/ch02.html#ch02eq-lev2sec4-4">4</a>).</p>

  <div class="image">
    <a id="page_279"></a><a id="ch02fig10"></a><img src="../Images/ch02/02fig10.jpg">

    <p class="fig-caption"><strong>Fig. 10.</strong> Addition of polynomials.</p>
  </div>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_5a" id="ch02ex_2_4_5">5</a>.</strong> [<em>21</em>] Design an algorithm that takes a circular list such as (<a href="../Text/ch02.html#ch02eq-lev2sec4-1">1</a>) and reverses the direction of all the arrows.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_4_6a" id="ch02ex_2_4_6">6</a>.</strong> [<em>18</em>] Give diagrams of the list representation for the polynomials (a) <em>xz</em> − 3; (b) 0.</p>

  <p class="exercises"><strong><a href="../Text/app01a.html#ch02ex_2_4_7a" id="ch02ex_2_4_7">7</a>.</strong> [<em>10</em>] Why is it useful to assume that the <code>ABC</code> fields of a polynomial list appear in decreasing order?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_8a" id="ch02ex_2_4_8">8</a>.</strong> [<em>10</em>] Why is it useful to have <code>Q1</code> trailing one step behind <code>Q</code> in <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a>?</p>

  <p class="exercises2"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_9a" id="ch02ex_2_4_9">9</a>.</strong> [<em>23</em>] Would <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm A</a> work properly if <code>P</code> = <code>Q</code> (i.e., both pointer variables point at the same polynomial)? Would <a href="../Text/ch02.html#ch02alg-lev2sec4-M">Algorithm M</a> work properly if <code>P</code> = <code>M</code>, if <code>P</code> = <code>Q</code>, or if <code>M</code> = <code>Q</code>?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_10a" id="ch02ex_2_4_10">10</a>.</strong> [<em>20</em>] The algorithms in this section assume that we are using three variables <em>x</em>, <em>y</em>, and <em>z</em> in the polynomials, and that their exponents individually never exceed <em>b</em> − 1 (where <em>b</em> is the byte size in <code>MIX</code>’s case). Suppose instead that we want to do addition and multiplication of polynomials in only one variable, <em>x</em>, and to let its exponent take on values up to <em>b</em><sup>3</sup> − 1. What changes should be made to <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithms A</a> and <a href="../Text/ch02.html#ch02alg-lev2sec4-M">M</a>?</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_4_11a" id="ch02ex_2_4_11">11</a>.</strong> [<em>24</em>] (The purpose of this exercise and many of those following is to create a package of subroutines useful for polynomial arithmetic, in conjunction with <a href="../Text/ch02.html#ch02pro_02">Program A</a>.) Since <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithms A</a> and <a href="../Text/ch02.html#ch02alg-lev2sec4-M">M</a> change the value of polynomial(<code>Q</code>), it is sometimes desirable to have a subroutine that makes a copy of a given polynomial. Write a <code>MIX</code> subroutine with the following specifications:</p>

  <div class="imageL"><img src="../Images/ch02/p0279_01.jpg"></div>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_4_12a" id="ch02ex_2_4_12">12</a>.</strong> [<em>21</em>] Compare the running time of the program in <a href="../Text/ch02.html#ch02ex_2_4_11">exercise 11</a> with that of <a href="../Text/ch02.html#ch02pro_02">Program A</a> when polynomial(<code>Q</code>) = 0.</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_4_13a" id="ch02ex_2_4_13">13</a>.</strong> [<em>20</em>] Write a <code>MIX</code> subroutine with the following specifications:</p>

  <div class="imageL"><img src="../Images/ch02/p0279_02.jpg"></div>

  <p class="exercisesp">[<em>Note:</em> This subroutine can be used in conjunction with the subroutine of <a href="../Text/ch02.html#ch02ex_2_4_11">exercise 11</a> in the sequence ‘<code>LD1 Q</code>; <code>JMP ERASE</code>; <code>LD1 P</code>; <code>JMP COPY</code>; <code>ST2 Q</code>’ to achieve the effect “polynomial(<code>Q</code>) ← polynomial(<code>P</code>)”.]</p>

  <p class="exercises1"><a id="page_280"></a><strong><a href="../Text/app01a.html#ch02ex_2_4_14a" id="ch02ex_2_4_14">14</a>.</strong> [<em>22</em>] Write a <code>MIX</code> subroutine with the following specifications:</p>

  <div class="imageL"><img src="../Images/ch02/p0280_01.jpg"></div>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_4_15a" id="ch02ex_2_4_15">15</a>.</strong> [<em>24</em>] Write a <code>MIX</code> subroutine to perform <a href="../Text/ch02.html#ch02alg-lev2sec4-M">Algorithm M</a>, having the following specifications:</p>

  <div class="imageL"><img src="../Images/ch02/p0280_02.jpg"></div>

  <p class="exercisesp">[<em>Note:</em> Use <a href="../Text/ch02.html#ch02pro_02">Program A</a> as a subroutine, changing the settings of <code>SW1</code>, <code>SW2</code>, and <code>SW3</code>.]</p>

  <p class="exercises1"><strong><a href="../Text/app01a.html#ch02ex_2_4_16a" id="ch02ex_2_4_16">16</a>.</strong> [<em>M28</em>] Estimate the running time of the subroutine in <a href="../Text/ch02.html#ch02ex_2_4_15">exercise 15</a> in terms of some relevant parameters.</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_17a" id="ch02ex_2_4_17">17</a>.</strong> [<em>22</em>] What advantage is there in representing polynomials with a circular list as in this section, instead of with a straight linear linked list terminated by <em>Λ</em> as in the previous section?</p>

  <p class="exercises3"><span class="middle"><img src="../Images/ch02/arrow.png"></span>&nbsp;&nbsp;&nbsp;<strong><a href="../Text/app01a.html#ch02ex_2_4_18a" id="ch02ex_2_4_18">18</a>.</strong> [<em>25</em>] Devise a way to represent circular lists inside a computer in such a way that the list can be traversed efficiently in both directions, yet only one link field is used per node. [<em>Hint:</em> If we are given two pointers, to two successive nodes <em>x</em><sub><em>i</em>−1</sub> and <em>x</em><sub><em>i</em></sub>, it should be possible to locate both <em>x</em><sub><em>i</em>+1</sub> and <em>x</em><sub><em>i</em>−2</sub>.]</p>

  <div class="heading">
    <h4 id="ch02lev2sec5">2.2.5. Doubly Linked Lists</h4>

    <p>For even greater flexibility in the manipulation of linear lists, we can include two links in each node, pointing to the items on either side of that node:</p>
  </div>

  <div class="equation"><a id="ch02eq-lev2sec5-1"></a><img src="../Images/ch02/280equ01.jpg"></div>

  <p>Here <code>LEFT</code> and <code>RIGHT</code> are pointer variables to the left and right of the list. Each node of the list includes two links, called, for example, <code>LLINK</code> and <code>RLINK</code>. The operations of a general deque are readily performed with such a representation; see <a href="../Text/ch02a.html#ch02ex_2_5_1">exercise 1</a>. However, manipulations of doubly linked lists almost always become much easier if a <em>list head</em> node is part of each list, as described in the preceding section. When a list head is present, we have the following typical diagram of a doubly linked list:</p>

  <div class="equation"><a id="ch02eq-lev2sec5-2"></a><img src="../Images/ch02/280equ02.jpg"></div>

  <p>The <code>RLINK</code> and <code>LLINK</code> fields of the list head take the place of <code>LEFT</code> and <code>RIGHT</code> in (<a href="../Text/ch02.html#ch02eq-lev2sec5-1">1</a>). There is complete symmetry between left and right; the list head could equally well have been shown at the right of (<a href="../Text/ch02.html#ch02eq-lev2sec5-2">2</a>). If the list is empty, both link fields of the list head point to the head itself.</p>

  <p class="indent">The list representation (<a href="../Text/ch02.html#ch02eq-lev2sec5-2">2</a>) clearly satisfies the condition</p>

  <div class="equation"><a id="ch02eq-lev2sec5-3"></a><img src="../Images/ch02/280equ03.jpg"></div>

  <p><a id="page_281"></a>if <code>X</code> is the location of any node in the list (including the head). This fact is the principal reason that representation (<a href="../Text/ch02.html#ch02eq-lev2sec5-2">2</a>) is preferable to (<a href="../Text/ch02.html#ch02eq-lev2sec5-1">1</a>).</p>

  <p class="indent">A doubly linked list usually takes more memory space than a singly linked one does (although there is sometimes room for another link in a node that doesn’t fill a complete computer word). But the additional operations that can be performed efficiently with two-way links are often more than ample compensation for the extra space requirement. Besides the obvious advantage of being able to go back and forth at will when examining a doubly linked list, one of the principal new abilities is the fact that <em>we can delete</em> <code>NODE</code>(<code>X</code>) <em>from the list it is in, given only the value of</em> X. This deletion operation is easy to derive from a “before and after” diagram (<a href="../Text/ch02.html#ch02fig11">Fig. 11</a>) and it is very simple:</p>

  <div class="equation"><a id="ch02eq-lev2sec5-4"></a><img src="../Images/ch02/281equ01.jpg"></div>

  <div class="image">
    <a id="ch02fig11"></a><img src="../Images/ch02/02fig11.jpg">

    <p class="fig-caption"><strong>Fig. 11.</strong> Deletion from a doubly linked list.</p>
  </div>

  <p class="indent">In a list that has only one-way links, we cannot delete <code>NODE</code>(<code>X</code>) without knowing which node precedes it in the chain, since the preceding node needs to have its link altered when <code>NODE</code>(<code>X</code>) is deleted. In all the algorithms considered in <a href="../Text/ch02.html#ch02lev2sec3">Sections 2.2.3</a> and <a href="../Text/ch02.html#ch02lev2sec4">2.2.4</a> this additional knowledge was present whenever a node was to be deleted; see, in particular, <a href="../Text/ch02.html#ch02alg-lev2sec4-A">Algorithm 2.2.4A</a>, where we had pointer <code>Q1</code> following pointer <code>Q</code> for just this purpose. But we will meet several algorithms that require removing random nodes from the middle of a list, and doubly linked lists are frequently used just for this reason. (We should point out that in a circular list it is possible to delete <code>NODE</code>(<code>X</code>), given <code>X</code>, if we go around the entire circle to find the predecessor of <code>X</code>. But this operation is clearly inefficient when the list is long, so it is rarely an acceptable substitute for doubly linking the list. See also the answer to <a href="../Text/ch02.html#ch02ex_2_4_8">exercise 2.2.4–8</a>.)</p>

  <p class="indent">Similarly, a doubly linked list permits the easy insertion of a node adjacent to <code>NODE</code>(<code>X</code>) at either the left or the right. The steps</p>

  <div class="equation"><a id="ch02eq-lev2sec5-5"></a><img src="../Images/ch02/281equ02.jpg"></div>

  <p>do such an insertion to the right of <code>NODE</code>(<code>X</code>); and by interchanging left and right we get the corresponding algorithm for insertion to the left. Operation (<a href="../Text/ch02.html#ch02eq-lev2sec5-5">5</a>) changes the settings of five links, so it is a little slower than an insertion operation in a one-way list where only three links need to be changed.</p>

  <p class="indent"><a id="page_282"></a>As an example of the use of doubly linked lists, we will now consider the writing of a <em>discrete simulation</em> program. “Discrete simulation” means the simulation of a system in which all changes in the state of the system may be assumed to happen at certain discrete instants of time. The “system” being simulated is usually a set of individual activities that are largely independent although they interact with each other; examples are customers at a store, ships in a harbor, people in a corporation. In a discrete simulation, we proceed by doing whatever is to be done at a certain instant of simulated time, then advance the simulated clock to the next time when some action is scheduled to occur.</p>

  <p class="indent">By contrast, a “continuous simulation” would be simulation of activities that are under continuous changes, such as traffic moving on a highway, spaceships traveling to other planets, etc. Continuous simulation can often be satisfactorily approximated by discrete simulation with very small time intervals between steps; however, in such a case we usually have “synchronous” discrete simulation, in which many parts of the system are slightly altered at each discrete time interval, and such an application generally calls for a somewhat different type of program organization than the kind considered here.</p>

  <p class="indent">The program developed below simulates the elevator system in the Mathematics building of the California Institute of Technology. The results of such a simulation will perhaps be of use only to people who make reasonably frequent visits to Caltech; and even for them, it may be simpler just to try using the elevator several times instead of writing a computer program. But, as is usual with simulation studies, the methods we will use are of much more interest than the answers given by the program. The methods to be discussed below illustrate typical implementation techniques used with discrete simulation programs.</p>

  <p class="indent">The Mathematics building has five floors: sub-basement, basement, first, second, and third. There is a single elevator, which has automatic controls and can stop at each floor. For convenience we will renumber the floors 0, 1, 2, 3, and 4.</p>

  <p class="indent">On each floor there are two call buttons, one for <code>UP</code> and one for <code>DOWN</code>. (Actually floor 0 has only <code>UP</code> and floor 4 has only <code>DOWN</code>, but we may ignore that anomaly since the excess buttons will never be used.) Corresponding to these buttons, there are ten variables <code>CALLUP</code>[<em>j</em>] and <code>CALLDOWN</code>[<em>j</em>], 0 ≤ <em>j</em> ≤ 4. There are also variables <code>CALLCAR</code>[<em>j</em>], 0 ≤ <em>j</em> ≤ 4, representing buttons within the elevator car, which direct it to a destination floor. When a person presses a button, the appropriate variable is set to 1; the elevator clears the variable to 0 after the request has been fulfilled.</p>

  <p class="indent">So far we have described the elevator from a user’s point of view; the situation is more interesting as viewed by the elevator. The elevator is in one of three states: <code>GOINGUP</code>, <code>GOINGDOWN</code>, or <code>NEUTRAL</code>. (The current state is indicated to passengers by lighted arrows inside the elevator.) If it is in <code>NEUTRAL</code> state and not on floor 2, the machine will close its doors and (if no command is given by the time its doors are shut) it will change to <code>GOINGUP</code> or <code>GOINGDOWN</code>, heading for floor 2. (This is the “home floor,” since most passengers get in there.) On floor 2 in <code>NEUTRAL</code> state, the doors will eventually close and the machine will wait 2.2.5 <a id="page_283"></a>silently for another command. The first command received for another floor sets the machine <code>GOINGUP</code> or <code>GOINGDOWN</code> as appropriate; it stays in this state until there are no commands waiting in the same direction, and then it switches direction or switches to <code>NEUTRAL</code> just before opening the doors, depending on what other commands are in the <code>CALL</code> variables. The elevator takes a certain amount of time to open and close its doors, to accelerate and decelerate, and to get from one floor to another. All of these quantities are indicated in the algorithm below, which is much more precise than an informal description can be. The algorithm we will now study may not reflect the elevator’s true principles of operation, but it is believed to be the simplest set of rules that explain all the phenomena observed during several hours of experimentation by the author during the writing of this section.</p>

  <p class="indent">The elevator system is simulated by using two coroutines, one for the passengers and one for the elevator; these routines specify all the actions to be performed, as well as various time delays that are to be used in the simulation. In the following description, the variable <code>TIME</code> represents the current value of the simulated time clock. All units of time are given in <em>tenths of seconds</em>. There are also several other variables:</p>

  <p class="indent-1"><code>FLOOR</code>, the current position of the elevator;</p>

  <p class="indent-1"><code>D1</code>, a variable that is zero except during the time people are getting in or out of the elevator;</p>

  <p class="indent-1"><code>D2</code>, a variable that becomes zero if the elevator has sat on one floor without moving for 30 sec or more;</p>

  <p class="indent-1"><code>D3</code>, a variable that is zero except when the doors are open but nobody is getting in or out of the elevator;</p>

  <p class="indent-1"><code>STATE</code>, the current state of the elevator (<code>GOINGUP</code>, <code>GOINGDOWN</code>, or <code>NEUTRAL</code>).</p>

  <p>Initially <code>FLOOR</code> = 2, <code>D1</code> = <code>D2</code> = <code>D3</code> = 0, and <code>STATE</code> = <code>NEUTRAL</code>.</p>

  <p><strong>Coroutine U</strong> (<em>Users</em>). Everyone who enters the system begins to perform the actions specified below, starting at step U1.</p>

  <p class="indenthanging"><strong>U1.</strong> [Enter, prepare for successor.] The following quantities are determined in some manner that will not be specified here:</p>

  <p class="indent-2"><code>IN</code>, the floor on which the new user has entered the system;</p>

  <p class="indent-2"><code>OUT</code>, the floor to which this user<br>
  wants to go (<code>OUT</code> ≠ <code>IN</code>);</p>

  <p class="indent-2"><code>GIVEUPTIME</code>, the amount of time this user will wait for the elevator before running out of patience and deciding to walk;</p>

  <p class="indent-2"><code>INTERTIME</code>, the amount of time before another user will enter the system.</p>

  <p class="indenthangingP">After these quantities have been computed, the simulation program sets things up so that another user enters the system at <code>TIME + INTERTIME</code>.</p>

  <p class="indenthanging"><strong>U2.</strong> [Signal and wait.] (The purpose of this step is to call for the elevator; some special cases arise if the elevator is already on the right floor.) If <code>FLOOR = IN</code> and if the elevator’s next action is step E6 below (that is, if the elevator doors are now closing), send the elevator immediately to its step E3 and cancel its <a id="page_284"></a>activity E6. (This means that the doors will open again before the elevator moves.) If <code>FLOOR = IN</code> and if <code>D3</code> ≠ 0, set <code>D3</code> ← 0, set <code>D1</code> to a nonzero value, and start up the elevator’s activity E4 again. (This means that the elevator doors are open on this floor, but everyone else has already gotten on or off. Elevator step E4 is a sequencing step that grants people permission to enter the elevator according to normal laws of courtesy; therefore, restarting E4 gives this user a chance to get in before the doors close.) In all other cases, the user sets <code>CALLUP[IN]</code> ← <code>1</code> or <code>CALLDOWN[IN]</code> ← 1, according as <code>OUT</code> &gt; <code>IN</code> or <code>OUT</code> &lt; <code>IN</code>; and if <code>D2</code> = 0 or the elevator is in its “dormant” position E1, the <code>DECISION</code> subroutine specified below is performed. (The <code>DECISION</code> subroutine is used to take the elevator out of <code>NEUTRAL</code> state at certain critical times.)</p>

  <p class="indenthanging"><strong>U3.</strong> [Enter queue.] Insert this user at the rear of <code>QUEUE[IN]</code>, which is a linear list representing the people waiting on this floor. Now the user waits patiently for <code>GIVEUPTIME</code> units of time, unless the elevator arrives first — more precisely, unless step E4 of the elevator routine below sends this user to U5 and cancels the scheduled activity U4.</p>

  <p class="indenthanging"><strong>U4.</strong> [Give up.] If <code>FLOOR ≠ IN</code> or <code>D1</code> = 0, delete this user from <code>QUEUE[IN]</code> and from the simulated system. (The user has decided that the elevator is too slow, or that a bit of exercise will be better than an elevator ride.) If <code>FLOOR = IN</code> and <code>D1</code> ≠ 0, the user stays and waits (knowing that the wait won’t be long).</p>

  <p class="indenthanging"><strong>U5.</strong> [Get in.] This user now leaves <code>QUEUE[IN]</code> and enters <code>ELEVATOR</code>, which is a stack-like list representing the people now on board the elevator. Set <code>CALLCAR[OUT]</code> ← 1.</p>

  <p class="indenthangingP1">Now if <code>STATE = NEUTRAL</code>, set <code>STATE</code> ← <code>GOINGUP</code> or <code>GOINGDOWN</code> as appropriate, and set the elevator’s activity E5 to be executed after 25 units of time. (This is a special feature of the elevator, allowing the doors to close faster than usual if the elevator is in <code>NEUTRAL</code> state when the user selects a destination floor. The 25-unit time interval gives step E4 the opportunity to make sure that D1 is properly set up by the time step E5, the door-closing action, occurs.)</p>

  <p class="indenthangingP1">Now the user waits until being sent to step U6 by step E4 below, when the elevator has reached the desired floor.</p>

  <p class="indenthanging"><strong>U6.</strong> [Get out.] Delete this user from the <code>ELEVATOR</code> list and from the simulated system. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p><strong>Coroutine E</strong> (<em>Elevator</em>). This coroutine represents the actions of the elevator; step E4 also handles the control of when people get in and out.</p>

  <p class="indenthanging"><strong>E1.</strong> [Wait for call.] (At this point the elevator is sitting at floor 2 with the doors closed, waiting for something to happen.) If someone presses a button, the <code>DECISION</code> subroutine will take us to step E3 or E6. Meanwhile, wait.</p>

  <p class="indenthanging"><strong>E2.</strong> [Change of state?] If <code>STATE</code> = <code>GOINGUP</code> and <code>CALLUP</code>[<em>j</em>] = <code>CALLDOWN</code>[<em>j</em>] = <code>CALLCAR</code>[<em>j</em>] = 0 for all <em>j</em> &gt; <code>FLOOR</code>, then set <code>STATE</code> ← <code>NEUTRAL</code> or <code>STATE</code> ← <a id="page_285"></a><code>GOINGDOWN</code>, according as <code>CALLCAR[</code><em>j</em><code>]</code> = 0 for all <em>j</em> &gt; <code>FLOOR</code> or not, and set all <code>CALL</code> variables for the current floor to zero. If <code>STATE</code> = <code>GOINGDOWN</code>, do similar actions with directions reversed.</p>

  <p class="indenthanging"><strong>E3.</strong> [Open doors.] Set <code>D1</code> and <code>D2</code> to any nonzero values. Set elevator activity E9 to start up independently after 300 units of time. (This activity may be canceled in step E6 below before it occurs. If it has already been scheduled and not canceled, we cancel it and reschedule it.) Also set elevator activity E5 to start up independently after 76 units of time. Then wait 20 units of time (to simulate opening of the doors) and go to E4.</p>

  <p class="indenthanging"><strong>E4.</strong> [Let people out, in.] If anyone in the <code>ELEVATOR</code> list has <code>OUT</code> = <code>FLOOR</code>, send the user of this type who has most recently entered immediately to step U6, wait 25 units, and repeat step E4. If no such users exist, but <code>QUEUE[FLOOR]</code> is not empty, send the front person of that queue immediately to step U5 instead of U4, wait 25 units, and repeat step E4. But if <code>QUEUE[FLOOR]</code> is empty, set <code>D1</code> ← 0, make <code>D3</code> nonzero, and wait for some other activity to initiate further action. (Step E5 will send us to E6, or step U2 will restart E4.)</p>

  <p class="indenthanging"><strong>E5.</strong> [Close doors.] If <code>D1</code> ≠ 0, wait 40 units and repeat this step (the doors flutter a little, but they spring open again, since someone is still getting out or in). Otherwise set <code>D3</code> ← 0 and set the elevator to start at step E6 after 20 units of time. (This simulates closing the doors after people have finished getting in or out; but if a new user enters on this floor while the doors are closing, they will open again as stated in step U2.)</p>

  <p class="indenthanging"><strong>E6.</strong> [Prepare to move.] Set <code>CALLCAR[FLOOR]</code> to zero; also set <code>CALLUP[FLOOR]</code> to zero if <code>STATE</code> ≠ <code>GOINGDOWN</code>, and also set <code>CALLDOWN[FLOOR]</code> to zero if <code>STATE</code> ≠ <code>GOINGUP</code>. (<em>Note:</em> If <code>STATE</code> ≠ <code>GOINGUP</code>, the elevator does not clear out <code>CALLDOWN</code>, since it assumes that people who are going down will not have entered; but see <a href="../Text/ch02a.html#ch02ex_2_5_6">exercise 6</a>.) Now perform the <code>DECISION</code> subroutine.</p>

  <p class="indenthangingP1">If <code>STATE</code> = <code>NEUTRAL</code> even after the <code>DECISION</code> subroutine has acted, go to E1. Otherwise, if <code>D2</code> ≠ 0, cancel the elevator activity E9. Finally, if <code>STATE</code> = <code>GOINGUP</code>, wait 15 units of time (for the elevator to build up speed) and go to E7; if <code>STATE</code> = <code>GOINGDOWN</code>, wait 15 units and go to E8.</p>

  <p class="indenthanging"><strong>E7.</strong> [Go up a floor.] Set <code>FLOOR</code> ← <code>FLOOR</code> + 1 and wait 51 units of time. If now <code>CALLCAR[FLOOR]</code> = 1 or <code>CALLUP[FLOOR]</code> = 1, or if ((<code>FLOOR</code> = 2 or <code>CALLDOWN[FLOOR]</code> = 1) and <code>CALLUP[</code><em>j</em><code>]</code> = <code>CALLDOWN[</code><em>j</em><code>]</code> = <code>CALLCAR[</code><em>j</em><code>]</code> = 0 for all <em>j</em> &gt; <code>FLOOR</code>), wait 14 units (for deceleration) and go to E2. Otherwise, repeat this step.</p>

  <p class="indenthanging"><strong>E8.</strong> [Go down a floor.] This step is like E7 with directions reversed, and also the times 51 and 14 are changed to 61 and 23, respectively. (It takes the elevator longer to go down than up.)</p>

  <p class="indenthanging"><strong>E9.</strong> [Set inaction indicator.] Set <code>D2</code> ← 0 and perform the <code>DECISION</code> subroutine. (This independent action is initiated in step E3 but it is almost always canceled in step E6. See <a href="../Text/ch02a.html#ch02ex_2_5_4">exercise 4</a>.) <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p><a id="page_287"></a><strong>Subroutine D</strong> (DECISION <em>subroutine</em>). This subroutine is performed at certain critical times, as specified in the coroutines above, when a decision about the elevator’s next direction is to be made.</p>

  <p class="indenthanging"><strong>D1.</strong> [Decision necessary?] If <code>STATE</code> ≠ <code>NEUTRAL</code>, exit from this subroutine.</p>

  <p class="indenthanging"><strong>D2.</strong> [Should doors open?] If the elevator is positioned at E1 and if <code>CALLUP[2]</code>, <code>CALLCAR[2]</code>, and <code>CALLDOWN[2]</code> are not all zero, cause the elevator to start its activity E3 after 20 units of time, and exit from this subroutine. (If the <code>DECISION</code> subroutine is currently being invoked by the independent activity E9, it is possible for the elevator coroutine to be positioned at E1.)</p>

  <p class="indenthanging"><strong>D3.</strong> [Any calls?] Find the smallest <em>j</em> ≠ <code>FLOOR</code> for which <code>CALLUP[</code><em>j</em><code>]</code>, <code>CALLCAR[</code><em>j</em><code>]</code>, or <code>CALLDOWN[</code><em>j</em><code>]</code> is nonzero, and go on to step D4. But if no such <em>j</em> exists, then set <em>j</em> ← 2 if the <code>DECISION</code> subroutine is currently being invoked by step E6; otherwise exit from this subroutine.</p>

  <p class="indenthanging"><strong>D4.</strong> [Set <code>STATE</code>.] If <code>FLOOR</code> <em>&gt; j</em>, set <code>STATE</code> ← <code>GOINGDOWN</code>; if <code>FLOOR</code> <em>&lt; j</em>, set <code>STATE</code> ← <code>GOINGUP</code>.</p>

  <p class="indenthanging"><strong>D5.</strong> [Elevator dormant?] If the elevator coroutine is positioned at step E1, and if <em>j</em> ≠ 2, set the elevator to perform step E6 after 20 units of time. Exit from the subroutine. <span class="middle"><img src="../Images/ch02/common-01.jpg"></span></p>

  <p class="indent">The elevator system described above is quite complicated by comparison with other algorithms we have seen in this book, but the choice of a real-life system is more typical of a simulation problem than any cooked-up “textbook example” would ever be.</p>

  <p class="indent">To help understand the system, consider <a href="../Text/ch02.html#ch02tab01">Table 1</a>, which gives part of the history of one simulation. It is perhaps best to start by examining the simple case starting at time 4257: The elevator is sitting idly at floor 2 with its doors shut, when a user arrives (time 4384); let’s say the user’s name is Don. Two seconds later, the doors open, and Don gets in after two more seconds. By pushing button “3” he starts the elevator moving up; ultimately he gets off at floor 3 and the elevator returns to floor 2.</p>

  <div class="image4">
    <a id="page_286"></a><a id="ch02tab01"></a><img class="img1" src="../Images/ch02/286tab01.jpg">

    <p class="tab-caption"><strong>Table 1</strong> Some Actions of the Elevator System</p>
  </div>

  <p class="indent">The first entries in <a href="../Text/ch02.html#ch02tab01">Table 1</a> show a much more dramatic scenario: A user calls the elevator to floor 0, but loses patience and gives up after 15.2 sec. The elevator stops at floor 0 but finds nobody there; then it heads to floor 4, since there are several calls wanting to go downward; etc.</p>

  <p class="indent">The programming of this system for a computer (in our case, <code>MIX</code>) merits careful study. At any given time during the simulation, we may have many simulated users in the system (in various queues and ready to “give up” at various times), and there is also the possibility of essentially simultaneous execution of steps E4, E5, and E9 if many people are trying to get out as the elevator is trying to close its doors. The passing of simulated time and the handling of “simultaneity” may be programmed by having each entity represented by a node that includes a <code>NEXTTIME</code> field (denoting the time when the next action for this entity is to take place) and a <code>NEXTINST</code> field (denoting the memory address where this entity is to start executing instructions, analogous to ordinary coroutine <a id="page_288"></a>linkage). Each entity waiting for time to pass is placed in a doubly linked list called the <code>WAIT</code> list; this “agenda” is sorted on the <code>NEXTTIME</code> fields of its nodes, so that the actions may be processed in the correct sequence of simulated times. The program also uses doubly linked lists for the <code>ELEVATOR</code> and for the <code>QUEUE</code> lists.</p>

  <p class="indent">Each node representing an activity (whether a user or an elevator action) has the form</p>

  <div class="equation"><a id="ch02eq-lev2sec5-6"></a><img src="../Images/ch02/288equ01.jpg"></div>

  <p>Here <code>LLINK1</code> and <code>RLINK1</code> are the links for the <code>WAIT</code> list; <code>LLINK2</code> and <code>RLINK2</code> are used as links in the <code>QUEUE</code> lists or the <code>ELEVATOR</code>. The latter two fields and the <code>IN</code> and <code>OUT</code> field are relevant when node (<a href="../Text/ch02.html#ch02eq-lev2sec5-6">6</a>) represents a user, but they are not relevant for nodes that represent elevator actions. The third word of the node is actually a <code>MIX</code> ‘<code>JMP</code>’ instruction.</p>

  <p class="indent"><a href="../Text/ch02.html#ch02fig12">Figure 12</a> shows typical contents of the <code>WAIT</code> list, <code>ELEVATOR</code> list, and one of the <code>QUEUE</code> lists; each node in the <code>QUEUE</code> list is simultaneously in the <code>WAIT</code> list with <code>NEXTINST</code> = U4, but this has not been indicated in the figure, since the complexity of the linking would obscure the basic idea.</p>

  <div class="image4">
    <a id="ch02fig12"></a><img class="img1" src="../Images/ch02/02fig12.jpg">

    <p class="fig-caption"><strong>Fig. 12.</strong> Some lists used in the elevator simulation program. (List heads appear at the left.)</p>
  </div>

  <p class="indent">Now let us consider the program itself. It is quite long, although (as with all long programs) it divides into small parts each of which is quite simple in itself. <a id="page_289"></a>First comes a number of lines of code that just serve to define the initial contents of the tables. There are several points of interest here: We have list heads for the <code>WAIT</code> list (lines 010–011), the <code>QUEUE</code> lists (lines 026–031), and the <code>ELEVATOR</code> list (lines 032–033). Each of them is a node of the form (<a href="../Text/ch02.html#ch02eq-lev2sec5-6">6</a>), but with unimportant words deleted; the <code>WAIT</code> list head contains only the first two words of a node, and the <code>QUEUE</code> and <code>ELEVATOR</code> list heads require only the last word of a node. We also have four nodes that are always present in the system (lines 012–023): <code>USER1</code>, a node that is always positioned at step U1 ready to enter a new user into the system; <code>ELEV1</code>, a node that governs the main actions of the elevator at steps E1, E2, E3, E4, E6, E7, and E8; and <code>ELEV2</code> and <code>ELEV3</code>, nodes that are used for the elevator actions E5 and E9, which take place independently of other elevator actions with respect to simulated time. Each of these four nodes contains only three words, since they never appear in the <code>QUEUE</code> or <code>ELEVATOR</code> lists. The nodes representing each actual user in the system will appear in a storage pool following the main program.</p>

  <div class="image"><img src="../Images/ch02/289pro01.jpg"></div>

  <div class="image"><img src="../Images/ch02/289pro01a.jpg"></div>

  <p class="indent"><a id="page_290"></a>The next part of the program coding contains basic subroutines and the main control routines for the simulation process. Subroutines <code>INSERT</code> and <code>DELETE</code> perform typical manipulations on doubly linked lists; they put the current node into or take it out of a <code>QUEUE</code> or <code>ELEVATOR</code> list. (In the program, the “current node” C is always represented by index register 6.) There are also subroutines for the <code>WAIT</code> list: Subroutine <code>SORTIN</code> adds the current node to the <code>WAIT</code> list, sorting it into the right place based on its <code>NEXTTIME</code> field. Subroutine <code>IMMED</code> inserts the current node at the front of the <code>WAIT</code> list. Subroutine <code>HOLD</code> puts the current node into the <code>WAIT</code> list, with <code>NEXTTIME</code> equal to the current time plus the amount in register A. Subroutine <code>DELETEW</code> deletes the current node from the <code>WAIT</code> list.</p>

  <p class="indent">The routine <code>CYCLE</code> is the heart of the simulation control: It decides which activity is to act next (namely, the first element of the <code>WAIT</code> list, which we know is nonempty), and jumps to it. There are two special entrances to <code>CYCLE</code>: <code>CYCLE1</code> first sets <code>NEXTINST</code> in the current node, and <code>HOLDC</code> is the same with an additional call on the <code>HOLD</code> subroutine. Thus, the effect of the instruction ‘<code>JMP HOLD</code>C’ with amount <em>t</em> in register A is to suspend activity for <em>t</em> units of simulated time and then to return to the following location.</p>

  <div class="image"><img src="../Images/ch02/290pro01.jpg"></div>

  <div class="image"><a id="page_291"></a><img src="../Images/ch02/290pro01a.jpg"></div>

  <p class="indent">Now comes the program for Coroutine U. At the beginning of step U1, the current node <code>C</code> is <code>USER1</code> (see lines 012–014 above), and lines 099–100 of the program cause <code>USER1</code> to be reinserted into the <code>WAIT</code> list so that the next user will be generated after <code>INTERTIME</code> units of simulated time. The following lines 101–114 take care of setting up a node for the newly generated user; the <code>IN</code> and <code>OUT</code> floors are recorded in this node position. The <code>AVAIL</code> stack is singly linked in the <code>RLINK1</code> field of each node. Note that lines 101–108 perform the action “<code>C</code> <span class="ent">⇐</span> <code>AVAIL</code>” using the <code>POOLMAX</code> technique, <a href="../Text/ch02.html#ch02eq-lev2sec3-7">2.2.3–(7</a>); no test for <code>OVERFLOW</code> is necessary here, since the total size of the storage pool (the number of users in the system at any one time) rarely exceeds 10 nodes (40 words). The return of a node to the <code>AVAIL</code> stack appears in lines 156–158.</p>

  <p class="indent"><a id="page_292"></a>Throughout the program, index register 4 equals the variable <code>FLOOR</code>, and index register 5 is positive, negative, or zero, depending on whether <code>STATE</code> = <code>GOINGUP</code>, <code>GOINGDOWN</code>, or <code>NEUTRAL</code>. The variables <code>CALLUP[</code><em>j</em><code>]</code>, <code>CALLCAR[</code><em>j</em><code>]</code>, and <code>CALLDOWN[</code><em>j</em><code>]</code> occupy the respective fields (1 : 1), (3 : 3), and (5 : 5) of location <code>CALL</code> + <em>j</em>.</p>

  <div class="image"><img src="../Images/ch02/292pro01.jpg"></div>

  <div class="image"><img src="../Images/ch02/292pro01a.jpg"></div>

  <div class="image"><img src="../Images/ch02/292pro01b.jpg"></div>

  <p class="indent"><a id="page_293"></a>The program for Coroutine E is a rather straightforward rendition of the semiformal description given earlier. Perhaps the most interesting portion is the preparation for the elevator’s independent actions in step E3, and the searching of the <code>ELEVATOR</code> and <code>QUEUE</code> lists in step E4.</p>

  <div class="image"><img src="../Images/ch02/293pro01.jpg"></div>

  <div class="image"><a id="page_294"></a><img src="../Images/ch02/293pro01a.jpg"></div>

  <div class="image"><a id="page_295"></a><img src="../Images/ch02/293pro01b.jpg"></div>

  <div class="image"><img src="../Images/ch02/293pro01c.jpg"></div>

  <p class="indent"><a id="page_296"></a>We will not consider here the <code>DECISION</code> subroutine (see <a href="../Text/ch02a.html#ch02ex_2_5_9">exercise 9</a>), nor the <code>VALUES</code> subroutine that is used to specify the demands on the elevator. At the very end of the program comes the code</p>

  <div class="image"><img src="../Images/ch02/296pro01.jpg"></div>

  <p class="indent">The program above does a fine job of simulating the elevator system, as it goes through its paces. But it would be useless to run this program, since there is no output! Actually, the author added a <code>PRINT</code> subroutine that was called at most of the critical steps in the program above, and this was used to prepare <a href="../Text/ch02.html#ch02tab01">Table 1</a>; the details have been omitted, since they are very straightforward but they only clutter up the code.</p>

  <p class="indent">Several programming languages have been devised that make it quite easy to specify the actions in a discrete simulation, and to use a compiler to translate these specifications into machine language. Assembly language was used in this section, of course, since we are concerned here with the basic techniques of linked list manipulation, and we want to see the details of how discrete simulations can actually be performed by a computer that has a one-track mind. The technique of using a <code>WAIT</code> list or agenda to control the sequencing of coroutines, as we have done in this section, is called <em>quasiparal lel processing</em>.</p>

  <p class="indent">It is quite difficult to give a precise analysis of the running time of such a long program, because of the complex interactions involved; but large programs often spend most of their time in comparatively short routines doing comparatively simple things. Therefore we can usually get a good indication of the overall efficiency by using a special trace routine called a <em>profiler</em>, which executes the program and records how often each instruction is performed. This identifies the “bottlenecks,” the places that should be given special attention. [See <a href="../Text/ch01c.html#ch01ex_3_5_7">exercise 1.4.3.2–7</a>. See also <em>Software Practice &amp; Experience</em> <strong>1</strong> (1971), 105–133, for examples of such studies on randomly selected <code>FORTRAN</code> programs found in wastebaskets at the Stanford Computer Center.] The author made such an experiment with the elevator program above, running it for 10000 units of simulated elevator time; 26 users entered the simulated system. The instructions in the <code>SORTIN</code> loop, lines 073–075, were executed by far the most often, 1432 times, while the <code>SORTIN</code> subroutine itself was called 437 times. The <code>CYCLE</code> routine was performed 407 times; so we could gain a little speed by not calling the <code>DELETEW</code> subroutine at line 095: The four lines of that subroutine could be written out in full (to save 4<em>u</em> each time <code>CYCLE</code> is used). The profiler also showed that the <code>DECISION</code> subroutine was called only 32 times and the loop in E4 (lines 217–219) was executed only 142 times.</p>

  <p class="indent">It is hoped that some reader will learn as much about simulation from the example above as the author learned about elevators while the example was being prepared.</p>
</body>
</html>