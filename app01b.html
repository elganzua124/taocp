<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX", "output/HTML-CSS"],
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      processEscapes: true
    },
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>

<script type="text/javascript" src="../MathJax-2.4-latest/MathJax.js?config=TeX-AMS_HTML"></script>

  <title>Section 2.4 - The Art of Computer Programming: Volume 1 / Fundamental Algorithms, Third Edition</title>
  <link href="../Styles/style.css" rel="stylesheet" type="text/css" />
</head>

<body class="soluc">
  <div class="heading">
    <h4 id="app01lev2sec23">Section 2.3.1</h4>

    <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_1" id="ch02ex_2_7_1a">1</a>.</strong> ${\tt INFO(T)}=A$, ${\tt INFO(RLINK(T))}=C$, etc.; the answer is $H$.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_2" id="ch02ex_2_7_2a">2</a>.</strong> Preorder: 1245367; symmetric order: 4251637; postorder: 4526731.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_3" id="ch02ex_2_7_3a">3</a>.</strong> The statement is true; notice, for example, that nodes 4, 5, 6, 7 always appear in this order in <a href="../Text/app01b.html#ch02ex_2_7_2a">exercise 2</a>. The result is immediately proved by induction on the size of the binary tree.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_4" id="ch02ex_2_7_4a">4</a>.</strong> It is the reverse of postorder. (This is easily proved by induction.)</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_5" id="ch02ex_2_7_5a">5</a>.</strong> In the tree of <a href="../Text/app01b.html#ch02ex_2_7_2a">exercise 2</a>, for example, preorder is 1, 10, 100, 101, 11, 110, 111, using binary notation (which is in this case equivalent to the Dewey system). The strings of digits have been sorted, like words in a dictionary.</p>

  <p class="indent">In general, the nodes will be listed in preorder if they are sorted lexicographically from left to right, with ${\rm “blank”}\lt 0\lt 1$. The nodes will be listed in postorder if they are sorted lexicographically with $0\lt 1\lt\rm “blank”$. For inorder, use $0\lt\mathrm{“blank”}\lt 1$.</p>

  <p class="indent">(Moreover, if we imagine the blanks at the left and treat the Dewey labels as ordinary binary numbers, we get <em>level order</em>; see <a href="../Text/ch02a.html#ch02lev2sec9">2.3.3</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec9-8">8</a>).)</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_6" id="ch02ex_2_7_6a">6</a>.</strong> The fact that $p_1 p_2\ldots p_n$ is obtainable with a stack is readily proved by induction on $n$, or in fact we may observe that <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> does precisely what is required in its stack actions. (The corresponding sequence of S’s and X’s, as in <a href="../Text/ch02.html#ch02ex_2_1_3">exercise 2.2.1–3</a>, is the same as the sequence of 1s and 2s as subscripts in double order; see <a href="../Text/ch02a.html#ch02ex_2_7_18">exercise 18</a>.)</p>

  <p class="indent">Conversely, if $p_1 p_2\ldots p_n$ is obtainable with a stack and if $p_k=1$, then $p_1\ldots p_{k−1}$ is a permutation of $\{2,\ldots,k\}$ and $p_{k+1}\ldots p_n$ is a permutation of $\{k+1,\ldots,n\}$; these are the permutations corresponding to the left and right subtrees, and both are obtainable with a stack. The proof now proceeds by induction.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_7" id="ch02ex_2_7_7a">7</a>.</strong> From the preorder, the root is known; then from the inorder, we know the left subtree and the right subtree; and in fact we know the preorder and inorder of the nodes in the latter subtrees. Hence the tree is readily constructed (and indeed it is quite amusing to construct a simple algorithm that links the tree together in the normal fashion, starting with the nodes linked together in preorder in $\tt LLINK$ and in inorder in $\tt RLINK$). Similarly, postorder and inorder together characterize the structure. But preorder and postorder do not; there are two binary trees having $AB$ as preorder and $BA$ as postorder. If all nonterminal nodes of a binary tree have <em>both</em> branches nonempty, its structure <em>is</em> characterized by preorder and postorder.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_8" id="ch02ex_2_7_8a">8</a>.</strong> (a) Binary trees with all $\tt LLINK\rm s$ null. (b) Binary trees with zero or one nodes. (c) Binary trees with all $\tt RLINK\rm s$ null.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_7_9" id="ch02ex_2_7_9a">9</a>.</strong> $\tt T1$ once, ${\tt T2}\;2n\!+\!1$ times, ${\tt T3}\;n$ times, ${\tt T4}\;n\!+\!1$ times, ${\tt T5}\;n$ times. These counts can be derived by induction or by Kirchhoff’s law, or by examining <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_10" id="ch02ex_2_7_10a">10</a>.</strong> A binary tree with all $\tt RLINK\rm s$ null will cause all $n$ node addresses to be put in the stack before any are removed.</p>

  <p class="exercises1" id="page_565"><strong><a href="../Text/ch02a.html#ch02ex_2_7_11" id="ch02ex_2_7_11a">11</a>.</strong> Let $a_{nk}$ be the number of binary trees with $n$ nodes for which the stack in <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> never contains more than $k$ items. If $g_k(z)=\sum_n a_{nk}z^n$, we find $g_1(z)=1/(1−z)$, $g_2(z)=1/(1−z/(1−z))=(1−z)/(1−2z),\ldots,g_k(z)=1/(1−zg_{k−1}(z))=q_{k−1}(z)/q_k(z)$ where $q_{−1}(z)=q_0(z)=1, q_{k+1}(z)=q_k(z)−zq_{k−1}(z)$; hence $g_k(z)=(f_1(z)^{k+1}−f_2(z)^{k+1})/(f_1(z)^{k+2}−f_2(z)^{k+2})$ where $f_j(z)=\frac12{\left(1\pm\sqrt{1−4z}\right)}$. It can now be shown that $a_{nk}=[u^n](1−u)(1+u)^{2n}(1−u^{k+1})/(1−u^{k+2})$; hence $s_n=\sum_{k\ge 1}k(a_{nk}−a_{n(k−1)})$ is $[u^{n+1}](1−u)^2(1+u)^{2n}\sum_{j\ge 1}u^j/(1−u^j)$, minus $a_{nn}$. The technique of exercise 5.2.2–52 now yields the asymptotic series</p>

  <div class="image">$$s_n/a_{nn}=\sqrt{\pi n}−\frac32 −\frac{13}{24}\sqrt{\frac{\pi}{n}}+\frac{1}{2n}+O\left(n^{−3/2}\right)$$</div>

  <p>[N. G. de Bruijn, D. E. Knuth, and S. O. Rice, in <em>Graph Theory and Computing</em>, ed. by R. C. Read (New York: Academic Press, 1972), 15–22.]</p>

  <p class="indent">When the binary tree represents a forest as described in <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>, the quantity analyzed here is the <em>height</em> of that forest (the furthest distance between a node and a root, plus one). Generalizations to many other varieties of trees have been obtained by Flajolet and Odlyzko [<em>j. Computer and System Sci.</em> <strong>25</strong> (1982), 171–213]; the asymptotic distribution of heights, both near the mean and far away, was subsequently analyzed by Flajolet, Gao, Odlyzko, and Richmond [<em>Combinatorics, Probability, and Computing</em> <strong>2</strong> (1993), 145–156].</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_12" id="ch02ex_2_7_12a">12</a>.</strong> Visit $\tt NODE(P)$ between steps T2 and T3, instead of in step T5. For the proof, demonstrate the validity of the statement “<em>Starting at step T2 with $\ldots$ original value</em> ${\tt A[}1{\tt]}\ldots{\tt A[}m{\tt]}$,” essentially as in the text.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_13" id="ch02ex_2_7_13a">13</a>.</strong> (Solution by S. Araújo, 1976.) Let steps T1 through T4 be unchanged, except that a new variable $\tt Q$ is initialized to $Λ$ in step T1'; $\tt Q$ will point to the last node visited, if any. Step T5 becomes two steps:</p>

  <p class="uln-indentC"><strong>T5'.</strong> [Right branch done?] If ${\tt RLINK(P)}=\varLambda$ or $\tt RLINK(P)=Q$, go on to T6; otherwise set ${\tt A}\Leftarrow\tt P$, $\tt P\gets RLINK(P)$ and return to T2'.</p>

  <p class="uln-indentC"><strong>T6'.</strong> [Visit $\tt P$.] Visit $\tt NODE(P)$, set $\tt Q\gets P$, and return to T4'.</p>

  <p>A similar proof applies. (Steps T4' and T5' can be streamlined so that nodes are not taken off the stack and immediately reinserted.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_14" id="ch02ex_2_7_14a">14</a>.</strong> By induction, there are always exactly $n+1\varLambda$ links (counting $\tt T$ when it is null). There are $n$ nonnull links, counting $\tt T$, so the remark in the text about the majority of null links is justified.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_15" id="ch02ex_2_7_15a">15</a>.</strong> There is a thread $\tt LLINK$ or $\tt RLINK$ pointing to a node if and only if it has a nonempty right or left subtree, respectively. (See <a href="../Text/ch02a.html#ch02fig24">Fig. 24</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_16" id="ch02ex_2_7_16a">16</a>.</strong> If ${\tt LTAG(Q)}=0$, ${\tt Q}*$ is $\tt LLINK(Q)$; thus ${\tt Q}*$ is one step down and to the left. Otherwise ${\tt Q}*$ is obtained by going upwards in the tree (if necessary) repeatedly until the first time it is possible to go down to the right without retracing steps; typical examples are the trips from $\tt P$ to ${\tt P}*$ and from $\tt Q$ to ${\tt Q}*$ in the following tree:</p>

  <div class="image"><img alt="Image" src="../Images/565fig01.gif" /></div>

  <p class="exercises1" id="page_566"><strong><a href="../Text/ch02a.html#ch02ex_2_7_17" id="ch02ex_2_7_17a">17</a>.</strong> If ${\tt LTAG(P)}=0$, set $\tt Q\gets LLINK(P)$ and terminate. Otherwise set $\tt Q\gets P$, then set $\tt Q\gets RLINK(Q)$ zero or more times until finding ${\tt RTAG(Q)}=0$; finally set $\tt Q\gets RLINK(Q)$ once more.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_18" id="ch02ex_2_7_18a">18</a>.</strong> Modify <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> by inserting a step T2.5, “Visit $\tt NODE(P)$ the first time”; in step T5, we are visiting $\tt NODE(P)$ the second time.</p>

  <p class="indent">Given a threaded tree the traversal is extremely simple:</p>

  <p class="uln-indent1">$({\tt P}, 1)^Δ=({\tt LLINK(P)}, 1)$ if ${\tt LTAG(P)}=0$, otherwise $({\tt P}, 2)$;</p>

  <p class="uln-indent1">$({\tt P}, 2)^Δ=({\tt RLINK(P)}, 1)$ if ${\tt RTAG(P)}=0$, otherwise $({\tt RLINK(P)}, 2)$.</p>

  <p>In each case, we move at most one step in the tree; in practice, therefore, double order and the values of $d$ and $e$ are embedded in a program and not explicitly mentioned.</p>

  <p class="indent">Suppressing all the first visits gives us precisely <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithms T</a> and <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">S</a>; suppressing all the second visits gives us the solutions to <a href="../Text/ch02a.html#ch02ex_2_7_12">exercises 12</a> and <a href="../Text/ch02a.html#ch02ex_2_7_17">17</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_19" id="ch02ex_2_7_19a">19</a>.</strong> The basic idea is to start by finding the parent $\tt Q$ of $\tt P$. Then if $\tt P\neq LLINK(Q)$ we have ${\tt P\#}=\tt Q$; otherwise we can find $\tt P\#$ by repeatedly setting $\tt Q\gets Q\$$ zero or more times until ${\tt RTAG(Q)}=1$. (See, for example, $\tt P$ and $\tt P\#$ in the tree shown.)</p>

  <div class="image"><img alt="Image" src="../Images/566fig01.gif" /></div>

  <p class="indent">There is no efficient algorithm to find the parent of $\tt P$ in a general right-threaded tree, since a degenerate right-threaded tree in which all left links are null is essentially a circular list in which the links go the wrong way. Therefore we cannot traverse a right-threaded tree in postorder with the same efficiency as the stack method of <a href="../Text/ch02a.html#ch02ex_2_7_13">exercise 13</a>, if we keep no history of how we have reached the current node $\tt P$.</p>

  <p class="indent">But if the tree is threaded in both directions, we <em>can</em> find $\tt P\rm\unicode{39}s$ parent efficiently:</p>

  <p class="uln-indentC"><strong>F1.</strong> Set $\tt Q\gets P$ and $\tt R\gets P$.</p>

  <p class="uln-indentC"><strong>F2.</strong> If ${\tt LTAG(Q)=RTAG(R)}=0$, set $\tt Q\gets LLINK(Q)$ and $\tt R\gets RLINK(R)$ and repeat this step. Otherwise go to F4 if ${\tt RTAG(R)}=1$.</p>

  <p class="uln-indentC"><strong>F3.</strong> Set $\tt Q\gets LLINK(Q)$, and terminate if $\tt P=RLINK(Q)$. Otherwise set $\tt R\gets RLINK(R)$ zero or more times until ${\tt RTAG(R)}=1$, then set $\tt Q\gets RLINK(R)$ and terminate.</p>

  <p class="uln-indentC"><strong>F4.</strong> Set $\tt R\gets RLINK(R)$, and terminate with $\tt Q\gets R$ if $\tt P=LLINK(R)$. Otherwise set $\tt Q\gets LLINK(Q)$ zero or more times until ${\tt LTAG(Q)}=1$, then set $\tt Q\gets LLINK(Q)$ and terminate. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>The average running time of <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> is $O(1)$ when $\tt P$ is a random node of the tree. For if we count only the steps $\tt Q\gets LLINK(Q)$ when $\tt P$ is a right child, or only the steps $\tt R\gets RLINK(R)$ when $\tt P$ is a left child, each link is traversed for exactly one node $\tt P$.</p>

  <p class="exercises1" id="page_567"><strong><a href="../Text/ch02a.html#ch02ex_2_7_20" id="ch02ex_2_7_20a">20</a>.</strong></p>

  <div class="image"><img alt="Image" src="../Images/567pro01.gif" /></div>

  <p>If two more lines of code are added at line 06</p>

  <div class="image"><img alt="Image" src="../Images/567pro02.gif" /></div>

  <p>with appropriate changes in lines 10 and 11, the running time goes down from $(30n+a+4)u$ to $(27a+6n−22)u$. (This same device would reduce the running time of <a href="../Text/ch02a.html#ch02a_pro_t">Program T</a> to $(12a+6n−7)u$, which is a slight improvement, if we set $a=(n+1)/2.)$</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_21" id="ch02ex_2_7_21a">21</a>.</strong> The following solution by Joseph M. Morris [<em>Inf. Proc. Letters</em> <strong>9</strong> (1979), 197–200] traverses also in preorder (see <a href="../Text/ch02a.html#ch02ex_2_7_18">exercise 18</a>).</p>

  <p class="uln-indentC"><strong>U1.</strong> [Initialize.] Set $\tt P\gets T$ and ${\tt R}\gets\varLambda$.</p>

  <p class="uln-indentC"><strong>U2.</strong> [Done?] If ${\tt P}=\varLambda$, the algorithm terminates.</p>

  <p class="uln-indentC"><strong>U3.</strong> [Look left.] Set $\tt Q\gets LLINK(P)$. If ${\tt Q}=\varLambda$, visit $\tt NODE(P)$ in preorder and go to U6.</p>

  <p class="uln-indentC"><strong>U4.</strong> [Search for thread.] Set $\tt Q\gets RLINK(Q)$ zero or more times until either $\tt Q=R$ or ${\tt RLINK(Q)}=\varLambda$.</p>

  <p class="uln-indentC"><strong>U5.</strong> [Insert or remove thread.] If $\tt Q\neq R$, set $\tt RLINK(Q)\gets P$ and go to U8. Otherwise set ${\tt RLINK(Q)}\gets\varLambda$ (it had been changed temporarily to $\tt P$, but we’ve now traversed $\tt P\rm\unicode{39}s$ left subtree).</p>

  <p class="uln-indentC"><strong>U6.</strong> [Inorder visit.] Visit $\tt NODE(P)$ in inorder.</p>

  <p class="uln-indentC"><strong>U7.</strong> [Go to right or up.] Set $\tt R\gets P$, $\tt P\gets RLINK(P)$, and return to U2.</p>

  <p class="uln-indentC"><strong>U8.</strong> [Preorder visit.] Visit $\tt NODE(P)$ in preorder.</p>

  <p class="uln-indentC"><strong>U9.</strong> [Go to left.] Set $\tt P\gets LLINK(P)$ and return to step U3. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>Morris also suggested a slightly more complicated way to traverse in postorder.</p>

  <p class="indent">A completely different solution was found by J. M. Robson [<em>Inf. Proc. Letters</em> <strong>2</strong> (1973), 12–14]. Let’s say that a node is “full” if its $\tt LLINK$ and $\tt RLINK$ are nonnull, “empty” if its $\tt LLINK$ and $\tt RLINK$ are both empty. Robson found a way to maintain a stack of pointers to the full nodes whose right subtrees are being visited, using the link fields in empty nodes!</p>

  <p class="indent">Yet another way to avoid an auxiliary stack was discovered independently by G. Lindstrom and B. Dwyer, <em>Inf. Proc. Letters</em> <strong>2</strong> (1973), 47–51, 143–145. Their algorithm traverses in <em>triple order</em>—it visits every node exactly three times, once in each of preorder, inorder, and postorder—but it does not know which of the three is currently being done.</p>

  <p class="uln-indentC"><strong>W1.</strong> [Initialize.] Set $\tt P\gets T$ and $\tt Q\gets S$, where $\tt S$ is a sentinel value — any number that is known to be different from any link in the tree (e.g., $−1$).</p>

  <p class="uln-indentC"><strong>W2.</strong> [Bypass null.] If ${\tt P}=\varLambda$, set $\tt P\gets Q$ and ${\tt Q}\gets\varLambda$.</p>

  <p class="uln-indentC"><strong>W3.</strong> [Done?] If $\tt P=S$, terminate the algorithm. (We will have $\tt Q=T$ at termination.)</p>

  <p class="uln-indentC" id="page_568"><strong>W4.</strong> [Visit.] Visit $\tt NODE(P)$.</p>

  <p class="uln-indentC"><strong>W5.</strong> [Rotate.] Set $\tt R\gets LLINK(P)$, ${\tt LLINK(P)\gets RLINK(P)}$, $\tt RLINK(P)\gets Q$, $\tt Q\gets P$, $\tt P\gets R$, and return to W2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>Correctness follows from the fact that if we start at W2 with $\tt P$ pointing to the root of a binary tree $\tt T$ and $\tt Q$ pointing to $\tt X$, where $\tt X$ is not a link in that tree, the algorithm will traverse the tree in triple order and reach step W3 with $\tt P=X$ and $\tt Q=T$.</p>

  <p class="indent">If $\alpha({\tt T})=x_1 x_2\ldots x_{3n}$ is the resulting sequence of nodes in triple order, we have $\alpha({\tt T})={\tt T}\;\alpha({\tt LLINK(T)})\;{\tt T}\;\alpha({\tt RLINK(T)})\tt\;T$. Therefore, as Lindstrom observed, the three subsequences $x_1 x_4\ldots x_{3n−2}, x_2 x_5\ldots x_{3n−1}, x_3 x_6\ldots x_{3n}$ each include every tree node just once. (Since $x_{j+1}$ is either the parent or child of $x_j$, these subsequences visit the nodes in such a way that each is at most three links away from its predecessor. Section 7.2.1.6 describes a general traversal scheme called <em>prepostorder</em> that has this property not only for binary trees but for trees in general.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_22" id="ch02ex_2_7_22a">22</a>.</strong> This program uses the conventions of <a href="../Text/ch02a.html#ch02a_pro_t">Programs T</a> and <a href="../Text/ch02a.html#ch02a_pro_s">S</a>, with $\tt Q$ in r$\tt I$6 and/or r$\tt I$4. The old-fashioned $\tt MIX$ computer is not good at comparing index registers for equality, so variable $\tt R$ is omitted and the test “$\tt Q=R$” is changed to “$\tt RLINK(Q)=P$”.</p>

  <div class="image"><img alt="Image" src="../Images/e568_01.gif" /></div>

  <p>The total running time is $21n+6a−3−14b$, where $n$ is the number of nodes, $a$ is the number of null $\tt RLINK\rm{s}$ (hence $a−1$ is the number of nonnull $\tt LLINK\rm{s}$), and $b$ is the number of nodes on the tree’s “right spine” $\tt T$, $\tt RLINK(T)$, ${\tt RLINK(RLINK(T))}$, etc.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_23" id="ch02ex_2_7_23a">23</a>.</strong> Insertion to the right: ${\tt RLINKT(Q)\gets RLINKT(P)}$, $\tt RLINK(P)\gets Q$, ${\tt RTAG(P)}\gets 0$, ${\tt LLINK(Q)}\gets\varLambda$. Insertion to the left, assuming ${\tt LLINK(P)}=\varLambda$: Set $\tt LLINK(P)\gets Q$, ${\tt LLINK(Q)}\gets\varLambda$, $\tt RLINK(Q)\gets P$, ${\tt RTAG(Q)}\gets 1$. Insertion to the left, between $\tt P$ and ${\tt LLINK(P)}\neq\varLambda$: Set $\tt R\gets LLINK(P)$, $\tt LLINK(Q)\gets R$, and then set $\tt R\gets RLINK(R)$ zero or more times until ${\tt RTAG(R)}=1$; finally set $\tt RLINK(R)\gets Q$, $\tt LLINK(P)\gets Q$, $\tt RLINK(Q)\gets P$, ${\tt RTAG(Q)}\gets 1$.</p>

  <p class="indent">(A more efficient algorithm for the last case can be used if we know a node $\tt F$ such that $\tt P=LLINK(F)$ or $\tt P=RLINK(F)$; assuming the latter, for example, we could set ${\tt INFO(P)}\leftrightarrow\tt INFO(Q)$, $\tt RLINK(F)\gets Q$, $\tt LLINK(Q)\gets P$, ${\tt RLINKT(Q)\gets RLINKT(P)}$, $\tt RLINK(P)\gets Q$, ${\tt RTAG(P)}\gets 1$. This takes a fixed amount of time, but it is generally not recommended because it switches nodes around in memory.)</p>

  <p class="exercises1" id="page_569"><strong><a href="../Text/ch02a.html#ch02ex_2_7_24" id="ch02ex_2_7_24a">24</a>.</strong> No: <span class="top"><img alt="Image" src="../Images/569pro01.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_25" id="ch02ex_2_7_25a">25</a>.</strong> We first prove (b), by induction on the number of nodes in $T$, and similarly (c). Now (a) breaks into several cases; write $T\preceq_1 T'$ if (i) holds, $T\preceq_2 T'$ if (ii) holds, etc. Then $T\preceq_1 T'$ and $T'\preceq T''$ implies $T\preceq_1 T''$; $T\preceq_2 T'$ and $T'\preceq T''$ implies $T\preceq_2 T''$; and the remaining two cases are treated by proving (a) by induction on the number of nodes in $T$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_26" id="ch02ex_2_7_26a">26</a>.</strong> If the double order of $T$ is $(u_1, d_1), (u_2, d_2),\ldots,(u_{2n}, d_{2n})$ where the $u\rm\unicode{39}s$ are nodes and the $d\rm\unicode{39}s$ are 1 or 2, form the “trace” of the tree $(v_1, s_1), (v_2, s_2),\ldots,(v_{2n}, s_{2n})$, where $v_j=\operatorname{info}(u_j)$, and $s_j=l(u_j)$ or $r(u_j)$ according as $d_j=1\;\rm or\;2$. Now $T\preceq T'$ if and only if the trace of $T$ (as defined here) <em>lexicographically</em> precedes or equals the trace of $T'$. Formally, this means that we have either $n\le n'$ and $(v_j,s_j)=(v'_j,s'_j)$ for $1\le j\le 2n$, or else there is a $k$ for which $(v_j,s_j)=(v'_j,s'_j)$ for $1\le j\lt k$ and either $v_k\prec v'_k$ or $v_k=v'_k$ and $s_k\lt s'_k$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_27" id="ch02ex_2_7_27a">27</a>.</strong> <strong>R1.</strong> [Initialize.] Set $\tt P\gets HEAD$, $\tt P'\gets HEAD'$; these are the respective list heads of the given right-threaded binary trees. Go to R3.</p>

  <p class="uln-indentC"><strong>R2.</strong> [Check $\tt INFO$.] If ${\tt INFO(P)\prec INFO(P')}$, terminate $(T\prec T')$; if ${\tt INFO(P)\succ INFO(P')}$, terminate $(T\succ T')$.</p>

  <p class="uln-indentC"><strong>R3.</strong> [Go to left.] If ${\tt LLINK(P)=\varLambda=LLINK(P')}$, go to R4; if ${\tt LLINK(P)=\varLambda\neq LLINK(P')}$, terminate $(T\prec T')$; if ${\tt LLINK(P)\neq\varLambda=LLINK(P')}$, terminate $(T\succ T')$; otherwise set $\tt P\gets LLINK(P)$, ${\tt P'\gets LLINK(P')}$, and go to R2.</p>

  <p class="uln-indentC"><strong>R4.</strong> [End of tree?] If $\tt P=HEAD$ (or, equivalently, if $\tt P'=HEAD'$), terminate ($T$ is equivalent to $T'$).</p>

  <p class="uln-indentC"><strong>R5.</strong> [Go to right.] If ${\tt RTAG(P)=1=RTAG(P')}$, set $\tt P\gets RLINK(P)$, ${\tt P'\gets RLINK(P')}$, and go to R4. If ${\tt RTAG(P)=1\neq RTAG(P')}$, terminate $(T\prec T')$. If ${\tt RTAG(P)\neq 1=RTAG(P')}$, terminate $(T\succ T')$. Otherwise, set $\tt P\gets RLINK(P)$, ${\tt P'\gets RLINK(P')}$, and go to R2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="indent">To prove the validity of this algorithm (and therefore to understand how it works), one may show by induction on the size of the tree $T_0$ that the following statement is valid: <em>Starting at step R2 with $\tt P$ and $\tt P'$ pointing to the roots of two nonempty right-threaded binary trees $T_0$ and $T'_0$, the algorithm will terminate if $T_0$ and $T'_0$ are not equivalent, indicating whether $T_0\prec T'_0$ or $T_0\succ T'_0$; the algorithm will reach step R4 if $T_0$ and $T'_0$ are equivalent, with $\tt P$ and $\tt P'$ then pointing respectively to the successor nodes of $T_0$ and $T'_0$ in symmetric order.</em></p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_28" id="ch02ex_2_7_28a">28</a>.</strong> Equivalent <em>and</em> similar.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_29" id="ch02ex_2_7_29a">29</a>.</strong> Prove by induction on the size of $T$ that the following statement is valid: <em>Starting at step C2 with</em> $\tt P$ <em>pointing to the root of a nonempty binary tree $T$ and with</em> $\tt Q$ <em>pointing to a node that has empty left and right subtrees, the procedure will ultimately arrive at step C6 after setting</em> ${\tt INFO(Q)\gets INFO(P)}$ <em>and attaching copies of the left and right subtrees of</em> $\tt NODE(P)$ <em>to</em> $\tt NODE(Q)$<em>, and with</em> $\tt P$ <em>and</em> $\tt Q$ <em>pointing respectively to the preorder successor nodes of the trees $T$ and</em> $\tt NODE(Q)$.</p>

  <p class="exercises1" id="page_570"><strong><a href="../Text/ch02a.html#ch02ex_2_7_30" id="ch02ex_2_7_30a">30</a>.</strong> Assume that the pointer $\tt T$ in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) is $\tt LLINK(HEAD)$ in (<a href="../Text/ch02a.html#ch02eq-lev2sec7-10">10</a>). Thus ${\tt LOC(T)=HEAD}$, and $\tt HEAD\$$ is the first node of the binary tree in symmetric order.</p>

  <p class="uln-indentC"><strong>L1.</strong> [Initialize.] Set $\tt Q\gets HEAD$, $\tt RLINK(Q)\gets Q$.</p>

  <p class="uln-indentC"><strong>L2.</strong> [Advance.] Set $\tt P\gets Q\$$. (See below.)</p>

  <p class="uln-indentC"><strong>L3.</strong> [Thread.] If ${\tt RLINK(Q)}=\varLambda$, set $\tt RLINK(Q)\gets P$, ${\tt RTAG(Q)}\gets 1$; otherwise set ${\tt RTAG(Q)}\gets 0$. If ${\tt LLINK(P)}=\varLambda$, set $\tt LLINK(P)\gets Q$, ${\tt LTAG(P)}\gets 1$; otherwise set ${\tt LTAG(P)}\gets 0$.</p>

  <p class="uln-indentC"><strong>L4.</strong> [Done?] If $\tt P\neq HEAD$, set $\tt Q\gets P$ and return to L2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="indent">Step L2 of this algorithm implies the activation of an inorder traversal coroutine like <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a>, with the additional proviso that <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> visits $\tt HEAD$ after it has fully traversed the tree. This notation is a convenient simplification in the description of tree algorithms, since we need not repeat the stack mechanisms of <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm T</a> over and over again. Of course <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> cannot be used during step L2, since the tree hasn’t been threaded yet. But Algorithm U in <a href="../Text/app01b.html#ch02ex_2_7_21a">answer 21</a> <em>can</em> be used in step L2; it provides us with a very pretty method that threads a tree without using any auxiliary stack.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_31" id="ch02ex_2_7_31a">31</a>.</strong> <strong>X1.</strong> Set $\tt P\gets HEAD$.</p>

  <p class="uln-indentC"><strong>X2.</strong> Set $\tt Q\gets P\$$ (using, say, <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a>, modified for a right-threaded tree).</p>

  <p class="uln-indentC"><strong>X3.</strong> If $\tt P\neq HEAD$, set ${\tt AVAIL}\Leftarrow\tt P$.</p>

  <p class="uln-indentC"><strong>X4.</strong> If $\tt Q\neq HEAD$, set $\tt P\gets Q$ and go back to X2.</p>

  <p class="uln-indentC"><strong>X5.</strong> Set ${\tt LLINK(HEAD)}\gets\varLambda$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>Other solutions that decrease the length of the inner loop are clearly possible, although the order of the basic steps is somewhat critical. The stated procedure works because we never return a node to available storage until after <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm S</a> has looked at both its $\tt LLINK$ and its $\tt RLINK$; as observed in the text, each of these links is used precisely once during a complete tree traversal.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_32" id="ch02ex_2_7_32a">32</a>.</strong> ${\tt RLINK(Q)\gets RLINK(P)}$, ${\tt SUC(Q)\gets SUC(P)}$, ${\tt SUC(P)\gets RLINK(P)\gets Q}$, $\tt PRED(Q)\gets P$, ${\tt PRED(SUC(Q))\gets Q}$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_33" id="ch02ex_2_7_33a">33</a>.</strong> Inserting $\tt NODE(Q)$ just to the left and below $\tt NODE(P)$ is quite simple: Set ${\tt LLINKT(Q)\gets LLINKT(P)}$, $\tt LLINK(P)\gets Q$, ${\tt LTAG(P)}\gets 0$, ${\tt RLINK(Q)}\gets\varLambda$. Insertion to the right is considerably harder, since it essentially requires finding $*\tt Q$, which is of comparable difficulty to finding $\tt Q\#$ (see <a href="../Text/ch02a.html#ch02ex_2_7_19">exercise 19</a>); the node-moving technique discussed in <a href="../Text/ch02a.html#ch02ex_2_7_23">exercise 23</a> could perhaps be used. So general insertions are more difficult with this type of threading. But the insertions required by <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> are not as difficult as insertions are in general, and in fact the copying process is slightly faster for this kind of threading:</p>

  <p class="uln-indentC"><strong>C1.</strong> Set $\tt P\gets HEAD$, $\tt Q\gets U$, go to C4. (The assumptions and philosophy of <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> in the text are being used throughout.)</p>

  <p class="uln-indentC"><strong>C2.</strong> If ${\tt RLINK(P)}\neq\varLambda$, set ${\tt R}\Leftarrow\tt AVAIL$, ${\tt LLINK(R)\gets LLINK(Q)}$, ${\tt LTAG(R)}\gets 1$, ${\tt RLINK(R)}\gets\varLambda$, ${\tt RLINK(Q)\gets LLINK(Q)\gets R}$.</p>

  <p class="uln-indentC"><strong>C3.</strong> Set ${\tt INFO(Q)\gets INFO(P)}$.</p>

  <p class="uln-indentC"><strong>C4.</strong> If ${\tt LTAG(P)}=0$, set ${\tt R}\Leftarrow\tt AVAIL$, ${\tt LLINK(R)\gets LLINK(Q)}$, ${\tt LTAG(R)}\gets 1$, ${\tt RLINK(R)}\gets\varLambda$, $\tt LLINK(Q)\gets R$, ${\tt LTAG(Q)}\gets 0$.</p>

  <p class="uln-indentC"><strong>C5.</strong> Set $\tt P\gets LLINK(P)$, $\tt Q\gets LLINK(Q)$.</p>

  <p class="uln-indentC"><strong>C6.</strong> If $\tt P\neq HEAD$, go to C2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>The algorithm now seems almost too simple to be correct!</p>

  <p class="indent" id="page_571"><a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm C</a> for threaded or right-threaded binary trees takes slightly longer due to the extra time to calculate ${\tt P}*$, ${\tt Q}*$ in step C5.</p>

  <p class="indent">It would be possible to thread $\tt RLINK\rm s$ in the usual way or to put $\#\tt P$ in $\tt RLINK(P)$, in conjunction with this copying method, by appropriately setting the values of $\tt RLINK(R)$ and $\tt RLINKT(Q)$ in steps C2 and C4.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_34" id="ch02ex_2_7_34a">34</a>.</strong> <strong>A1.</strong> Set $\tt Q\gets P$, and then repeatedly set $\tt Q\gets RLINK(Q)$ zero or more times until ${\tt RTAG(Q)}=1$.</p>

  <p class="uln-indentC"><strong>A2.</strong> Set $\tt R\gets RLINK(Q)$. If $\tt LLINK(R)=P$, set ${\tt LLINK(R)}\gets\varLambda$. Otherwise set $\tt R\gets LLINK(R)$, then repeatedly set $\tt R\gets RLINK(R)$ zero or more times until $\tt RLINK(R)=P$; then finally set ${\tt RLINKT(R)\gets RLINKT(Q)}$. (This step has removed $\tt NODE(P)$ and its subtrees from the original tree.)</p>

  <p class="uln-indentC"><strong>A3.</strong> Set ${\tt RLINK(Q)\gets HEAD}$, ${\tt LLINK(HEAD)\gets P}$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>(The key to inventing and/or understanding this algorithm is the construction of good “before and after” diagrams.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_36" id="ch02ex_2_7_36a">36</a>.</strong> No; see the answer to <a href="../Text/ch01.html#ch01ex_2_1_15">exercise 1.2.1–15</a>(e).</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_7_37" id="ch02ex_2_7_37a">37</a>.</strong> If ${\tt LLINK(P)=RLINK(P)}=\varLambda$ in the representation (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>), let ${\tt LINK(P)}=\varLambda$; otherwise let $\tt LINK(P)=Q$ where $\tt NODE(Q)$ corresponds to ${\tt NODE(LLINK(P))}$ and $\tt NODE(Q+1)$ to ${\tt NODE(RLINK(P))}$. The condition $\tt LLINK(P)$ or ${\tt RLINK(P)}=\varLambda$ is represented by a sentinel in $\tt NODE(Q)$ or $\tt NODE(Q+1)$ respectively. This representation uses between $n$ and $2n−1$ memory positions; under the stated assumptions, (<a href="../Text/ch02a.html#ch02eq-lev2sec7-2">2</a>) would require 18 words of memory, compared to 11 in the present scheme. Insertion and deletion operations are approximately of equal efficiency in either representation. But this representation is not quite as versatile in combination with other structures.</p>

  <div class="heading">
    <h4 id="app01lev2sec24">Section 2.3.2</h4>

    <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_1" id="ch02ex_2_8_1a">1</a>.</strong> If $B$ is empty, $F(B)$ is an empty forest. Otherwise, $F(B)$ consists of a tree $T$ plus the forest $F(right(B))$, where $\operatorname{root}(T)=\operatorname{root}(B)$ and $subtrees(T)=F(left(B))$.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_2" id="ch02ex_2_8_2a">2</a>.</strong> The number of zeros in the binary notation is the number of decimal points in the decimal notation; the exact formula for the correspondence is</p>

  <p class="center">$a_1.a_2.\cdots.a_k\leftrightarrow 1^{a_1}01^{a_2−1}0\ldots01^{a_k−1}$,</p>

  <p>where $1^a$ denotes $a$ ones in a row.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_3" id="ch02ex_2_8_3a">3</a>.</strong> Sort the Dewey decimal notations for the nodes lexicographically (from left to right, as in a dictionary), placing a shorter sequence $a_1.\cdots.a_k$ in front of its extensions $a_1.\cdots.a_k.\cdots.a_r$ for preorder, and behind its extensions for postorder. Thus, if we were sorting words instead of sequences of numbers, we would place the words <em>cat</em>, <em>cataract</em> in the usual dictionary order, to get preorder; we would reverse the order of initial subwords $(cataract, cat)$, to get postorder. These rules are readily proved by induction on the size of the tree.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_4" id="ch02ex_2_8_4a">4</a>.</strong> True, by induction on the number of nodes.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_5" id="ch02ex_2_8_5a">5</a>.</strong> (a) Inorder. (b) Postorder. It is interesting to formulate rigorous induction proofs of the equivalence of these traversal algorithms.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_6" id="ch02ex_2_8_6a">6</a>.</strong> We have $\operatorname{preorder}(T)=\operatorname{preorder}(T')$, and $\operatorname{postorder}(T)=\operatorname{inorder}(T')$, even if $T$ has nodes with only one child. The remaining two orders are not in any simple relation; for example, the root of $T$ comes at the end in one case and about in the middle in the other.</p>

  <p class="exercises" id="page_572"><strong><a href="../Text/ch02a.html#ch02ex_2_8_7" id="ch02ex_2_8_7a">7</a>.</strong> (a) Yes; (b) no; (c) no; (d) yes. Note that reverse preorder of a forest equals postorder of the left-right reversed forest (in the sense of mirror reflection).</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_8" id="ch02ex_2_8_8a">8</a>.</strong> <span class="middle"><img alt="Image" src="../Images/e569_08.gif" /></span> means that either $\operatorname{info}(\operatorname{root}(T))\prec\operatorname{info}(\operatorname{root}(T'))$, or these info’s are equal and the following condition holds: Suppose the subtrees of $\operatorname{root}(T)$ are $T_1,\ldots,T_n$ and the subtrees of $\operatorname{root}(T')$ are <span class="middle"><img alt="Image" src="../Images/e572_02.gif" /></span>, and let $k\ge 0$ be as large as possible such that $T_j$ is equivalent to <span class="middle"><img alt="Image" src="../Images/e572_03.gif" /></span> for $1\le j\le k$. Then either $k=n$ or $k\lt n$ and <span class="middle"><img alt="Image" src="../Images/e572_04.gif" /></span>.</p>

  <p class="exercises"><strong><a href="../Text/ch02a.html#ch02ex_2_8_9" id="ch02ex_2_8_9a">9</a>.</strong> The number of nonterminal nodes is one less than the number of right links that are $\varLambda$, in a nonempty forest, because the null right links correspond to the rightmost child of each nonterminal node, and also to the root of the rightmost tree in the forest. (This fact gives another proof of <a href="../Text/ch02a.html#ch02ex_2_7_14">exercise 2.3.1–14</a>, since the number of null left links is obviously equal to the number of <em>terminal</em> nodes.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_10" id="ch02ex_2_8_10a">10</a>.</strong> The forests are similar if and only if $n=n'$ and <span class="middle"><img alt="Image" src="../Images/e572_05.gif" /></span>, for $1\le j\le n$; they are equivalent if and only if in addition $\operatorname{info}(u_j)=\operatorname{info}(u'_j)$, $1\le j\le n$. The proof is similar to the previous proof, by generalizing <a href="../Text/ch02a.html#ch02aLemma-p">Lemma 2.3.1P</a>; let $f(u)=d(u)−1$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_11" id="ch02ex_2_8_11a">11</a>.</strong><span class="top"><img alt="Image" src="../Images/572fig01.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_12" id="ch02ex_2_8_12a">12</a>.</strong> If ${\tt INFO(Q1)}\neq 0$: Set $\tt R\gets COPY(P1)$; then if ${\tt TYPE(P2)}=0$ and ${\tt INFO(P2)}\neq 2$, set ${\tt R\gets TREE(“\uparrow”,R,TREE(INFO(P2)−1))}$; if ${\tt TYPE(P2)}\neq 0$, set ${\tt R\gets TREE(“\uparrow”,R,TREE(“−”,COPY(P2),TREE(1)))}$; then set ${\tt Q1\gets MULT(Q1,MULT(COPY(P2),R))}$.</p>

  <p class="indent">If ${\tt INFO(Q)}\neq 0$: Set ${\tt Q\gets TREE(}“×”{\tt,MULT(TREE(}“ln”{\tt,COPY(P1)),Q),TREE(}“\uparrow”{\tt,COPY(P1),COPY(P2)))}$.</p>

  <p class="indent">Finally go to ${\tt DIFF[}4{\tt]}$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_13" id="ch02ex_2_8_13a">13</a>.</strong> The following program implements <a href="../Text/ch02a.html#ch02alg-lev2sec7-C">Algorithm 2.3.1C</a> with $\rm rI1\equiv\tt P$, $\rm rI2\equiv\tt Q$, $\rm rI3\equiv\tt R$, and with appropriate changes to the initialization and termination conditions:</p>

  <div class="image"><img alt="Image" src="../Images/572pro01.gif" /></div>

  <div class="image"><img alt="Image" src="../Images/572pro01a.gif" /></div>

  <p class="exercises1" id="page_573"><strong><a href="../Text/ch02a.html#ch02ex_2_8_14" id="ch02ex_2_8_14a">14</a>.</strong> Let $a$ be the number of nonterminal (operator) nodes copied. The number of executions of the various lines in the previous program is as follows: $064–\!067, 1$; $069, a$; $070–\!079, a+1$; $080–\!081, n−1$; $082–\!088, n−1−a$; $089–\!094, n$; $095, n−a$; $096–\!098, n+1$; $099–\!100, n−a$; $101–\!103, 1$. The total time is $(36n+22)u$; we use about 20% of the time to get available nodes, 40% to traverse, and 40% to copy the $\tt INFO$ and $\tt LINK$ information.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_15" id="ch02ex_2_8_15a">15</a>.</strong> Comments are left to the reader.</p>

  <div class="image"><img alt="Image" src="../Images/573pro01.gif" /></div>

  <p class="exercises1" id="page_574"><strong><a href="../Text/ch02a.html#ch02ex_2_8_16" id="ch02ex_2_8_16a">16</a>.</strong> Comments are left to the reader.</p>

  <div class="image"><img alt="Image" src="../Images/574pro01.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_17" id="ch02ex_2_8_17a">17</a>.</strong> References to early work on such problems can be found in a survey article by J. Sammet, <em>CACM</em> <strong>9</strong> (1966), 555–569.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_18" id="ch02ex_2_8_18a">18</a>.</strong> First set ${\tt LLINK[}j{\tt]\gets RLINK[}j{\tt]}\gets j$ for all $j$, so that each node is in a circular list of length 1. Then for $j=n$, $n −1,\ldots,1$ (in this order), if ${\tt PARENT[}j{\tt]}=0$ set $r\gets j$, otherwise insert the circular list starting with $j$ into the circular list starting with ${\tt PARENT[}j{\tt]}$ as follows: $k\gets {\tt PARENT[}j{\tt]}$, $l\gets {\tt RLINK[}k{\tt]}$, $i\gets {\tt LLINK[}j{\tt]}$, ${\tt LLINK[}j{\tt]}\gets k$, ${\tt RLINK[}k{\tt]}\gets j$, ${\tt LLINK[}l{\tt]}\gets i$, ${\tt RLINK[}i{\tt]}\gets l$. This works because (a) each nonroot node is always preceded by its parent or by a descendant of its parent; (b) nodes of each family appear in their parent’s list, in order of location; (c) preorder is the unique order satisfying (a) and (b).</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_20" id="ch02ex_2_8_20a">20</a>.</strong> If $u$ is an ancestor of $v$, it is immediate by induction that $u$ precedes $v$ in preorder and follows $v$ in postorder. Conversely, suppose $u$ precedes $v$ in preorder and follows $v$ in postorder; we must show that $u$ is an ancestor of $v$. This is clear if $u$ is the root of the first tree. If $u$ is another node of the first tree, $v$ must be also, since $u$ follows $v$ in postorder; so induction applies. Similarly if $u$ is not in the first tree, $v$ must not be either, since $u$ precedes $v$ in preorder. (This exercise also follows easily from the result of <a href="../Text/ch02a.html#ch02ex_2_8_3">exercise 3</a>. It gives us a quick test for ancestorhood, if we know each node’s position in preorder and postorder.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_21" id="ch02ex_2_8_21a">21</a>.</strong> If $\tt NODE(P)$ is a binary operator, pointers to its two operands are $\tt P1=LLINK(P)$ and $\tt P2=RLINK(P1)=\$P$. <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> makes use of the fact that $\tt P2\$$, so that $\tt RLINK(P1)$ may be changed to $\tt Q1$, a pointer to the derivative of $\tt NODE(P1)$; then $\tt RLINK(P1)$ is reset later in step D3. For ternary operations, we would have, say, $\tt P1=LLINK(P)$, $\tt P2=RLINK(P1)$, $\tt P3=RLINK(P2)=\$P$, so it is difficult to generalize the binary trick. After computing the derivative $\tt Q1$, we could set $\tt RLINK(P1)\gets Q1$ temporarily, and then after computing the next derivative $\tt Q2$ we could set $\tt RLINK(Q2)\gets Q1$ and $\tt RLINK(P2)\gets Q2$ and reset $\tt RLINK(P1)\gets P2$. But this is certainly inelegant, and it becomes progressively more so as the degree of the operator becomes higher. Therefore the device of temporarily changing $\tt RLINK(P1)$ in <a href="../Text/ch02a.html#ch02alg-lev2sec8-D">Algorithm D</a> is definitely a <em>trick</em>, <a id="page_575"></a>not a <em>technique</em>. A more aesthetic way to control a differentiation process, because it generalizes to operators of higher degree and does not rely on isolated tricks, can be based on <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm 2.3.3F</a>; see <a href="../Text/ch02b.html#ch02ex_2_9_1">exercise 2.3.3–3</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02a.html#ch02ex_2_8_22" id="ch02ex_2_8_22a">22</a>.</strong> From the definition it follows immediately that the relation is transitive; that is, if $T\subseteq T'$ and $T'\subseteq T''$ then $T\subseteq T''$. (In fact the relation is easily seen to be a partial ordering.) If we let $f$ be the function taking nodes into themselves, clearly $l(T)\subseteq T$ and $r(T)\subseteq T$. Therefore if $T\subseteq l(T')$ or $T\subseteq r(T')$ we must have $T\subseteq T'$.</p>

  <p class="indent">Suppose $f_l$ and $f_r$ are functions that respectively show $l(T)\subseteq l(T')$ and $r(T)\subseteq r(T')$. Let $f(u)=f_l(u)$ if $u$ is in $l(T)$, $f(u)=\operatorname{root}(T')$ if $u$ is $\operatorname{root}(T)$, otherwise $f(u)=f_r(u)$. Now it follows easily that $f$ shows $T\subseteq T'$; for example, if we let $r'(T)$ denote $r(T)\backslash\operatorname{root}(T)$ we have $\operatorname{preorder}(T)=\operatorname{root}(T)\operatorname{preorder}(l(T))\operatorname{preorder}(r'(T))$; $\operatorname{preorder}(T')=f(\operatorname{root}(T))\operatorname{preorder}(l(T'))\operatorname{preorder}(r'(T'))$.</p>

  <p class="indent">The converse does not hold: Consider the subtrees with roots $b$ and $b'$ in <a href="../Text/ch02a.html#ch02fig25">Fig. 25</a>.</p>

  <div class="heading">
    <h4 id="app01lev2sec25">Section 2.3.3</h4>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_1" id="ch02ex_2_9_1a">1</a>.</strong> Yes, we can reconstruct them just as (<a href="../Text/ch02.html#ch02eq-lev2sec3-3">3</a>) is deduced from (<a href="../Text/ch02.html#ch02eq-lev2sec3-4">4</a>), but interchanging $\tt LTAG$ and $\tt RTAG$, $\tt LLINK$ and $\tt RLINK$, and using a queue instead of a stack.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_2" id="ch02ex_2_9_2a">2</a>.</strong> Make the following changes in <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a>: Step F1, change to “last node of the forest in preorder.” Step F2, change “$f(x_d),\ldots,f(x_1)$” to “$f(x_1),\ldots,f(x_d)$” in two places. Step F4, “If $\tt P$ is the first node in preorder, terminate the algorithm. (Then the stack contains $f(\operatorname{root}(T_1)),\ldots,f(\operatorname{root}(T_m))$, from top to bottom, where $T_1,\ldots,T_m$ are the trees of the given forest, from left to right.) Otherwise set $\tt P$ to its predecessor in preorder (${\tt P\gets P}− c$ in the given representation), and return to F2.”</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_3" id="ch02ex_2_9_3a">3</a>.</strong> In step D1, also set ${\tt S}\gets\varLambda$. ($\tt S$ is a link variable that links to the top of the stack.) Step D2 becomes, for example, “If $\tt NODE(P)$ denotes a unary operator, set $\tt Q\gets S$, $\tt S\gets RLINK(Q)$, ${\tt P1\gets LLINK(P)}$; if it denotes a binary operator, set $\tt Q\gets S$, ${\tt Q1\gets RLINK(Q)}$, ${\tt S\gets RLINK(Q1)}$, ${\tt P1\gets LLINK(P)}$, ${\tt P2\gets RLINK(P1)}$. Then perform ${\tt DIFF[TYPE(P)]}$.” Step D3 becomes “Set $\tt RLINK(Q)\gets S$, $\tt S\gets Q$.” Step D4 becomes “Set $\tt P\gets P\$$.” The operation ${\tt LLINK(DY)\gets Q}$ may be avoided in step D5 if we assume that ${\tt S}\equiv\tt LLINK(DY)$. This technique clearly generalizes to ternary and higher-order operators.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_4" id="ch02ex_2_9_4a">4</a>.</strong> A representation like (<a href="../Text/ch02.html#ch02eq-lev2sec3-10">10</a>) takes $n−m$ $\tt LLINK\rm{s}$ and $n+(n−m)$ $\tt RLINK\rm{s}$. The difference in total number of links is $n−2m$ between the two forms of representation. Arrangement (<a href="../Text/ch02.html#ch02eq-lev2sec3-10">10</a>) is superior when the $\tt LLINK$ and $\tt INFO$ fields require about the same amount of space in a node and when $m$ is rather large, namely when the nonterminal nodes have rather large degrees.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_5" id="ch02ex_2_9_5a">5</a>.</strong> It would certainly be silly to include threaded $\tt RLINK\rm{s}$, since an $\tt RLINK$ thread just points to $\tt PARENT$ anyway. Threaded $\tt LLINK\rm{s}$ as in <a href="../Text/ch02a.html#ch02lev2sec8">2.3.2</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec8-4">4</a>) would be useful if it is necessary to move leftward in the tree, for example if we wanted to traverse a tree in reverse postorder, or in family order; but these operations are not significantly harder without threaded $\tt LLINK\rm{s}$ unless the nodes tend to have very high degrees.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_6" id="ch02ex_2_9_6a">6</a>.</strong> <strong>L1.</strong> Set $\tt P\gets FIRST$, ${\tt FIRST}\gets\varLambda$.</p>

  <p class="uln-indentC"><strong>L2.</strong> If ${\tt P}=\varLambda$, terminate. Otherwise set $\tt Q\gets RLINK(P)$.</p>

  <p class="uln-indentC"><strong>L3.</strong> If ${\tt PARENT(P)}=\varLambda$, set $\tt RLINK(P)\gets FIRST$, $\tt FIRST\gets P$; otherwise set $\tt R\gets PARENT(P)$, $\tt RLINK(P)\gets LCHILD(R)$, $\tt LCHILD(R)\gets P$.</p>

  <p class="uln-indentC"><strong>L4.</strong> Set $\tt P\gets Q$ and return to L2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises" id="page_576"><strong><a href="../Text/ch02b.html#ch02ex_2_9_7" id="ch02ex_2_9_7a">7</a>.</strong> $\{1,5\}\{2,3,4,7\}\{6,8,9\}$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_8" id="ch02ex_2_9_8a">8</a>.</strong> Perform step E3 of <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm E</a>, then test if $j=k$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_2_9_9" id="ch02ex_2_9_9a">9</a>.</strong> <span class="top"><img alt="Image" src="../Images/576pro01.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_10" id="ch02ex_2_9_10a">10</a>.</strong> One idea is to set $\tt PARENT$ of each <em>root</em> node to the negative of the number of nodes in its tree (these values being easily kept up to date); then if $|{\tt PARENT[}j{\tt]}|\gt |{\tt PARENT[}k{\tt]}|$ in step E4, the roles of $j$ and $k$ are interchanged. This technique (due to M. D. McIlroy) ensures that each operation takes $O(log n)$ steps.</p>

  <p class="indent">For still more speed, we can use the following suggestion due to Alan Tritter: In step E4, set ${\tt PARENT[}x{\tt]}\gets k$ for all values $x\neq k$ that were encountered in step E3. This makes an extra pass up the trees, but it collapses them so that future searches are faster. (See Section 7.4.1.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_11" id="ch02ex_2_9_11a">11</a>.</strong> It suffices to define the transformation that is done for each input $({\tt P}, j,{\tt Q}, k)$:</p>

  <p class="uln-indentC"><strong>T1.</strong> If ${\tt PARENT(P)}\neq\varLambda$, set $j\gets j+\tt DELTA(P)$, $\tt P\gets PARENT(P)$, and repeat this step.</p>

  <p class="uln-indentC"><strong>T2.</strong> If ${\tt PARENT(Q)}\neq\varLambda$, set $k\gets k+\tt DELTA(Q)$, $\tt Q\gets PARENT(Q)$, and repeat this step.</p>

  <p class="uln-indentC"><strong>T3.</strong> If $\tt P=Q$, check that $j=k$ (otherwise the input erroneously contains contradictory equivalences). If $\tt P\neq Q$, set ${\tt DELTA(Q)}\gets j−k$, $\tt PARENT(Q)\gets P$, ${\tt LBD(P)\gets {\rm min}(LBD(P), LBD(Q)+DELTA(Q))}$, and ${\tt UBD(P)\gets {\rm max}(UBD(P), UBD(Q)+DELTA(Q))}$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p><em>Note:</em> It is possible to allow the ${\tt ARRAY\;X[}l:u\tt]$ declarations to occur intermixed with equivalences, or to allow assignment of certain addresses of variables before others are equivalenced to them, etc., under suitable conditions that are not difficult to understand. For further development of this algorithm, see <em>CACM</em> <strong>7</strong> (1964), 301–303, 506.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_12" id="ch02ex_2_9_12a">12</a>.</strong> (a) Yes. (If this condition is not required, it would be possible to avoid the loops on $\tt S$ that appear in steps A2 and A9.) (b) Yes.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_13" id="ch02ex_2_9_13a">13</a>.</strong> The crucial fact is that the $\tt UP$ chain leading upward from $\tt P$ always mentions the same variables and the same exponents for these variables as the $\tt UP$ chain leading upward from $\tt Q$, except that the latter chain may include additional steps for variables with exponent zero. (This condition holds throughout most of the algorithm, except during the execution of steps A9 and A10.) Now we get to step A8 either from A3 or from A10, and in each case it was verified that ${\tt EXP(Q)}\neq 0$. Therefore ${\tt EXP(P)}\neq 0$, and in particular it follows that ${\tt P}\neq\varLambda$, ${\tt Q}\neq\varLambda$, ${\tt UP(P)}\neq\varLambda$, ${\tt UP(Q)}\neq\varLambda$; the result stated in the exercise now follows. Thus the proof depends on showing that the $\tt UP$ chain condition stated above is preserved by the actions of the algorithm.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_14" id="ch02ex_2_9_14a">14</a>, <a href="../Text/ch02b.html#ch02ex_2_9_15" id="ch02ex_2_9_15a">15</a>.</strong> See Martin Ward and Hussain Zedan, “Provably correct derivation of algorithms using FermaT,” <em>Formal Aspects of Computing</em> <strong>27</strong> (2015), to appear.</p>

  <p class="exercises1" id="page_577"><strong><a href="../Text/ch02b.html#ch02ex_2_9_16" id="ch02ex_2_9_16a">16</a>.</strong> We prove (by induction on the number of nodes in a <em>single tree $T$</em>) that if $\tt P$ is a pointer to $T$, and if the stack is initially empty, steps F2 through F4 will end with the single value $f(\operatorname{root}(T))$ on the stack. This is true for $n=1$. If $n\gt 1$, there are $0\lt d={\tt DEGREE}(\operatorname{root}(T))$ subtrees $T_1,\ldots,T_d$; by induction and the nature of a stack, and since postorder consists of $T_1,\ldots,T_d$ followed by $\operatorname{root}(T)$, the algorithm computes $f(T_1),\ldots,f(T_d)$, and then $f(\operatorname{root}(T))$, as desired. The validity of <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm F</a> for forests follows.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_17" id="ch02ex_2_9_17a">17</a>.</strong> <strong>G1.</strong> Set the stack empty, and let $\tt P$ point to the root of the tree (the last node in postorder). Evaluate $f({\tt NODE(P)})$.</p>

  <p class="uln-indentC"><strong>G2.</strong> Push $\tt DEGREE(P)$ copies of $f({\tt NODE(P)})$ onto the stack.</p>

  <p class="uln-indentC"><strong>G3.</strong> If $\tt P$ is the first node in postorder, terminate the algorithm. Otherwise set $\tt P$ to its predecessor in postorder (this would be simply ${\tt P\gets P}− c$ in (<a href="../Text/ch02.html#ch02eq-lev2sec3-9">9</a>)).</p>

  <p class="uln-indentC"><strong>G4.</strong> Evaluate $f({\tt NODE(P)})$ using the value at the top of the stack, which is equal to $f({\tt NODE(PARENT(P))})$. Pop this value off the stack, and return to G2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p><em>Note:</em> An algorithm analogous to this one can be based on preorder instead of postorder as in <a href="../Text/ch02b.html#ch02ex_2_9_2">exercise 2</a>. In fact, family order or level order could be used; in the latter case we would use a queue instead of a stack.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_18" id="ch02ex_2_9_18a">18</a>.</strong> The $\tt INFO1$ and $\tt RLINK$ tables, together with the suggestion for computing $\tt LTAG$ in the text, give us the equivalent of a binary tree represented in the usual manner. The idea is to traverse this tree in postorder, counting degrees as we go:</p>

  <p class="uln-indentC"><strong>P1.</strong> Let $\tt R$, $\tt D$, and $\tt I$ be stacks that are initially empty; then set ${\tt R}\Leftarrow n+1$, ${\tt D}\Leftarrow 0$, $j\gets 0$, $k\gets 0$.</p>

  <p class="uln-indentC"><strong>P2.</strong> If ${\rm top}({\tt R})\gt j+1$, go to P5. (If an $\tt LTAG$ field were present, we could have tested ${\tt LTAG[}j{\tt]}=0$ instead of ${\rm top}({\tt R})\gt j+1$.)</p>

  <p class="uln-indentC"><strong>P3.</strong> If $\tt I$ is empty, terminate the algorithm; otherwise set $i\Leftarrow\tt I$, $k\gets k+1$, ${\tt INFO2[}k{\tt]\gets INFO1[}i{\tt]}$, ${\tt DEGREE[}k{\tt]\Leftarrow D}$.</p>

  <p class="uln-indentC"><strong>P4.</strong> If ${\tt RLINK[}i{\tt]}=0$, go to P3; otherwise delete the top of $\tt R$ (which will equal ${\tt RLINK[}i{\tt]}$).</p>

  <p class="uln-indentC"><strong>P5.</strong> Set ${\rm top}({\tt D})\gets {\rm top}({\tt D})+1$, $j\gets j+1$, ${\tt I}\Leftarrow j$, ${\tt D}\Leftarrow 0$, and if ${\tt RLINK[}j{\tt]}\neq 0$ set ${\tt R}\Leftarrow{\tt RLINK[}j{\tt]}$. Go to P2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_2_9_19" id="ch02ex_2_9_19a">19</a>.</strong> (a) This property is equivalent to saying that $\tt SCOPE$ links do not cross each other.</p>

  <p class="indenthangingA">(b) The first tree of the forest contains $d_1+1$ elements, and we can proceed by induction.</p>

  <p class="indenthangingA">(c) The condition of (a) is preserved when we take minima.</p>

  <p class="indent"><em>Notes:</em> By <a href="../Text/ch02a.html#ch02ex_2_8_20">exercise 2.3.2–20</a>, it follows that $d_1 d_2\ldots d_n$ can also be interpreted in terms of inversions: If the $k\rm th$ node in postorder is the $p_k\rm th$ node in preorder, then $d_k$ is the number of elements $\gt k$ that appear to the left of $k$ in $p_1 p_2\ldots p_n$.</p>

  <p class="indent">A similar scheme, in which we list the number of descendants of each node in <em>postorder</em> of the forest, leads to sequences of numbers $c_1 c_2\ldots c_n$ characterized by the properties (i) $0\le c_k\lt k$ and (ii) $k\ge j\ge k−c_k$ implies $j−c_j\ge k−c_k$. Algorithms based on such sequences have been investigated by J. M. Pallo, <em>Comp. J.</em> <strong>29</strong> (1986), 171–175. Notice that $c_k$ is the size of the left subtree of the $k\rm th$ node in symmetric order of the corresponding binary tree. We can also interpret $d_k$ as the size of the <em>right</em> subtree of the $k\rm th$ node in symmetric order of a suitable binary tree, namely the binary tree that corresponds to the given forest by the dual method of <a href="../Text/ch02a.html#ch02ex_2_8_5">exercise 2.3.2–5</a>.</p>

  <p class="indent">The relation <span class="middle"><img alt="Image" src="../Images/e577_01.gif" /></span> for $1\le k\le n$ defines an interesting lattice ordering of forests and binary trees, first introduced in another way by D. Tamari [Thèse (Paris, 1951)]; see exercise 6.2.3–32.</p>

  <div class="heading">
    <h5 id="app01lev3sec6"><a id="page_578"></a>Section 2.3.4.1</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_1" id="ch02ex_3_1_1a">1</a>.</strong> $(B,A,C,D,B)$, $(B,A,C,D,E,B)$, $(B,D,C,A,B)$, $(B,D,E,B)$, $(B,E,D,B)$, $(B,E,D,C,A,B)$.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_2" id="ch02ex_3_1_2a">2</a>.</strong> Let $(V_0, V_1,\ldots,V_n)$ be a walk of smallest possible length from $V$ to $V'$. If now $V_j=V_k$ for some $j\lt k$, then $(V_0,\ldots,V_j, V_{k+1},\ldots,V_n)$ would be a shorter walk.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_3" id="ch02ex_3_1_3a">3</a>.</strong> (The fundamental path traverses $e_3$ and $e_4$ once, but cycle $C_2$ traverses them $− 1$ times, giving a net total of zero.) Traverse the following edges: $e_1$, $e_2$, $e_6$, $e_7$, $e_9$, $e_{10}$, $e_{11}$, $e_{12}$, $e_{14}$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_4" id="ch02ex_3_1_4a">4</a>.</strong> If not, let $G″$ be the subgraph of $G'$ obtained by deleting each edge $e_j$ for which $E_j=0$. Then $G''$ is a finite graph that has no cycles and at least one edge, so by the proof of <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a> there is at least one vertex, $V$, that is adjacent to exactly one other vertex, $V'$. Let $e_j$ be the edge joining $V$ to $V'$; then Kirchhoff’s equation (<a href="../Text/ch02b.html#ch02eq-lev3sec1-1">1</a>) at vertex $V$ is $E_j=0$, contradicting the definition of $G″$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_5" id="ch02ex_3_1_5a">5</a>.</strong> $A=1+E_8$, $B=1+E_8−E_2$, $C=1+E_8$, $D=1+E_8−E_5$, $E=1+E_{17}− E_{21}$, <span class="middle"><img alt="Image" src="../Images/e578_01.gif" /></span>, <span class="middle"><img alt="Image" src="../Images/e578_02.gif" /></span>, $H=E_{17}− E_{21}$, $J=E_{17}$, <span class="middle"><img alt="Image" src="../Images/e578_03.gif" /></span>, <span class="middle"><img alt="Image" src="../Images/e578_04.gif" /></span>, $P=E_{17}+E_{20}− E_{21}$, $Q=E_{20}$, $R=E_{17}− E_{21}$, $S=E_{25}$.<br/>
  <em>Note:</em> In this case it is also possible to solve for $E_2, E_5,\ldots,E_{25}$ in terms of $A, B,\ldots,S$; hence there are nine independent solutions, explaining why we eliminated six variables in Eq. <a href="../Text/ch01b.html#ch01lev2sec14">1.3.3</a>–(<a href="../Text/ch01b.html#ch01eq-lev3sec3-8">8</a>).</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_6" id="ch02ex_3_1_6a">6</a>.</strong> (The following solution is based on the idea that we may print out each edge that does not make a cycle with the preceding edges.) Use <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm 2.3.3E</a>, with each pair $(a_i, b_i)$ representing $a_i\equiv b_i$ in the notation of that algorithm. The only change is to print $(a_i, b_i)$ if $j\neq k$ in step E4.</p>

  <p class="indent">To show that this algorithm is valid, we must prove that (a) the algorithm prints out no edges that form a cycle, and (b) if $G$ contains at least one free subtree, the algorithm prints out $n−1$ edges. Define $j\equiv k$ if there exists a path from $V_j$ to $V_k$ or if $j=k$. This is clearly an equivalence relation, and moreover $j\equiv k$ if and only if this relation can be deduced from the equivalences $a_1\equiv b_1,\ldots,a_m\equiv b_m$. Now (a) holds because the algorithm prints out no edges that form a cycle with previously printed edges; (b) is true because ${\tt PARENT[}k{\tt]}=0$ for precisely one $k$ if all vertices are equivalent.</p>

  <p class="indent">A more efficient algorithm can, however, be based on depth-first search; see <a href="../Text/ch02c.html#ch02alg-lev2sec11-A">Algorithm 2.3.5A</a> and Section 7.4.1.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_7" id="ch02ex_3_1_7a">7</a>.</strong> Fundamental cycles: $C_0=e_0+e_1+e_4+e_9$ (fundamental path is $e_1+e_4+e_9$); $C_5=e_5+e_3+e_2$; $C_6=e_6−e_2+e_4$; $C_7=e_7−e_4−e_3$; $C_8=e_8−e_9−e_4−e_3$. Therefore we find $E_1=1$, $E_2=E_5−E_6$, $E_3=E_5−E_7−E_8$, $E_4=1+E_6−E_7−E_8$, $E_9=1−E_8$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_8" id="ch02ex_3_1_8a">8</a>.</strong> Each step in the reduction process combines two arrows $e_i$ and $e_j$ that start at the same box, and it suffices to prove that such steps can be reversed. Thus we are given the value of $e_i+e_j$ after combination, and we must assign consistent values to $e_i$ and $e_j$ before the combination. There are three essentially different situations:</p>

  <div class="image"><img alt="Image" src="../Images/e578_05.gif" /></div>

  <p id="page_579">Here $A$, $B$, and $C$ stand for vertices or supervertices, and the $\alpha\rm ’s$ and $β\rm ’s$ stand for the other given flows besides $e_i+e_j$; these flows may each be distributed among several edges, although only one is shown. In Case 1 ($ e_i$ and $e_j$ lead to the same box), we may choose $e_i$ arbitrarily, then $e_j\gets (e_i+e_j)−e_i$. In Case 2 ($ e_i$ and $e_j$ lead to different boxes), we must set $e_i\gets β' −\alpha'$, $e_j\gets β'' −\alpha''$. In Case 3 ($ e_i$ is a loop but $e_j$ is not), we must set $e_j\gets β' −\alpha'$, $e_i\gets (e_i+e_j)−e_j$. In each case we have reversed the combination step as desired.</p>

  <p class="indent">The result of this exercise essentially proves that the number of fundamental cycles in the reduced flow chart is the minimum number of vertex flows that must be measured to determine all the others. In the given example, the reduced flow chart reveals that only three vertex flows (e.g., $a$, $c$, $d$) need to be measured, while the original chart of <a href="../Text/ch02b.html#ch02ex_3_1_7">exercise 7</a> has four independent edge flows. We save one measurement every time Case 1 occurs during the reduction.</p>

  <p class="indent">A similar reduction procedure could be based on combining the arrows flowing <em>into</em> a given box, instead of those flowing out. It can be shown that this would yield the same reduced flow chart, except that the supervertices would contain different names.</p>

  <p class="indent">The construction in this exercise is based on ideas due to Armen Nahapetian and F. Stevenson. For further comments, see A. Nahapetian, <em>Acta Informatica</em> <strong>3</strong> (1973), 37–41; D. E. Knuth and F. Stevenson, <em>BIT</em> <strong>13</strong> (1973), 313–322.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_1_9" id="ch02ex_3_1_9a">9</a>.</strong> Each edge from a vertex to itself becomes a “fundamental cycle” all by itself. If there are $k+1$ edges $e, e',\ldots,e^{(k)}$ between vertices $V$ and $V'$, make $k$ fundamental cycles $e' ± e,\ldots,e^{(k)}± e$ (choosing + or − according as the edges go in the opposite or the same direction), and then proceed as if only edge $e$ were present.</p>

  <p class="indent">Actually this situation would be much simpler conceptually if we had defined a graph in such a way that multiple edges are allowed between vertices, and edges are allowed from a vertex to itself; paths and cycles would be defined in terms of edges instead of vertices. Such a definition is, in fact, made for directed graphs in <a href="../Text/ch02b.html#ch02lev3sec2">Section 2.3.4.2</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_1_10" id="ch02ex_3_1_10a">10</a>.</strong> If the terminals have all been connected together, the corresponding graph must be connected in the technical sense. A minimum number of wires will involve no cycles, so we must have a free tree. By <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a>, a free tree contains $n−1$ wires, and a graph with $n$ vertices and $n−1$ edges is a free tree if and only if it is connected.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_1_11" id="ch02ex_3_1_11a">11</a>.</strong> It is sufficient to prove that when $n\gt 1$ and $c(n−1, n)$ is the minimum of the $c(i,n)$, there exists at least one minimum cost tree in which $T_{n−1}$ is wired to $T_n$. (For, any minimum cost tree with $n\gt 1$ terminals and with $T_{n−1}$ wired to $T_n$ must also be a minimum cost tree with $n−1$ terminals if we regard $T_{n−1}$ and $T_n$ as “common,” using the convention stated in the algorithm.)</p>

  <p class="indent">To prove the statement above, suppose we have a minimum cost tree in which $T_{n−1}$ is not wired to $T_n$. If we add the wire $T_{n−1}—− T_n$ we obtain a cycle, and any of the other wires in that cycle may be removed; removing the other wire touching $T_n$ gives us another tree, whose total cost is not greater than the original, and $T_{n−1}—− T_n$ appears in that tree.</p>

  <p class="exercises1" id="page_580"><strong><a href="../Text/ch02b.html#ch02ex_3_1_12" id="ch02ex_3_1_12a">12</a>.</strong> Keep two auxiliary tables, $a(i)$ and $b(i)$, for $1\le i\lt n$, representing the fact that the cheapest connection from $T_i$ to a chosen terminal is to $T_{b(i)}$, and its cost is $a(i)$; initially $a(i)=c(i,n)$ and $b(i)=n$. Then do the following operation $n−1$ times: Find $i$ such that $a(i)=min_{1\le j\lt n}a(j)$; connect $T_i$ to $T_{b(i)}$; for $1\le j\lt n$ if $c(i,j)\lt a(j)$ set $a(j)\gets c(i,j)$ and $b(j)\gets i$; and set $a(i)\gets\infty$. Here $c(i,j)$ means $c(j,i)$ when $j\lt i$.</p>

  <p class="indent">(It is somewhat more efficient to avoid the use of ∞, keeping instead a oneway linked list of those $j$ that have not yet been chosen. With or without this straightforward improvement, the algorithm takes $O(n^2)$ operations.) See also E. W. Dijkstra, <em>Proc. Nederl. Akad. Wetensch.</em> <strong>A63</strong> (1960), 196–199; D. E. Knuth, <em>The Stanford GraphBase</em> (New York: ACM Press, 1994), 460–497. Significantly better algorithms to find a minimum-cost spanning tree are discussed in Section 7.5.4.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_1_13" id="ch02ex_3_1_13a">13</a>.</strong> If there is no path from $V_i$ to $V_j$, for some $i\neq j$, then no product of the transpositions will move $i$ to $j$. So if all permutations are generated, the graph must be connected. Conversely if it is connected, remove edges if necessary until we have a free tree. Then renumber the vertices so that $V_n$ is adjacent to only one other vertex, namely $V_{n−1}$. (See the proof of <a href="../Text/ch02b.html#ch02b_the_a">Theorem A</a>.) Now the transpositions other than $(n−1 n)$ form a free tree with $n−1$ vertices; so by induction if π is any permutation of $\{1, 2,\ldots,n\}$ that leaves $n$ fixed, π can be written as a product of those transpositions. If π moves $n$ to $j$ then $\pi(j\;\;n\!\!−\!\!1)(n\!\!−\!\!1\;\;n)=ρ$ fixes $n$; hence $\pi=ρ(n\!\!−\!\!1\;\;n)(j\;\;n\!\!−\!\!1)$ can be written as a product of the given transpositions.</p>

  <div class="heading">
    <h5 id="app01lev3sec7">Section 2.3.4.2</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_1" id="ch02ex_3_2_1a">1</a>.</strong> Let $(e_1,\ldots,e_n)$ be an oriented walk of smallest possible length from $V$ to $V'$. If now $\operatorname{init}(e_j)=\operatorname{init}(e_k)$ for $j\lt k$, $(e_1,\ldots,e_{j−1}, e_k,\ldots,e_n)$ would be a shorter walk; a similar argument applies if $\operatorname{fin}(e_j)=\operatorname{fin}(e_k)$ for $j\lt k$. Hence $(e_1,\ldots,e_n)$ is simple.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_2" id="ch02ex_3_2_2a">2</a>.</strong> Those cycles in which all signs are the same: $C_0$, $C_8$, <span class="middle"><img alt="Image" src="../Images/e580_01.gif" /></span>, $C_{17}$, <span class="middle"><img alt="Image" src="../Images/e580_02.gif" /></span>, $C_{20}$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_3" id="ch02ex_3_2_3a">3</a>.</strong> For example, use three vertices $A$, $B$, $C$, with arcs from $A$ to $B$ and $A$ to $C$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_4" id="ch02ex_3_2_4a">4</a>.</strong> If there are no oriented cycles, <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm 2.2.3T</a> topologically sorts $G$. If there is an oriented cycle, topological sorting is clearly impossible. (Depending on how this exercise is interpreted, oriented cycles of length 1 could be excluded from consideration.)</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_5" id="ch02ex_3_2_5a">5</a>.</strong> Let $k$ be the smallest integer such that $\operatorname{fin}(e_k)=\operatorname{init}(e_j)$ for some $j\le k$. Then $(e_j,\ldots,e_k)$ is an oriented cycle.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_6" id="ch02ex_3_2_6a">6</a>.</strong> False (on a technicality), just because there may be several different arcs from one vertex to another.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_7" id="ch02ex_3_2_7a">7</a>.</strong> True for finite directed graphs: If we start at any vertex $V$ and follow the only possible oriented path, we never encounter any vertex twice, so we must eventually reach the vertex $R$ (the only vertex with no successor). For infinite directed graphs the result is obviously false since we might have vertices $R$, $V_1, V_2, V_3,\ldots$ and arcs from $V_j$ to $V_{j+1}$ for $j\ge 1$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_2_9" id="ch02ex_3_2_9a">9</a>.</strong> All arcs point upward.</p>

  <div class="image"><img alt="Image" src="../Images/580fig01.gif" /></div>

  <p class="exercises1" id="page_581"><strong><a href="../Text/ch02b.html#ch02ex_3_2_10" id="ch02ex_3_2_10a">10</a>.</strong> <strong>G1.</strong> Set $k\gets P[j]$, $P[j]\gets 0$.</p>

  <p class="uln-indentC"><strong>G2.</strong> If $k=0$, stop; otherwise set $m\gets P[k]$, $P[k]\gets j$, $j\gets k$, $k\gets m$, and repeat step G2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_11" id="ch02ex_3_2_11a">11</a>.</strong> This algorithm combines <a href="../Text/ch02a.html#ch02alg-lev2sec9-E">Algorithm 2.3.3E</a> with the method of the preceding exercise, so that all oriented trees have arcs that correspond to actual arcs in the directed graph; $S[j]$ is an auxiliary table that tells whether an arc goes from $j$ to $P[j] (S[j]=+1)$ or from $P[j]$ to $j (S[j]=− 1)$. Initially $P[1]=\cdots=P[n]=0$. The following steps may be used to process each $\operatorname{arc}\;(a,b)$:</p>

  <p class="uln-indentC"><strong>C1.</strong> Set $j\gets a$, $k\gets P[j]$, $P[j]\gets 0$, $s\gets S[j]$.</p>

  <p class="uln-indentC"><strong>C2.</strong> If $k=0$, go to C3; otherwise set $m\gets P[k]$, $t\gets S[k]$, $P[k]\gets j$, $S[k]\gets −s$, $s\gets t$, $j\gets k$, $k\gets m$, and repeat step C2.</p>

  <p class="uln-indentC"><strong>C3.</strong> (Now $a$ appears as the root of its tree.) Set $j\gets b$, and then if $P[j]\neq 0$ repeatedly set $j\gets P[j]$ until $P[j]=0$.</p>

  <p class="uln-indentC"><strong>C4.</strong> If $j=a$, go to C5; otherwise set $P[a]\gets b$, $S[a]\gets+1$, print $(a,b)$ as an arc belonging to the free subtree, and terminate.</p>

  <p class="uln-indentC"><strong>C5.</strong> Print “$\tt CYCLE$” followed by “$(a,b)$”.</p>

  <p class="uln-indentC"><strong>C6.</strong> If $P[b]=0$ terminate. Otherwise if $S[b]=+1$, print “$+(b, P[b])$”, else print “$−(P[b], b)$”; set $b\gets P[b]$ and repeat step C6. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p><em>Note:</em> This algorithm will take at most $O(m log n)$ steps if we incorporate the suggestion of McIlroy in <a href="../Text/ch02b.html#ch02ex_2_9_10">answer 2.3.3–10</a>. But there is a much better solution that needs only $O(m)$ steps: Use depth-first search to construct a “palm tree,” with one fundamental cycle for each “frond” [R. E. Tarjan, <em>SICOMP</em> <strong>1</strong> (1972), 146–150].</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_12" id="ch02ex_3_2_12a">12</a>.</strong> It equals the in-degree; the out-degree of each vertex can be only 0 or 1.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_13" id="ch02ex_3_2_13a">13</a>.</strong> Define a sequence of oriented subtrees of $G$ as follows: $G_0$ is the vertex $R$ alone. $G_{k+1}$ is $G_k$, plus any vertex $V$ of $G$ that is not in $G_k$ but for which there is an arc from $V$ to $V'$ where $V'$ <em>is</em> in $G_k$, plus one such $\operatorname{arc}\;e[V]$ for each such vertex. It is immediate by induction that $G_k$ is an oriented tree for all $k\ge 0$, and that if there is an oriented path of length $k$ from $V$ to $R$ in $G$ then $V$ is in $G_k$. Therefore $G_∞$, the set of all $V$ and $e[V]$ in any of the $G_k$, is the desired oriented subtree of $G$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_14" id="ch02ex_3_2_14a">14</a>.</strong> <span class="top"><img alt="Image" src="../Images/e581_01.gif" /></span></p>

  <p>in lexicographic order; the eight possibilities come from the independent choices of which of $e_{00}$ or <span class="middle"><img alt="Image" src="../Images/e581_02.gif" /></span>, $e_{10}$ or <span class="middle"><img alt="Image" src="../Images/e581_03.gif" /></span>, $e_{20}$ or $e_{22}$, should precede the other.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_15" id="ch02ex_3_2_15a">15</a>.</strong> True for finite graphs: If it is connected and balanced and has more than one vertex, it has an Eulerian trail that touches all the vertices. (But false in general.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_16" id="ch02ex_3_2_16a">16</a>.</strong> Consider the directed graph $G$ with vertices $V_1,\ldots,V_{13}$ and with an arc from $V_j$ to $V_k$ for each $k$ in pile $j$; this graph is balanced. Winning the game is equivalent to tracing out an Eulerian trail in $G$, because the game ends when the fourth arc to $V_{13}$ is encountered (namely, when the fourth king turns up). Now if the game is won, the stated digraph is an oriented subtree by <a href="../Text/ch02b.html#ch02b_lem_E">Lemma E</a>. Conversely if the stated digraph is an oriented tree, the game is won by <a href="../Text/ch02b.html#ch02b_the_d">Theorem D</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_17" id="ch02ex_3_2_17a">17</a>.</strong> <span class="middle"><img alt="Image" src="../Images/1by13.gif" /></span>. This answer can be obtained, as the author first obtained it, by laborious enumeration of oriented trees of special types and the application of generating functions, etc., based on the methods of <a href="../Text/ch02b.html#ch02lev3sec4">Section 2.3.4.4</a>. But such a simple answer deserves <a id="page_582"></a>a simple, direct proof, and indeed there is one [see Tor B. Staver, <em>Norsk Matematisk Tidsskrift</em> <strong>28</strong> (1946), 88–89]. Define an order for turning up <em>all</em> cards of the deck, as follows: Obey the rules of the game until getting stuck, then “cheat” by turning up the first available card (find the first pile that is not empty, going clockwise from pile 1) and continue as before, until eventually all cards have been turned up. The cards <em>in the order of turning up</em> are in completely random order (since the value of a card need not be specified until after it is turned up). So the problem is just to calculate the probability that in a randomly shuffled deck the last card is a king. More generally the probability that $k$ cards are still face down when the game is over is the probability that the last king in a random shuffle is followed by $k$ cards, namely <span class="middle"><img alt="Image" src="../Images/e582_01.gif" /></span>. Hence a person playing this game without cheating will turn up an average of exactly 42.4 cards per game. <em>Note:</em> Similarly, it can be shown that the probability that the player will have to “cheat” $k$ times in the process described above is exactly given by the Stirling number <span class="middle"><img alt="Image" src="../Images/e582_02.gif" /></span>. (See Eq. <a href="../Text/ch01a.html#ch01lev2sec10">1.2.10</a>–(<a href="../Text/ch01a.html#ch01eq-lev2sec10-9">9</a>) and <a href="../Text/ch01a.html#ch01ex_2_10_7">exercise 1.2.10–7</a>; the case of a more general card deck is considered in <a href="../Text/ch01a.html#ch01ex_2_10_18">exercise 1.2.10–18</a>.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_18" id="ch02ex_3_2_18a">18</a>.</strong> (a) If there is a cycle $(V_0, V_1,\ldots,V_k)$, where necessarily $3\le k\le n$, the sum of the $k$ rows of $A$ corresponding to the $k$ edges of this cycle, with appropriate signs, is a row of zeros; so if $G$ is not a free tree the determinant of $A_0$ is zero.</p>

  <p class="indent">But if $G$ is a free tree we may regard it as an ordered tree with root $V_0$, and we can rearrange the rows and columns of $A_0$ so that columns are in preorder and so that the $kth$ row corresponds to the edge from the $kth$ vertex (column) to its parent. Then the matrix is triangular with $±1\rm\unicode{39}s$ on the diagonal, so the determinant is $±1$.</p>

  <p class="indent">(b) By the Binet–Cauchy formula (<a href="../Text/ch01.html#ch01ex_2_3_46">exercise 1.2.3–46</a>) we have</p>

  <div class="image"><img alt="Image" src="../Images/e582_03.gif" /></div>

  <p>where $A_{i_1\ldots i_n}$ represents a matrix consisting of rows $i_1,\ldots,i_n$ of $A_0$ (thus corresponding to a choice of $n$ edges of $G$). The result now follows from (a).</p>

  <p class="indent">[See S. Okada and R. Onodera, <em>Bull. Yamagata Univ.</em> <strong>2</strong> (1952), 89–117.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_19" id="ch02ex_3_2_19a">19</a>.</strong> (a) The conditions $a_{00}=0$ and $a_{jj}=1$ are just conditions (a), (b) of the definition of oriented tree. If $G$ is not an oriented tree there is an oriented cycle (by <a href="../Text/ch02b.html#ch02ex_3_2_7">exercise 7</a>), and the rows of $A_0$ corresponding to the vertices in this oriented cycle will sum to a row of zeros; hence $det A_0=0$. If $G$ is an oriented tree, assign an arbitrary order to the children of each family and regard $G$ as an ordered tree. Now permute rows and columns of $A_0$ until they correspond to preorder of the vertices. Since the same permutation has been applied to the rows as to the columns, the determinant is unchanged; and the resulting matrix is triangular with $+1$ in every diagonal position.</p>

  <p class="indent">(b) We may assume that $a_{0j}=0$ for all $j$, since no arc emanating from $V_0$ can participate in an oriented subtree. We may also assume that $a_{jj}\gt 0$ for all $j\ge 1$ since otherwise the whole $jth$ row is zero and there obviously are no oriented subtrees. Now use induction on the number of arcs: If $a_{jj}\gt 1$ let $e$ be some arc leading from $V_j$; let $B_0$ be a matrix like $A_0$ but with $\operatorname{arc}\;e$ deleted, and let $C_0$ be the matrix like $A_0$ but with all arcs <em>except e</em> that lead from $V_j$ deleted. <em>Example:</em> If <span class="middle"><img alt="Image" src="../Images/e582_04.gif" /></span>, $j=1$, and $e$ is an arc from $V_1$ to $V_0$, then <span class="middle"><img alt="Image" src="../Images/e582_05.gif" /></span>, <span class="middle"><img alt="Image" src="../Images/e582_06.gif" /></span>. In general we have $det A_0=det B_0+det C_0$, since the matrices agree in all rows except row $j$, and $A_0$ is the sum of $B_0$ and $C_0$ in that row. Moreover, the number of oriented subtrees of $G$ is the number of subtrees that do <em>not</em> use $e$ (namely, $det B_0$, by induction) plus the number that <em>do</em> use $e$ (namely, $det C_0$).</p>

  <p class="indent" id="page_583"><em>Notes:</em> The matrix $A$ is often called the <em>Laplacian</em> of the graph, by analogy with a similar concept in the theory of partial differential equations. If we delete any set $S$ of rows from the matrix $A$, and the same set of columns, the determinant of the resulting matrix is the number of oriented forests whose roots are the vertices $\{V_k\mid k\epsilon S\}$ and whose arcs belong to the given digraph. The matrix tree theorem for oriented trees was stated without proof by J. J. Sylvester in 1857 (see <a href="../Text/ch02b.html#ch02ex_3_2_28">exercise 28</a>), then forgotten for many years until it was independently rediscovered by W. T. Tutte [<em>Proc. Cambridge Phil. Soc.</em> <strong>44</strong> (1948), 463–482, §3]. The first published proof in the special case of <em>undirected</em> graphs, when the matrix $A$ is symmetric, was given by C. W. Borchardt [<em>Crelle</em> <strong>57</strong> (1860), 111–121]. Several authors have ascribed the theorem to Kirchhoff, but Kirchhoff proved a quite different (though related) result.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_20" id="ch02ex_3_2_20a">20</a>.</strong> Using <a href="../Text/ch02b.html#ch02ex_3_2_18">exercise 18</a> we find <span class="middle"><img alt="Image" src="../Images/e583_01.gif" /></span>. Or, using <a href="../Text/ch02b.html#ch02ex_3_2_19">exercise 19</a>, $B$ is the matrix $A_0$ for the directed graph $G'$ with two arcs (one in each direction) in place of each edge of $G$; each free subtree of $G$ corresponds uniquely to an oriented subtree of $G'$ with root $V_0$, since the directions of the arcs are determined by the choice of root.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_21" id="ch02ex_3_2_21a">21</a>.</strong> Construct the matrices $A$ and $A^*$ as in <a href="../Text/ch02b.html#ch02ex_3_2_19">exercise 19</a>. For the example graphs $G$ and $G^*$ in <a href="../Text/ch02b.html#ch02fig36">Figs. 36</a> and <a href="../Text/ch02b.html#ch02fig37">37</a>,</p>

  <div class="image"><img alt="Image" src="../Images/e583_02.gif" /></div>

  <p>Add the indeterminate λ to every diagonal element of $A$ and $A^*$. If $t(G)$ and $t(G^*)$ are the numbers of oriented subtrees of $G$ and $G^*$, we then have $det A=λt(G)+O(λ^2)$, $det A^*=λt(G^*)+O(λ^2)$. (The number of oriented subtrees of a balanced graph is the same for any given root, by <a href="../Text/ch02b.html#ch02ex_3_2_22">exercise 22</a>, but we do not need that fact.)</p>

  <p class="indent">If we group vertices $V_{jk}$ for equal $k$ the matrix $A^*$ can be partitioned as shown above. Let $B_{kk'}$ be the submatrix of $A^*$ consisting of the rows for $V_{jk}$ and the columns for $V_{j'k'}$, for all $j$ and $j'$ such that $V_{jk}$ and $V_{j'k'}$ are in $G^*$. By adding the $2nd,\ldots,mth$ columns of each submatrix to the first column and then subtracting the first row of each submatrix from the $2nd,\ldots,mth$ rows, the matrix $A^*$ is transformed so that</p>

  <div class="image"><img alt="Image" src="../Images/e583_03.gif" /></div>

  <p>The asterisks in the top rows of the transformed submatrices turn out to be irrelevant, because the determinant of $A^*$ is now seen to be $(λ+m)^{(m−1)n}$ times</p>

  <div class="image"><img alt="Image" src="../Images/e583_04.gif" /></div>

  <p class="indent" id="page_584">Notice that when $n=1$ and there are $m$ arcs from $V_0$ to itself, we find in particular that exactly $m^{m−1}$ oriented trees are possible on $m$ labeled nodes. This result will be obtained by quite different methods in <a href="../Text/ch02b.html#ch02lev3sec4">Section 2.3.4.4</a>.</p>

  <p class="indent">This derivation can be generalized to determine the number of oriented subtrees of $G^*$ when $G$ is an <em>arbitrary</em> directed graph; see R. Dawson and I. J. Good, <em>Ann. Math. Stat.</em> <strong>28</strong> (1957), 946–956; D. E. Knuth, <em>Journal of Combinatorial Theory</em> <strong>3</strong> (1967), 309–314. An alternative, purely combinatorial proof has been given by J. B. Orlin, <em>Journal of Combinatorial Theory</em> <strong>B25</strong> (1978), 187–198.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_22" id="ch02ex_3_2_22a">22</a>.</strong> The total number is $(σ_1+\cdots+σ_n)$ times the number of Eulerian trails starting with a given edge $e_1$, where $\operatorname{init}(e_1)=V_1$. Each such trail determines an oriented subtree with root $V_1$ by <a href="../Text/ch02b.html#ch02b_lem_E">Lemma E</a>, and for each of the $T$ oriented subtrees there are <span class="middle"><img alt="Image" src="../Images/584fig01.gif" /></span> walks satisfying the three conditions of <a href="../Text/ch02b.html#ch02b_the_d">Theorem D</a>, corresponding to the different order in which the arcs $\{e\mid\operatorname{init}(e)=V_j, e\neq e[V_j], e\neq e_1\}$ are entered into $P$. (<a href="../Text/ch02b.html#ch02ex_3_2_14">Exercise 14</a> provides a simple example.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_23" id="ch02ex_3_2_23a">23</a>.</strong> Construct the directed graph $G_k$ with $m^{k−1}$ vertices as in the hint, and denote by $[x_1,\ldots,x_k]$ the arc mentioned there. For each function that has maximum period length, we can define a unique corresponding Eulerian trail, by letting $f(x_1,\ldots,x_k)=x_{k+1}$ if $\operatorname{arc}\;[x_1,\ldots,x_k]$ is followed by $[x_2,\ldots,x_{k+1}]$. (We regard Eulerian trails as being the same if one is just a cyclic permutation of the other.) Now <span class="middle"><img alt="Image" src="../Images/e584_01.gif" /></span> in the sense of <a href="../Text/ch02b.html#ch02ex_3_2_21">exercise 21</a>, so $G_k$ has $m^{m^{k−1}− m^{k−2}}$ times as many oriented subtrees as $G_{k−1}$; by induction $G_k$ has $m^{m^{k−1}− 1}$ oriented subtrees, and $m^{m^{k−1}−k}$ with a given root. Therefore by <a href="../Text/ch02b.html#ch02ex_3_2_22">exercise 22</a> the number of functions with maximum period, namely the number of Eulerian trails of $G_k$ starting with a given arc, is $m^{−k}(m!)^{m^{k−1}}$. [For $m=2$ this result is due to C. Flye Sainte-Marie, L’<em>Intermédiaire des Mathématiciens</em> 1 (1894), 107–110.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_24" id="ch02ex_3_2_24a">24</a>.</strong> Define a new directed graph having $E_j$ copies of $e_j$, for $0\le j\le m$. This graph is balanced, hence it contains an Eulerian trail $(e_0,\ldots)$ by <a href="../Text/ch02b.html#ch02b_the_g">Theorem G</a>. The desired oriented walk comes by deleting the edge $e_0$ from this Eulerian trail.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_25" id="ch02ex_3_2_25a">25</a>.</strong> Assign an arbitrary order to all arcs in the sets $I_j=\{e\mid\operatorname{init}(e)=V_j\}$ and $F_j=\{e\mid\operatorname{fin}(e)=V_j\}$. For each $\operatorname{arc}\;e$ in $I_j$, let ${\tt ATAG}(e)=0$ and ${\tt ALINK}(e)=e'$ if $e'$ follows $e$ in the ordering of $I_j$; also let ${\tt ATAG(e)}=1$ and ${\tt ALINK}(e)=e'$ if $e$ is last in $I_j$ and $e'$ is first in $F_j$. Let ${\tt ALINK}(e)=\varLambda$ in the latter case if $F_j$ is empty. Define $\tt BLINK$ and $\tt BTAG$ by the same rules, reversing the roles of init and fin.</p>

  <p><em>Examples</em> (using alphabetic order in each set of arcs):</p>

  <div class="image"><img alt="Image" src="../Images/e584_02.gif" /></div>

  <p class="indent" id="page_585"><em>Note:</em> If in the oriented tree representation we add another arc from $H$ to itself, we get an interesting situation: Either we get the standard conventions <a href="../Text/ch02a.html#ch02lev2sec7">2.3.1</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec7-8">8</a>) with $\tt LLINK$, $\tt LTAG$, $\tt RLINK$, $\tt RTAG$ <em>interchanged</em> in the list head, or (if the new arc is placed last in the ordering) we get the standard conventions except ${\tt RTAG}=0$ in the node associated with the root of the tree.</p>

  <p class="indent">This exercise is based on an idea communicated to the author by W. C. Lynch. Can tree traversal algorithms like <a href="../Text/ch02a.html#ch02alg-lev2sec6-S">Algorithm 2.3.1S</a> be generalized to classes of digraphs that are not oriented trees, using such a representation?</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_27" id="ch02ex_3_2_27a">27</a>.</strong> Let $a_{ij}$ be the sum of $p(e)$ over all arcs $e$ from $V_i$ to $V_j$. We are to prove that $t_j=\sum_i a_{ij}t_i$ for all $j$. Since $\sum_i a_{ji}=1$, we must prove that $\sum_i a_{ji}t_j=\sum_i a_{ij}t_i$. But this is not difficult, because both sides of the equation represent the sum of all products $p(e_1)\ldots p(e_n)$ taken over subgraphs $\{e_1,\ldots,e_n\}$ of $G$ such that $\operatorname{init}(e_i)=V_i$ and such that there is a unique oriented cycle contained in $\{e_1,\ldots,e_n\}$, where this cycle includes $V_j$. Removing any arc of the cycle yields an oriented tree; the left-hand side of the equation is obtained by factoring out the arcs that leave $V_j$, while the right-hand side corresponds to those that enter $V_j$.</p>

  <p class="indent">In a sense, this exercise is a combination of <a href="../Text/ch02b.html#ch02ex_3_2_19">exercises 19</a> and <a href="../Text/ch02b.html#ch02ex_3_2_26">26</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_2_28" id="ch02ex_3_2_28a">28</a>.</strong> Every term in the expansion is $a_{1p_1}\ldots a_{mp_m}b_{1q_1}\ldots b_{nq_n}$, where $0\le p_i\le n$ for $1\le i\le m$ and $0\le q_j\le m$ for $1\le j\le n$, times some integer coefficient. Represent this product as a directed graph on the vertices $\{0,u_1,\ldots,u_m,v_1,\ldots,v_n\}$, with arcs from $u_i$ to $v_{pi}$ and from $v_j$ to $u_{qj}$, where $u_0=v_0=0$.</p>

  <p class="indent">If the digraph contains a cycle, the integer coefficient is zero. For each cycle corresponds to a factor of the form</p>

  <p class="image"><img alt="Image" src="../Images/e585_01.gif" /></p>

  <p>where the indices $(i_0, i_1,\ldots,i_{k−1})$ are distinct and so are the indices $(j_0, j_1,\ldots,j_{k−1})$. The sum of all terms containing $(*)$ as a factor is $(*)$ times the determinant obtained by setting $a_{i_l j}\gets [j=j_l]$ for $0\le j\le n$ and $b_{j_l i}\gets [i=i_{(l+1)\mod k}]$ for $0\le i\le m$, for $0\le l\lt k$, leaving the variables in the other $m+n−2k$ rows unchanged. This determinant is identically zero, because the sum of rows $i_0, i_1,\ldots,i_{k−1}$ in the top section equals the sum of rows $j_0, j_1,\ldots,j_{k−1}$ in the bottom section.</p>

  <p class="indent">On the other hand, if the directed graph contains no cycles, the integer coefficient is $+1$. This follows because each factor $a_{ip_i}$ and $b_{jq_j}$ must have come from the diagonal of the determinant: If any off-diagonal element $a_{i_0 j_0}$ is chosen in row $i_0$ of the top section, we must choose some off-diagonal $b_{j_0 i_1}$ from row $j_0$ of the bottom section, hence we must choose some off-diagonal $a_{i_1 j_1}$ from row $i_1$ of the top section, etc., forcing a cycle.</p>

  <p class="indent">Thus the coefficient is $+1$ if and only if the corresponding digraph is an oriented tree with root 0. The number of such terms (hence the number of such oriented trees) is obtained by setting each $a_{ij}$ and $b_{ji}$ to 1; for example,</p>

  <div class="image"><img alt="Image" src="../Images/e585_02.gif" /></div>

  <p>In general we obtain det<span class="middle"><img alt="Image" src="../Images/e585_03.gif" /></span>.</p>

  <p class="indent" id="page_586"><em>Notes:</em> J. J. Sylvester considered the special case $m=n$ and $a_{10}=a_{20}=\cdots=a_{m0}=0$ in <em>Quarterly J. of Pure and Applied Math.</em> <strong>1</strong> (1857), 42–56, where he conjectured (correctly) that the total number of terms is then $n^n(n+1)^{n−1}$. He also stated without proof that the $(n+1)^{n−1}$ nonzero terms present when $a_{ij}=δ_{ij}$ correspond to all connected cycle-free graphs on $\{0, 1,\ldots,n\}$. In that special case, he reduced the determinant to the form in the matrix tree theorem of <a href="../Text/ch02b.html#ch02ex_3_2_19">exercise 19</a>, e.g.,</p>

  <div class="image"><img alt="Image" src="../Images/e586_01.gif" /></div>

  <p>Cayley quoted this result in <em>Crelle</em> <strong>52</strong> (1856), 279, ascribing it to Sylvester; thus it is ironic that the theorem about the number of such graphs is often attributed to Cayley.</p>

  <p class="indent">By negating the first $m$ rows of the given determinant, then negating the first $m$ columns, we can reduce this exercise to the matrix tree theorem.</p>

  <p class="indent">[Matrices having the general form considered in this exercise are important in iterative methods for the solution of partial differential equations, and they are said to have “Property $A$.” See, for example, Louis A. Hageman and David M. Young, <em>Applied Iterative Methods</em> (Academic Press, 1981), Chapter 9.]</p>

  <div class="heading">
    <h5 id="app01lev3sec8">Section 2.3.4.3</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_1" id="ch02ex_3_3_1a">1</a>.</strong> The root is the empty sequence; arcs go from $(x_1,\ldots,x_n)$ to $(x_1,\ldots,x_{n−1})$.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_2" id="ch02ex_3_3_2a">2</a>.</strong> Take one tetrad type and rotate it $180^°$ to get another tetrad type; these two types clearly tile the plane (without further rotations), by repeating a $2×2$ pattern.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_3" id="ch02ex_3_3_3a">3</a>.</strong> Consider the set of tetrad types <span class="baseline"><img alt="Image" src="../Images/e586_02.gif" /></span> for all positive integers $j$. The right half plane can be tiled in uncountably many ways; but whatever square is placed in the center of the plane puts a finite limit on the distance it can be continued to the left.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_4" id="ch02ex_3_3_4a">4</a>.</strong> Systematically enumerate all possible ways to tile an $n×n$ block, for $n=1, 2,\ldots$, looking for toroidal solutions within these blocks. If there is no way to tile the plane, the infinity lemma tells us there is an $n$ with no $n×n$ solutions. If there <em>is</em> a way to tile the plane, the assumption tells us that there is an $n$ with an $n×n$ solution containing a rectangle that yields a toroidal solution. Hence in either case the algorithm will terminate.</p>

  <p class="indent">[But the stated assumption is false, as shown in the next exercise; and in fact there is no algorithm that will determine in a finite number of steps whether or not there exists a way to tile the plane with a given set of types. On the other hand, if such a tiling does exist, there is always a tiling that is <em>quasitoroidal</em>, in the sense that each of its $n×n$ blocks occurs at least once in every $f(n)×f(n)$ block, for some function $f$. See B. Durand, <em>Theoretical Computer Science</em> <strong>221</strong> (1999), 61–75.]</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_5" id="ch02ex_3_3_5a">5</a>.</strong> Start by noticing that we need classes <span class="middle"><img alt="Image" src="../Images/e586_03.gif" /></span> replicated in $2×2$ groups in any solution. Then, step 1: Considering just the α squares, show that the pattern <span class="middle"><img alt="Image" src="../Images/e586_04.gif" /></span> must be replicated in $2×2$ groups of α squares. Step $n\gt 1$: Determine a pattern that must appear in a cross-shaped region of height and width $2^n−1$. The middle of the crosses has the pattern <span class="middle"><img alt="Image" src="../Images/e586_05.gif" /></span> replicated throughout the plane.</p>

  <p class="indent">For example, after step 3 we will know the contents of $7×7$ blocks throughout the plane, separated by unit length strips, every eight units. The $7×7$ blocks that are of <a id="page_587"></a>class $Na$ in the center have the form</p>

  <div class="image"><img alt="Image" src="../Images/e587_01.gif" /></div>

  <p>The middle column and the middle row is the “cross” just filled in during step 3; the other four $3×3$ squares were filled in after step 2; the squares just to the right and below this $7×7$ square are part of a $15×15$ cross to be filled in at step 4.</p>

  <p class="indent">For a similar construction that leads to a set of only 35 tetrad types having nothing but nontoroidal solutions, see R. M. Robinson, <em>Inventiones Math.</em> <strong>12</strong> (1971), 177–209. Robinson also exhibits a set of <em>six</em> squarish shapes that tile the plane only nontoroidally, even when rotations and reflections are allowed. In 1974, Roger Penrose discovered a set of only <em>two</em> polygons, based on the golden ratio instead of a square grid, that tile the plane only aperiodically; this led to a set of only 16 tetrad types with only nontoroidal solutions [see B. Grünbaum and G. C. Shephard, <em>Tilings and Patterns</em> (Freeman, 1987), Chapters 10–11; Martin Gardner, <em>Penrose Tiles to Trapdoor Ciphers</em> (Freeman, 1989), <a href="../Text/ch01.html#ch01">Chapters 1</a>–<a href="../Text/ch02.html#ch02">2</a>].</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_6" id="ch02ex_3_3_6a">6</a>.</strong> Let $k$ and $m$ be fixed. Consider an oriented tree whose vertices each represent, for some $n$, one of the partitions of $\{1,\ldots,n\}$ into $k$ parts, containing no arithmetic progression of length $m$. A node that partitions $\{1,\ldots,n+1\}$ is a child of one for $\{1,\ldots,n\}$ if the two partitions agree on $\{1,\ldots,n\}$. If there were an infinite path to the root we would have a way to divide <em>all</em> integers into $k$ sets with no arithmetic progression of length $m$. Hence, by the infinity lemma and van der Waerden’s theorem, this tree is finite. (If $k=2$, $m=3$, the tree can be rapidly calculated by hand, and the least value of $N$ is 9. See <em>Studies in Pure Mathematics</em>, ed. by L. Mirsky (Academic Press, 1971), 251–260, for van der Waerden’s interesting account of how the proof of his theorem was discovered.)</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_7" id="ch02ex_3_3_7a">7</a>.</strong> The positive integers can be partitioned into two sets $S_0$ and $S_1$ such that neither set contains any infinite <em>computable</em> sequence (see exercise 3.5–32). So in particular there is no infinite arithmetic progression. <a href="../Text/ch02b.html#ch02theor-k">Theorem K</a> does not apply because there is no way to put partial solutions into a tree with finite degrees at each vertex.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_3_8" id="ch02ex_3_3_8a">8</a>.</strong> Let a “counterexample sequence” be an infinite sequence of trees that violates Kruskal’s theorem, if such sequences exist. Assume that the theorem is false; then let $T_1$ be a tree with the smallest possible number of nodes such that $T_1$ can be the first tree in a counterexample sequence; if $T_1,\ldots,T_j$ have been chosen, let $T_{j+1}$ be a tree with the smallest possible number of nodes such that $T_1,\ldots,T_j, T_{j+1}$ is the beginning of a counterexample sequence. This process defines a counterexample sequence $⟨T_n⟩$. None of these $T\rm ’s$ is just a root. Now, we look at this sequence very carefully:</p>

  <p class="indent">(a) Suppose there is a subsequence $T_{n_1}, T_{n_2},\ldots$ for which $l(T_{n_1}), l(T_{n_2}),\ldots$ is a counterexample sequence. This is impossible; otherwise $T_1,\ldots,T_{n_1 −1}, l(T_{n_1}), l(T_{n_2}),\ldots$ would be a counterexample sequence, contradicting the definition of $T_{n_1}$.</p>

  <p class="indent" id="page_588">(b) Because of (a), there are only finitely many $j$ for which $l(T_j)$ cannot be embedded in $l(T_k)$ for any $k\gt j$. Therefore by taking $n_1$ larger than any such $j$ we can find a subsequence for which $l(T_{n_1})\subseteq l(T_{n_2})\subseteq l(T_{n_3})\subseteq\cdots$.</p>

  <p class="indent">(c) Now by the result of <a href="../Text/ch02a.html#ch02ex_2_8_22">exercise 2.3.2–22</a>, $r(T_{n_j})$ cannot be embedded in $r(T_{n_k})$ for any $k\gt j$, else $T_{n_j}\subseteq T_{n_k}$. Therefore $T_1,\ldots,T_{n_1 −1}, r(T_{n_1}), r(T_{n_2}),\ldots$ is a counterexample sequence. But this contradicts the definition of $T_{n_1}$.</p>

  <p class="indent"><em>Notes:</em> Kruskal, in <em>Trans. Amer. Math. Soc.</em> <strong>95</strong> (1960), 210–225, actually proved a stronger result, using a weaker notion of embedding. His theorem does not follow directly from the infinity lemma, although the results are vaguely similar. Indeed, K<span class="baseline"><img alt="Image" src="../Images/oprime.gif" /></span>nig himself proved a special case of Kruskal’s theorem, showing that there is no infinite sequence of pairwise incomparable $n\unicode{45}\rm tuples$ of nonnegative integers, where comparability means that all components of one $n\unicode{45}\rm tuple$ are\le the corresponding components of the other [<em>Matematikai és Fizikai Lapok</em> <strong>39</strong> (1932), 27–29]. For further developments, see <em>J. Combinatorial Theory</em> <strong>A13</strong> (1972), 297–305. See also N. Dershowitz, <em>Inf. Proc. Letters</em> <strong>9</strong> (1979), 212–215, for applications to termination of algorithms.</p>

  <div class="heading">
    <h5 id="app01lev3sec9">Section 2.3.4.4</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_1" id="ch02ex_3_4_1a">1</a>.</strong> $\ln A(z)=\ln z+\sum_{k\ge1}a_k\ln\left(\frac1{1−z^k}\right)=\ln z+\sum_{k,t\ge1}\frac{a_kz^{kt}}t=\ln z+\sum_{t\ge1}\frac{A(z^t)}t$</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_2" id="ch02ex_3_4_2a">2</a>.</strong> By differentiation, and equating the coefficients of $z^n$, we obtain the identity</p>

  <div class="image"><img alt="Image" src="../Images/e588_02.gif" /></div>

  <p>Now interchange the order of summation.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_4" id="ch02ex_3_4_4a">4</a>.</strong> (a) $A(z)$ certainly converges at least for <span class="middle"><img alt="Image" src="../Images/e588_03.gif" /></span>, since $a_n$ is less than the number of <em>ordered</em> trees $b_{n−1}$. Since $A(1)$ is infinite and all coefficients are positive, there is a positive number $\alpha\le 1$ such that $A(z)$ converges for $|z|\lt\alpha$, and there is a singularity at $z=\alpha$. Let $Ψ(z)=A(z)/z$; since $Ψ(z)\gt e^{zΨ(z)}$, we see that $Ψ(z)=m$ implies $z\lt\ln m/m$, so $Ψ(z)$ is bounded and $\lim_{z\to\alpha−}Ψ(z)$ exists. Thus $\alpha\lt 1$, and by Abel’s limit theorem $a=\alpha\cdot\exp\left(a+\frac12 A(\alpha^2)+\frac13 A(\alpha^3)+\cdots\right)$.</p>

  <p class="indent">(b) $A(z^2), A(z^3),\ldots$ are analytic for <span class="middle"><img alt="Image" src="../Images/e588_05.gif" /></span>, and $\frac12 A(z^2)+\frac13 A(z^3)+\cdots$ converges uniformly in a slightly smaller disk.</p>

  <p class="indent">(c) If $∂F/∂w=a−1\neq 0$, the implicit function theorem implies that there is an analytic function $f(z)$ in a neighborhood of $(\alpha,a/\alpha)$ such that $F(z, f(z))=0$. But this implies $f(z)=A(z)/z$, contradicting the fact that $A(z)$ is singular at α.</p>

  <p class="indent">(d) Obvious.</p>

  <p class="indent">(e) $∂F/∂w=A(z)−1$ and $|A(z)|\lt A(\alpha)=1$, since the coefficients of $A(z)$ are all positive. Hence, as in (c), $A(z)$ is regular at all such points.</p>

  <p class="indent">(f) Near $(\alpha,1/\alpha)$ we have the identity $0=β(z −\alpha)+(\alpha/2)(w−1/\alpha)^2+\mathrm{higher order terms}$, where $w=A(z)/z$; so $w$ is an analytic function of <span class="middle"><img alt="Image" src="../Images/e588_07.gif" /></span> here by the implicit function theorem. Consequently there is a region $|z|\lt\alpha_1$ minus a cut $[\alpha,\alpha_1]$ in which $A(z)$ has the stated form. (The minus sign is chosen since a plus sign would make the coefficients ultimately negative.)</p>

  <p class="indent">(g) Any function of the stated form has coefficient asymptotically <span class="middle"><img alt="Image" src="../Images/e588_08.gif" /></span>.</p>

  <p>Note that</p>

  <div class="image"><img alt="Image" src="../Images/e588_09.gif" /></div>

  <p id="page_589">For further details, and asymptotic values of the number of free trees, see R. Otter, <em>Ann. Math.</em> (2) <strong>49</strong> (1948), 583–599.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_5" id="ch02ex_3_4_5a">5</a>.</strong></p>

  <div class="image"><img alt="Image" src="../Images/e589_01.gif" /></div>

  <p>Therefore</p>

  <div class="image"><img alt="Image" src="../Images/e589_02.gif" /></div>

  <p>We find $C(z)=z+z^2+2z^3+5z^4+12z^5+33z^6+90z^7+261z^8+766z^9+\cdots$. When $n\gt 1$, the number of series-parallel networks with $n$ edges is $2c_n$ [see P. A. MacMahon, <em>Proc. London Math. Soc.</em> <strong>22</strong> (1891), 330–339].</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_6" id="ch02ex_3_4_6a">6</a>.</strong> $zG(z)^2=2G(z)−2−zG(z^2)$; $G(z)=1+z+z^2+2z^3+3z^4+6z^5+11z^6+23z^7+46z^8+98z^9+\cdots$. The function $F(z)=1−zG(z)$ satisfies the simpler relation $F(z^2)=2z+F(z)^2$. [J. H. M. Wedderburn, <em>Annals of Math.</em> (2) <strong>24</strong> (1922), 121–140.]</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_7" id="ch02ex_3_4_7a">7</a>.</strong> $g_n=ca^n n ^{− 3/2}(1+O(1/n))$, where $c ≈ 0.7916031835775$, $a ≈ 2.483253536173$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_8" id="ch02ex_3_4_8a">8</a>.</strong></p>

  <div class="image"><img alt="Image" src="../Images/589fig01.gif" /></div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_4_9" id="ch02ex_3_4_9a">9</a>.</strong> If there are two centroids, by considering a path from one to the other we find that there can’t be intermediate points, so any two centroids are adjacent. A tree cannot contain three mutually adjacent vertices, so there are at most two.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_10" id="ch02ex_3_4_10a">10</a>.</strong> If $X$ and $Y$ are adjacent, let $s(X,Y)$ be the number of vertices in the $Y$ subtree of $X$. Then $s(X,Y)+s(Y,X)=n$. The argument in the text shows that if $Y$ is a centroid, $weight(X)=s(X,Y)$. Therefore if both $X$ and $Y$ are centroids, $weight(X)=weight(Y)=n/2$.</p>

  <p class="indent">In terms of this notation, the argument in the text goes on to show that if $s(X,Y)\ge s(Y,X)$, there is a centroid in the $Y$ subtree of $X$. So if two free trees with $m$ vertices are joined by an edge between $X$ and $Y$, we obtain a free tree in which $s(X,Y)=m=s(Y,X)$, and there must be two centroids (namely $X$ and $Y$).</p>

  <p class="indent">[It is a nice programming exercise to compute $s(X,Y)$ for all adjacent $X$ and $Y$ in $O(n)$ steps; from this information we can quickly find the centroid(s). An efficient algorithm for centroid location was first given by A. J. Goldman, <em>Transportation Sci.</em> <strong>5</strong> (1971), 212–221.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_11" id="ch02ex_3_4_11a">11</a>.</strong> $zT(z)^t=T(z)−1$; thus $z+T(z) ^{− t}=T(z)^{1−t}$. By Eq. <a href="../Text/ch01a.html#ch01lev2sec9">1.2.9</a>–(<a href="../Text/ch01a.html#ch01eq-lev2sec9-21">21</a>), $T(z)=\sum_n A_n(1,−t)z^n$, so the number of $t\unicode{45}\rm ary$ trees is</p>

  <div class="image"><img alt="Image" src="../Images/e589_04.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_12" id="ch02ex_3_4_12a">12</a>.</strong> Consider the directed graph that has one arc from $V_i$ to $V_j$ for all $i\neq j$. The matrix $A_0$ of <a href="../Text/ch02b.html#ch02ex_3_2_19">exercise 2.3.4.2–19</a> is a combinatorial $(n−1)×(n−1)$ matrix with $n−1$ on the diagonal and $− 1$ off the diagonal. So its determinant is</p>

  <p class="center">$(n+(n−1)(−1))n^{n−2}=n^{n−2}$,</p>

  <p>the number of oriented trees with a given root. (<a href="../Text/ch02b.html#ch02ex_3_4_20">Exercise 2.3.4.2–20</a> could also be used.)</p>

  <p class="exercises1" id="page_590"><strong><a href="../Text/ch02b.html#ch02ex_3_4_13" id="ch02ex_3_4_13a">13</a>.</strong></p>

  <div class="image"><img alt="Image" src="../Images/590fig01.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_14" id="ch02ex_3_4_14a">14</a>.</strong> True, since the root will not become a leaf until all other branches have been removed.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_15" id="ch02ex_3_4_15a">15</a>.</strong> In the canonical representation, $V_1, V_2,\ldots,V_{n−1}, f(V_{n−1})$ is a topological sort of the oriented tree considered as a directed graph, but this order would not in general be output by <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm 2.2.3T</a>. <a href="../Text/ch02.html#ch02alg-lev2sec3-T">Algorithm 2.2.3T</a> can be changed so that it determines the values of $V_1, V_2,\ldots,V_{n−1}$ if the “insert into queue” operation of step T6 is replaced by a procedure that adjusts links so that the entries of the list appear in ascending order from front to rear; then the queue becomes a priority queue.</p>

  <p class="indent">(However, a general priority queue isn’t needed to find the canonical representation; we only need to sweep through the vertices from 1 to $n$, looking for leaves, while pruning off paths from new leaves less than the sweep pointer; see the following exercise.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_16" id="ch02ex_3_4_16a">16</a>.</strong> <strong>D1.</strong> Set ${\tt C[}1{\tt]}\gets\cdots\gets {\tt C[}n{\tt]}\gets 0$, then set ${\tt C[}f(V_j){\tt]\gets C[}f(V_j){\tt]}+1$ for $1\le j\lt n$. (Thus vertex $k$ is a leaf if and only if ${\tt C[}k{\tt]}=0$.) Set $k\gets 0$ and $j\gets 1$.</p>

  <p class="uln-indentC"><strong>D2.</strong> Increase $k$ one or more times until ${\tt C[}k{\tt]}=0$, then set $l\gets k$.</p>

  <p class="uln-indentC"><strong>D3.</strong> Set ${\tt PARENT[}l{\tt]}\gets f(V_j)$, $l\gets f(V_j)$, ${\tt C[}l{\tt]\gets C[}l{\tt]}− 1$, and $j\gets j+1$.</p>

  <p class="uln-indentC"><strong>D4.</strong> If $j=n$, set ${\tt PARENT[}l{\tt]}\gets 0$ and terminate the algorithm.</p>

  <p class="uln-indentC"><strong>D5.</strong> If ${\tt C[}l{\tt]}=0$ and $l\lt k$, go to D3; otherwise go back to D2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_17" id="ch02ex_3_4_17a">17</a>.</strong> There must be exactly one cycle $x_1, x_2,\ldots,x_k$ where $f(x_j)=x_{j+1}$ and $f(x_k)=x_1$. We will enumerate all $f$ having a cycle of length $k$ such that the iterates of each $x$ ultimately come into this cycle. Define the canonical representation $f(V_1), f(V_2),\ldots,f(V_{m−k})$ as in the text; now $f(V_{m−k})$ is in the cycle, so we continue to get a “canonical representation” by writing down the rest of the cycle $f(f(V_{m−k}))$, $f(f(f(V_{m−k})))$, etc. For example, the function with $m=13$ whose graph is shown here leads to the representation 3, 1, 8, 8, 1, 12, 12, 2, 3, 4, 5, 1. We obtain a sequence of $m−1$ numbers in which the last $k$ are distinct. Conversely, from any such sequence we can reverse the construction (assuming that $k$ is known); hence there are precisely $m^{\underline{k}}m^{m−k−1}$ such functions having a $k\unicode{45}\rm cycle$. (For related results, see exercise 3.1–14. The formula $m^{m−1}Q(m)$ was first obtained by L. Katz, <em>Annals of Math. Statistics</em> <strong>26</strong> (1955), 512–517.)</p>

  <div class="image"><img alt="Image" src="../Images/590fig02.gif" /></div>

  <p class="exercises1" id="page_591"><strong><a href="../Text/ch02b.html#ch02ex_3_4_18" id="ch02ex_3_4_18a">18</a>.</strong> To reconstruct the tree from a sequence $s_1, s_2,\ldots,s_{n−1}$, begin with $s_1$ as the root and successively attach arcs to the tree that point to $s_1, s_2,\ldots$; if vertex $s_k$ has appeared earlier, leave the initial vertex of the arc leading to $s_{k−1}$ nameless, otherwise give this vertex the name $s_k$. After all $n−1$ arcs have been placed, give names to all vertices that remain nameless by using the numbers that have not yet appeared, assigning names in increasing order to nameless vertices in the order of their creation.</p>

  <p class="indent">For example, from 3, 1, 4, 1, 5, 9, 2, 6, 5 we would construct the tree shown on the right. There is no simple connection between this method and the one in the text. Several more representations are possible; see the article by E. H. Neville, <em>Proc. Cambridge Phil. Soc.</em> <strong>49</strong> (1953), 381–385.</p>

  <div class="image"><img alt="Image" src="../Images/591fig01.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_19" id="ch02ex_3_4_19a">19</a>.</strong> The canonical representation will have precisely $n−k$ different values, so we enumerate the sequences of $n−1$ numbers with this property. The answer is <span class="middle"><img alt="Image" src="../Images/e591_01.gif" /></span>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_20" id="ch02ex_3_4_20a">20</a>.</strong> Consider the canonical representation of such trees. We are asking how many terms of $(x_1+\cdots+x_n)^{n−1}$ have $k_0$ exponents zero, $k_1$ exponents one, etc. This is plainly the coefficient of such a term times the number of such terms, namely</p>

  <div class="image"><img alt="Image" src="../Images/e591_02.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_21" id="ch02ex_3_4_21a">21</a>.</strong> There are none with $2m$ vertices; if there are $n=2m+1$ vertices, the answer is obtained from <a href="../Text/ch02b.html#ch02ex_3_4_20">exercise 20</a> with $k_0=m+1, k_2=m$, namely <span class="middle"><img alt="Image" src="../Images/e591_03.gif" /></span>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_22" id="ch02ex_3_4_22a">22</a>.</strong> Exactly $n^{n−2}$; for if $X$ is a particular vertex, the free trees are in one-to-one correspondence with oriented trees having root $X$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_23" id="ch02ex_3_4_23a">23</a>.</strong> It is possible to put the labels on every unlabeled, ordered tree in $n!$ ways, and each of these labeled, ordered trees is distinct. So the total number is $n! b_{n−1}=(2n−2)!/(n−1)!$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_24" id="ch02ex_3_4_24a">24</a>.</strong> There are as many with one given root as with another, so the answer in general is 1<em>/n</em> times the answer in <a href="../Text/ch02b.html#ch02ex_3_4_23">exercise 23</a>; and in this particular case the answer is 30.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_25" id="ch02ex_3_4_25a">25</a>.</strong> For $0\le q\lt n, r(n,q)=(n−q)n^{q−1}$. (The special case $s=1$ in Eq. (<a href="../Text/ch02b.html#ch02eq-lev3sec4-24">24</a>).)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_26" id="ch02ex_3_4_26a">26</a>.</strong> $(k=7)$</p>

  <div class="image"><img alt="Image" src="../Images/591fig02.gif" /></div>

  <p class="exercises1" id="page_592"><strong><a href="../Text/ch02b.html#ch02ex_3_4_27" id="ch02ex_3_4_27a">27</a>.</strong> Given a function $g$ from $\{1, 2,\ldots,r\}$ to $\{1, 2,\ldots,q\}$ such that adding arcs from $V_k$ to $U_{g(k)}$ introduces no oriented cycles, construct a sequence $a_1,\ldots,a_r$ as follows: Call vertex $V_k$ “free” if there is no oriented path from $V_j$ to $V_k$ for any $j\neq k$. Since there are no oriented cycles, there must be at least one free vertex. Let $b_1$ be the smallest integer for which $V_{b_1}$ is free; and assuming that $b_1,\ldots,b_t$ have been chosen, let $b_{t+1}$ be the smallest integer different from $b_1,\ldots,b_t$ for which $V_{b_{t+1}}$ is free in the graph obtained by deleting the arcs from $V_{b_k}$ to $U_{g(b_k)}$ for $1\le k\le t$. This rule defines a permutation $b_1 b_2\ldots b_r$ of the integers $\{1, 2,\ldots,r\}$. Let $a_k=g(b_k)$ for $1\le k\le r$; this defines a sequence such that $1\le a_k\le q$ for $1\le k\lt r$, and $1\le a_r\le p$.</p>

  <p class="indent">Conversely if such a sequence $a_1,\ldots,a_r$ is given, call a vertex $V_k$ “free” if there is no $j$ for which $a_j\gt p$ and $f(a_j)=k$. Since $a_r\le p$ there are at most $r−1$ non-free vertices. Let $b_1$ be the smallest integer for which $V_{b_1}$ is free; and assuming that $b_1,\ldots,b_t$ have been chosen, let $b_{t+1}$ be the smallest integer different from $b_1,\ldots,b_t$ for which $V_{b_{t+1}}$ is free with respect to the sequence $a_{t+1},\ldots,a_r$. This rule defines a permutation $b_1 b_2\ldots b_r$ of the integers $\{1, 2,\ldots,r\}$. Let $g(b_k)=a_k$ for $1\le k\le r$; this defines a function such that adding arcs from $V_k$ to $U_{g(k)}$ introduces no oriented cycles.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_28" id="ch02ex_3_4_28a">28</a>.</strong> Let $f$ be any of the $n^{m−1}$ functions from $\{2,\ldots,m\}$ to $\{1, 2,\ldots,n\}$, and consider the directed graph with vertices $U_1,\ldots,U_m, V_1,\ldots,V_n$ and arcs from $U_k$ to $V_{f(k)}$ for $1\lt k\le m$. Apply <a href="../Text/ch02b.html#ch02ex_3_4_27">exercise 27</a> with $p=1$, $q=m$, $r=n$, to show that there are $m^{n−1}$ ways to add further arcs from the $V\mathrm{’s}$ to the $U\mathrm{’s}$ to obtain an oriented tree with root $U_1$. Since there is a one-to-one correspondence between the desired set of free trees and the set of oriented trees with root $U_1$, the answer is $n^{m−1}m^{n−1}$. [This construction can be extensively generalized; see D. E. Knuth, <em>Canadian J. Math.</em> <strong>20</strong> (1968), 1077–1086.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_29" id="ch02ex_3_4_29a">29</a>.</strong> If $y=x^t$, then $(tz)y=\ln y$, and we see that it is sufficient to prove the identity for $t=1$. Now if $zx=\ln x$ we know by <a href="../Text/ch02b.html#ch02ex_3_4_25">exercise 25</a> that $x^m=\sum_k E_k(m,1)z^k$ for nonnegative integers $m$. Hence</p>

  <div class="image"><img alt="Image" src="../Images/e592_01.gif" /></div>

  <p>[Exercise 4.7–22 derives considerably more general results.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_30" id="ch02ex_3_4_30a">30</a>.</strong> Each graph described defines a set $C_x\subseteq\{1,\ldots,n\}$, where $j$ is in $C_x$ if and only if there is a path from $t_j$ to $r_i$ for some $i\le x$. For a given $C_x$ each graph described is composed of two independent parts: one of the $x(x+\epsilon_1 z_1+\cdots+\epsilon_n z_n)^{\epsilon_1+\cdots+\epsilon_n−1}$ graphs on the vertices $r_i, s_{jk}, t_j$ for $i\le x$ and $j\epsilon C_x$, where $\epsilon_j=[j\epsilon C_x]$, plus one of the $y(y+(1−\epsilon_1)z_1+\cdots+(1−\epsilon_n)z_n)^{(1−\epsilon_1)+\cdots+(1−\epsilon_n)−1}$ graphs on the other vertices.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_31" id="ch02ex_3_4_31a">31</a>.</strong> $G(z)=z+G(z)^2+G(z)^3+G(z)^4+\cdots=z+G(z)^2/(1−G(z))$. Hence $G(z)=\frac14\left(1+z-\sqrt{1-6z+z^2}\right)=z+z^2+3z^3+11z^4+45z^5+\cdots$. [<em>Notes:</em> Another problem equivalent to this one was posed and solved by E. Schröder, <em>Zeitschrift für Mathematik und Physik</em> <strong>15</strong> (1870), 361–376, who determined the number of ways to insert nonoverlapping diagonals in a convex $(n+1)\unicode{45}\rm gon$. These numbers for $n\gt 1$ are just half the values obtained in <a href="../Text/ch02.html#ch02ex_2_1_11">exercise 2.2.1–11</a>, since Pratt’s grammar allows the root node of the associated parse tree to have degree one. The asymptotic value is calculated in <a href="../Text/ch02.html#ch02ex_2_1_12">exercise 2.2.1–12</a>. Curiously, the value $[z^{10}] G(z)=103049$ seems to have been calculated already by Hipparchus in the second century <small>B.C</small>., as the <a id="page_593"></a>number of “affirmative compound propositions that can be made from only ten simple propositions”; see R. P. Stanley, <em>AMM</em> <strong>104</strong> (1997), 344–350; F. Acerbi, <em>Archive for History of Exact Sciences</em> <strong>57</strong> (2003), 465–502.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_32" id="ch02ex_3_4_32a">32</a>.</strong> Zero if $n_0\neq 1+n_2+2n_3+3n_4+\cdots$ (see <a href="../Text/ch02a.html#ch02ex_1_3_21">exercise 2.3–21</a>), otherwise</p>

  <p class="center">$(n_0+n_1+\cdots+n_m−1)!/n_0! n_1!\ldots n_m!$.</p>

  <p class="indent">To prove this result we recall that an unlabeled tree with $n=n_0+n_1+\cdots+n_m$ nodes is characterized by the sequence $d_1 d_2\ldots d_n$ of the degrees of the nodes in postorder (<a href="../Text/ch02a.html#ch02lev2sec9">Section 2.3.3</a>). Furthermore such a sequence of degrees corresponds to a tree if and only if <span class="middle"><img alt="Image" src="../Images/e593_01.gif" /></span>. (This important property of Polish postfix notation is readily proved by induction; see <a href="../Text/ch02a.html#ch02alg-lev2sec9-F">Algorithm 2.3.3F</a> with $f$ a function that creates a tree, like the $\tt TREE$ function of <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>.) In particular, $d_1$ must be 0. The answer to our problem is therefore the number of sequences $d_2\ldots d_n$ with $n_j$ occurrences of $j$ for $j\gt 0$, namely the multinomial coefficient</p>

  <div class="image"><img alt="Image" src="../Images/e593_02.gif" /></div>

  <p>minus the number of such sequences $d_2\ldots d_n$ for which <span class="middle"><img alt="Image" src="../Images/e593_03.gif" /></span> for some $k\ge 2$.</p>

  <p class="indent">We may enumerate the latter sequences as follows: Let $t$ be minimal such that <span class="middle"><img alt="Image" src="../Images/e593_04.gif" /></span>; then <span class="middle"><img alt="Image" src="../Images/e593_05.gif" /></span> where $1\le s\lt d_t$, and we may form the subsequence <span class="middle"><img alt="Image" src="../Images/e593_06.gif" /></span>, which has $n_j$ occurrences of $j$ for $j\neq d_t$, $n_j−1$ occurrences of $j$ for $j=d_t$. Now <span class="middle"><img alt="Image" src="../Images/e593_07.gif" /></span> is equal to $d_t$ when $k=n$, and equal to $d_t−s$ when $k=t$; when $k\lt t$, it is</p>

  <div class="image"><img alt="Image" src="../Images/e593_08.gif" /></div>

  <p>It follows that, given $s$ and any sequence <span class="middle"><img alt="Image" src="../Images/e593_09.gif" /></span>, the construction can be reversed; hence the number of sequences $d_2\ldots d_n$ that have a given value of $d_t$ and $s$ is the multinomial coefficient</p>

  <div class="image"><img alt="Image" src="../Images/e593_10.gif" /></div>

  <p>The number of sequences $d_2\ldots d_n$ that correspond to trees is therefore obtained by summing over the possible values of $d_t$ and $s$:</p>

  <div class="image"><img alt="Image" src="../Images/e593_11.gif" /></div>

  <p>and the latter sum is 1.</p>

  <p class="indent">An even simpler proof of this result has been given by G. N. Raney (<em>Transactions of the American Math. Society</em> <strong>94</strong> (1960), 441–451). If $d_1 d_2\ldots d_n$ is any sequence with $n_j$ appearances of $j$, there is precisely one cyclic rearrangement $d_k\ldots d_n d_1\ldots d_{k−1}$ that corresponds to a tree, namely the rearrangement where $k$ is maximal such that <span class="middle"><img alt="Image" src="../Images/e593_12.gif" /></span> is minimal. [This argument in the case of binary trees was apparently first discovered by C. S. Peirce in an unpublished manuscript; see his <em>New Elements of Mathematics</em> <strong>4</strong> (The Hague: Mouton, 1976), 303–304. It was discovered in the case of $t\unicode{45}\rm ary$ trees by Dvoretzky and Motzkin, <em>Duke Math. J.</em> <strong>14</strong> (1947), 305–313.]</p>

  <p class="indent">Still another proof, by G. Bergman, inductively replaces $d_k d_{k+1}$ by $(d_k+d_{k+1}− 1)$ if $d_k\gt 0$ [<em>Algebra Universalis</em> <strong>8</strong> (1978), 129–130].</p>

  <p class="indent" id="page_594">The methods above can be generalized to show that the number of (ordered, unlabeled) forests having $f$ trees and $n_j$ nodes of degree $j$ is $(n−1)! f/n_0 ! n_1!\ldots n_m!$, provided that the condition $n_0=f+n_2+2n_3+\cdots$ is satisfied.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_4_33" id="ch02ex_3_4_33a">33</a>.</strong> Consider the number of trees with $n_1$ nodes labeled 1, $n_2$ nodes labeled 2, $\ldots$, and such that each node labeled $j$ has degree $e_j$. Let this number be $c(n_1, n_2,\ldots)$, with the specified degrees $e_1, e_2,\ldots$ regarded as fixed. The generating function <span class="middle"><img alt="Image" src="../Images/e594_01a.gif" /></span> satisfies the identity $G=z_1 G^{e_1}+\cdots+z_r G^{e_r}$, since $z_j G^{e_j}$ enumerates the trees whose root is labeled $j$. And by the result of the previous exercise,</p>

  <div class="image"><img alt="Image" src="../Images/e594_01.gif" /></div>

  <p class="indent">More generally, since $G^f$ enumerates the number of ordered forests having such labels, we have for integer $f\gt 0$</p>

  <div class="image"><img alt="Image" src="../Images/e594_02.gif" /></div>

  <p>These formulas are meaningful when $r=\infty$, and they are essentially equivalent to Lagrange’s inversion formula.</p>

  <div class="heading">
    <h5 id="app01lev3sec10">Section 2.3.4.5</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_1" id="ch02ex_3_5_1a">1</a>.</strong> There are <span class="middle"><img alt="Image" src="../Images/e594_03.gif" /></span> in all, since the nodes numbered 8, 9, 10, 11, 12 may be attached in any of eight positions below 4, 5, 6, and 7.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_2" id="ch02ex_3_5_2a">2</a>.</strong></p>

  <div class="image"><img alt="Image" src="../Images/e594_04.gif" /></div>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_3" id="ch02ex_3_5_3a">3</a>.</strong> By induction on $m$, the condition is necessary. Conversely if <span class="middle"><img alt="Image" src="../Images/e594_05.gif" /></span>, we want to construct an extended binary tree with path lengths $l_1,\ldots,l_m$. When $m=1$, we have $l_1=0$ and the construction is trivial. Otherwise we may assume that the $l\rm\unicode{39}s$ are ordered so that $l_1=l_2=\cdots=l_q\gt l_{q+1}\ge l_{q+2}\ge\cdots\ge l_m\gt 0$ for some $q$ with $1\le q\le m$. Now <span class="middle"><img alt="Image" src="../Images/e594_06.gif" /></span> integer, hence $q$ is even. By induction on $m$ there is a tree with path lengths $l_1−1, l_3, l_4,\ldots,l_m$; take such a tree and replace one of the external nodes at level $l_1−1$ by an internal node whose children are at level $l_1=l_2$.</p>

  <p class="exercises" id="page_595"><strong><a href="../Text/ch02b.html#ch02ex_3_5_4" id="ch02ex_3_5_4a">4</a>.</strong> First, find a tree by Huffman’s method. If $w_j\lt w_{j+1}$, then $l_j\ge l_{j+1}$, since the tree is optimal. The construction in the answer to <a href="../Text/ch02b.html#ch02ex_3_5_3">exercise 3</a> now gives us another tree with these same path lengths and with the weights in the proper sequence. For example, the tree (<a href="../Text/ch02b.html#ch02eq-lev3sec5-11">11</a>) becomes</p>

  <div class="image"><img alt="Image" src="../Images/595fig01.gif" /></div>

  <p class="right"><em>Reference: CACM</em> <strong>7</strong> (1964), 166–169.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_5" id="ch02ex_3_5_5a">5</a>.</strong> (a) $b_{np}=\sum\limits_{\begin{gather}{k+l=n−1\\r+s+n-1=p}\end{gather}}b_{kr}b_{ls}$. Hence $zB(w,wz)^2=B(w,z) – 1$.</p>

  <p class="indent">(b) Take the partial derivative with respect to $w$:</p>

  <p class="center">$2zB(w, wz)(B_w(w, wz)+zB_z(w, wz))=B_w(w,z)$.</p>

  <p>Therefore if $H(z)=B_w(1,z)=\sum_n h_n z^n$, we find $H(z)=2zB(z)(H(z)+zB'(z))$; and the known formula for $B(z)$ implies</p>

  <div class="image"><img alt="Image" src="../Images/e595_02.gif" /></div>

  <p>The average value is <em>h<sub>n</sub>/b<sub>n</sub></em>. (c) Asymptotically, this comes to <span class="middle"><img alt="Image" src="../Images/e595_03.gif" /></span>.</p>

  <p class="indent">For the solution to similar problems, see John Riordan, <em>IBM J. Res. and Devel.</em> <strong>4</strong> (1960), 473–478; A. Rényi and G. Szekeres, <em>J. Australian Math. Soc.</em> <strong>7</strong> (1967), 497–507; John Riordan and N. J. A. Sloane, <em>J. Australian Math. Soc.</em> <strong>10</strong> (1969), 278–282; and <a href="../Text/ch02a.html#ch02ex_2_7_11">exercise 2.3.1–11</a>.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_6" id="ch02ex_3_5_6a">6</a>.</strong> $n+s−1=tn$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_7" id="ch02ex_3_5_7a">7</a>.</strong> $E=(t−1)I+tn$.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_8" id="ch02ex_3_5_8a">8</a>.</strong> Summation by parts gives <span class="middle"><img alt="Image" src="../Images/e595_04.gif" /></span>, where the sum on the right is over values of $k$ such that $0\le k\le n$ and $(t−1)k+1=t^j$ for some $j$. The latter sum may be rewritten <span class="middle"><img alt="Image" src="../Images/e595_05.gif" /></span>.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_5_9" id="ch02ex_3_5_9a">9</a>.</strong> Induction on the size of the tree.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_10" id="ch02ex_3_5_10a">10</a>.</strong> By adding extra <em>zero</em> weights, if necessary, we may assume that $m\mod (t−1)=1$. To obtain a $t\unicode{45}\rm ary$ tree with minimum weighted path length, combine the smallest $t$ values at each step and replace them by their sum. The proof is essentially the same as the binary case. The desired ternary tree is shown.</p>

  <div class="image"><img alt="Image" src="../Images/595fig02.gif" /></div>

  <p class="indent">F. K. Hwang has observed [<em>SIAM J. Appl. Math.</em> <strong>37</strong> (1979), 124–127] that a similar procedure is valid for minimum weighted path length trees having any prescribed multiset of degrees: Combine the smallest $t$ weights at each step, where $t$ is as small as possible.</p>

  <p class="exercises1" id="page_596"><strong><a href="../Text/ch02b.html#ch02ex_3_5_11" id="ch02ex_3_5_11a">11</a>.</strong> The “Dewey” notation is the binary representation of the node number.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_12" id="ch02ex_3_5_12a">12</a>.</strong> By <a href="../Text/ch02b.html#ch02ex_3_5_9">exercise 9</a>, it is the internal path length divided by $n$, plus 1. (This result holds for general trees as well as binary trees.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_13" id="ch02ex_3_5_13a">13</a>.</strong> [See J. van Leeuwen, <em>Proc. 3rd International Colloq. Automata, Languages and Programming</em> (Edinburgh University Press, 1976), 382–410.]</p>

  <p class="uln-indentC"><strong>H1.</strong> [Initialize.] Set $A[m−1+i]\gets w_i$ for $1\le i\le m$. Then set $A[2m]\gets\infty$, $x\gets m$, $i\gets m+1$, $j\gets m−1$, $k\gets m$. (During this algorithm $A[i]\le\cdots\le A[2m−1]$ is the queue of unused external weights; $A[k]\ge\cdots\ge A[j]$ is the queue of unused internal weights, empty if $j\lt k$; the current left and right pointers are $x$ and $y$.)</p>

  <p class="uln-indentC"><strong>H2.</strong> [Find right pointer.] If $j\lt k$ or $A[i]\le A[j]$, set $y\gets i$ and $i\gets i+1$; otherwise set $y\gets j$ and $j\gets j−1$.</p>

  <p class="uln-indentC"><strong>H3.</strong> [Create internal node.] Set $k\gets k−1$, $L[k]\gets x$, $R[k]\gets y$, $A[k]\gets A[x]+A[y]$.</p>

  <p class="uln-indentC"><strong>H4.</strong> [Done?] Terminate the algorithm if $k=1$.</p>

  <p class="uln-indentC"><strong>H5.</strong> [Find left pointer.] (At this point $j\ge k$ and the queues contain a total of $k$ unused weights. If $A[y]\lt 0$ we have $j=k$, $i=y+1$, and $A[i]\gt A[j]$.) If $A[i]\le A[j]$, set $x\gets i$ and $i\gets i+1$; otherwise set $x\gets j$ and $j\gets j−1$. Return to step H2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_14" id="ch02ex_3_5_14a">14</a>.</strong> The proof for $k=m−1$ applies with little change. [See <em>SIAM J. Appl. Math.</em> <strong>21</strong> (1971), 518.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_15" id="ch02ex_3_5_15a">15</a>.</strong> Use the combined-weight functions (a) $1+max(w_1, w_2)$ and (b) $xw_1+xw_2$, respectively, instead of $w_1+w_2$ in (<a href="../Text/ch02b.html#ch02eq-lev3sec5-9">9</a>). [Part (a) is due to M. C. Golumbic, <em>IEEE Trans.</em> <strong>C-25</strong> (1976), 1164–1167; part (b) to T. C. Hu, D. Kleitman, and J. K. Tamaki, <em>SIAM J. Appl. Math.</em> <strong>37</strong> (1979), 246–256. Huffman’s problem is the limiting case of (b) as $x\to 1$, since $\sum (1+\epsilon)^{l_j}w_j=\sum w_j+\epsilon\sum w_j l_j+O(\epsilon^2)$.]</p>

  <p class="indent">D. Stott Parker, Jr., has pointed out that a Huffman-like algorithm will also find the minimum of $w_1 x^{l_1}+\cdots+w_m x^{l_m}$ when $0\lt x\lt 1$, if the two <em>maximum</em> weights are combined at each step as in part (b). In particular, the minimum of $w_1 2^{−l_1}+\cdots+w_m 2^{−l_m}$, when $w_1\le\cdots\le w_m$, is $w_1 / 2+\cdots+w_{m−1}/ 2^{m−1}+w_m / 2^{m−1}$. See D. E. Knuth, <em>J. Comb. Theory</em> <strong>A32</strong> (1982), 216–224, for further generalizations.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_16" id="ch02ex_3_5_16a">16</a>.</strong> Let $l_{m+1}=l'_{m+1}=0$. Then</p>

  <div class="image"><img alt="Image" src="../Images/e596_02.gif" /></div>

  <p>since <span class="middle"><img alt="Image" src="../Images/e596_03.gif" /></span> as in <a href="../Text/ch02b.html#ch02ex_3_5_4">exercise 4</a>. The same proof holds for many other kinds of optimum trees, including those of <a href="../Text/ch02b.html#ch02ex_3_5_10">exercise 10</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02b.html#ch02ex_3_5_17" id="ch02ex_3_5_17a">17</a>.</strong> (a) This is <a href="../Text/ch02b.html#ch02ex_3_5_14">exercise 14</a>. (b) We can extend $f(n)$ to a concave function $f(x)$, so the stated inequality holds. Now $F(m)$ is the minimum of <span class="middle"><img alt="Image" src="../Images/e596_04.gif" /></span>, where the $s_j$ are internal node weights of an extended binary tree on the weights $1, 1,\ldots,1$. Huffman’s algorithm, which constructs the complete binary tree with $m−1$ internal nodes in this case, yields the optimum tree. The choice $k=2^{\lceil{lg(n/3)}\rceil}$ defines a binary tree with the same internal weights, so it yields the minimum in the recurrence, for each $n$. [<em>SIAM J. Appl. Math.</em> <strong>31</strong> (1976), 368–378.] We can evaluate $F(n)$ in $O(log n)$ steps; see exercises 5.2.3–20 and 5.2.3–21. If $f(n)$ is convex instead of concave, so that $Δ^2 f(n)\ge 0$, the solution to the recurrence is obtained when $k =\lfloor{n/2}\rfloor$.</p>

  <div class="heading">
    <h5 id="app01lev3sec11"><a id="page_597"></a>Section 2.3.4.6</h5>

    <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_6_1" id="ch02ex_3_6_1a">1</a>.</strong> Choose one edge of the polygon and call it the base. Given a triangulation, let the triangle on the base correspond to the root of a binary tree, and let the other two sides of that triangle define bases of left and right subpolygons, which correspond to left and right subtrees in the same way. We proceed recursively until reaching “2-sided” polygons, which correspond to empty binary trees.</p>
  </div>

  <p class="indent">Stating this correspondence another way, we can label the non-base edges of a triangulated polygon with the integers $0,\ldots,n$; and when two adjacent sides of a triangle are labeled α and β in clockwise order, we can label the third side $(\alphaβ)$. The label of the base then characterizes the binary tree and the triangulation. For example,</p>

  <div class="image"><img alt="Image" src="../Images/597fig01.gif" /></div>

  <p>corresponds to the binary tree shown in <a href="../Text/ch02a.html#ch02lev2sec7">2.3.1</a>–(<a href="../Text/ch02a.html#ch02eq-lev2sec7-1">1</a>). [See H. G. Forder, <em>Mathematical Gazette</em> <strong>45</strong> (1961), 199–201.]</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_6_2" id="ch02ex_3_6_2a">2</a>.</strong> (a) Take a base edge as in <a href="../Text/ch02b.html#ch02ex_3_6_1">exercise 1</a>, and give it $d$ descendants if that edge is part of a $(d+1)\unicode{45}\rm gon$ in the dissected $r\unicode{45}\rm gon$. The other $d$ edges are then bases for subtrees. This defines a correspondence between Kirkman’s problem and all ordered trees with $r−1$ leaves and $k+1$ nonleaves, having no nodes of degree 1. (When $k=r−3$ we have the situation of <a href="../Text/ch02b.html#ch02ex_3_6_1">exercise 1</a>.)</p>

  <p class="indent">(b) There are <span class="middle"><img alt="Image" src="../Images/e597_01.gif" /></span> sequences $d_1 d_2\ldots d_{r+k}$ of nonnegative integers such that $r−1$ of the $d\mathrm{’s}$ are 0, none of them are 1, and the sum is $r+k−1$. Exactly one of the cyclic permutations $d_1 d_2\ldots d_{r+k}, d_2\ldots d_{r+k}d_1,\ldots,d_{r+k}d_1\ldots d_{r+k−1}$ satisfies the additional property that <span class="middle"><img alt="Image" src="../Images/e597_02.gif" /></span> for $1\le q\le r+k$.</p>

  <p class="indent">[Kirkman gave evidence for his conjecture in <em>Philos. Trans.</em> <strong>147</strong> (1857), 217–272, §22. Cayley proved it in <em>Proc. London Math. Soc.</em> <strong>22</strong> (1891), 237–262, without noticing the connection to trees.]</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_6_3" id="ch02ex_3_6_3a">3</a>.</strong> (a) Let the vertices be $\{1, 2,\ldots,n\}$. Draw an $\tt RLINK$ from $i$ to $j$ if $i$ and $j$ are consecutive elements of the same part and $i\lt j$; draw an $\tt LLINK$ from $j$ to $j+1$ if $j+1$ is the smallest of its part. Then there are $k−1$ nonnull $\tt LLINK\rm{s}$, $n−k$ nonnull $\tt RLINK\rm{s}$, and we have a binary tree whose nodes are $12\ldots n$ in preorder. Using the natural correspondence of <a href="../Text/ch02a.html#ch02lev2sec8">Section 2.3.2</a>, this rule defines a one-to-one correspondence between “partitions of an $n\unicode{45}\rm gon’s$ vertices into $k$ noncrossing parts” and “forests with $n$ vertices and $n−k+1$ leaves.” Interchanging $\tt LLINK$ with $\tt RLINK$ also gives “forests with $n$ vertices and $k$ leaves.”</p>

  <p class="indent">(b) A forest with $n$ vertices and $k$ leaves also corresponds to a sequence of nested parentheses, containing $n$ left parentheses, $n$ right parentheses, and $k$ occurrences of “()”. We can enumerate such sequences as follows:</p>

  <p class="indent" id="page_598">Say that a string of 0s and 1s is an $(m,n,k)$ string if there are $m$ 0s, $n$ 1s, and $k$ occurrences of “01”. Then $0010101001110$ is a $(7,6,4)$ string. The number of $(m,n,k)$ strings is <span class="middle"><img alt="Image" src="../Images/e598_01.gif" /></span>, because we are free to choose which 0s and 1s will form the 01 pairs.</p>

  <p class="indent">Let $S(\alpha)$ be the number of 0s in α minus the number of 1s. We say that a string σ is <em>good</em> if $S(\alpha)\ge 0$ whenever α is a prefix of σ (in other words, if $σ =\alphaβ$ implies that $S(\alpha)\ge 0$); otherwise σ is <em>bad</em>. The following alternative to the “reflection principle” of <a href="../Text/ch02.html#ch02ex_2_1_4">exercise 2.2.1–4</a> establishes a one-to-one correspondence between bad $(n,n,k)$ strings and arbitrary $(n−1, n+1, k)$ strings:</p>

  <p class="indent">Any bad $(n,n,k)$ string σ can be written uniquely in the form $σ =\alpha 0β$, where <span class="middle"><img alt="Image" src="../Images/e598_02.gif" /></span> and β are good. (Here <span class="middle"><img alt="Image" src="../Images/e598_02.gif" /></span> is the string obtained from α by reversing it and complementing all the bits.) Then $σ' =\alpha 1β$ is an $(n−1, n+1, k)$ string. Conversely, every $(n−1, n+1, k)$ string can be written uniquely in the form $\alpha1β$ where <span class="middle"><img alt="Image" src="../Images/e598_02.gif" /></span> and β are good, and $\alpha0β$ is then a bad $(n,n,k)$ string.</p>

  <p class="indent">Thus the number of forests with $n$ vertices and $k$ leaves is <span class="middle"><img alt="Image" src="../Images/e598_03.gif" /></span>, a so-called <em>Narayana number</em> [T. V. Narayana, <em>Comptes Rendus Acad. Sci.</em> <strong>240</strong> (Paris, 1955), 1188–1189].</p>

  <p class="indent"><em>Notes:</em> G. Kreweras, <em>Discrete Math.</em> <strong>1</strong> (1972), 333–350, enumerated noncrossing partitions in a different way. The partial ordering of partitions by refinement leads to an interesting partial ordering of forests, different from the one discussed in <a href="../Text/ch02b.html#ch02ex_3_6_2">exercise 2</a>.3.3– 19; see Y. Poupard, <em>Cahiers du Bureau Univ. de Recherche Opér.</em> <strong>16</strong> (1971), Chapter 8; <em>Discrete Math.</em> <strong>2</strong> (1972), 279–288; P. Edelman, <em>Discrete Math.</em> <strong>31</strong> (1980), 171–180, <strong>40</strong> (1982), 171–179; N. Dershowitz and S. Zaks, <em>Discrete Math.</em> <strong>64</strong> (1986), 215–218.</p>

  <p class="indent">A third way to define a natural lattice ordering of forests was introduced by R. Stanley in <em>Fibonacci Quarterly</em> <strong>13</strong> (1975), 215–232: Suppose we represent a forest by a string σ of 0s and 1s representing left and right parentheses as above; then $σ\le σ'$ if and only if $S(σ_k)\le S(σ'_k)$ for all $k$, where $σ_k$ denotes the first $k$ bits of σ. Stanley’s lattice is <em>distributive</em>, unlike the other two.</p>

  <p class="exercises"><strong><a href="../Text/ch02b.html#ch02ex_3_6_4" id="ch02ex_3_6_4a">4</a>.</strong> Let $m=n+2$; by <a href="../Text/ch02b.html#ch02ex_3_6_1">exercise 1</a>, we want a correspondence between triangulated $m\unicode{45}\rm gons$ and $(m−1)\unicode{45}\rm rowed$ friezes. First let’s look more closely at the previous correspondence, by giving a “top-down” labeling to the edges of a triangulation instead of the “bottom-up” one considered earlier: Assign the empty label $\epsilon$ to the base, then recursively give the labels $\alpha L$ and $\alpha R$ to the opposite edges of a triangle whose base is labeled α. For example, the previous diagram becomes</p>

  <div class="image"><img alt="Image" src="../Images/598fig01.gif" /></div>

  <p>under these new conventions. If the base edge in this example is called 10, while the other edges are 0 to 9 as before, we can write $0=10LLL$, $1=10LLR$, $2=10LR$, <a id="page_599"></a>$3=10RLL$, etc. Any of the other edges can also be chosen as the base; thus, if 0 is chosen we have $1=0L$, $2=0RL$, $3=0RRLLL$, etc. It is not difficult to verify that if $u=v\alpha$ we have $v=u\alpha^T$, where $\alpha^T$ is obtained by reading α from right to left and interchanging $L$ with $R$. For example, $10=0RRR=1LRR=2LR=3RRL$, etc. If $u$, $v$, and $w$ are edges of the polygon with $w=u\alphaLγ and w=vβRγ$, then $u=vβL\alpha^T$ and $v=u\alpha Rβ^T$.</p>

  <p class="indent">Given a triangulation of a polygon whose edges are numbered $0, 1,\ldots,m−1$, we define $(u,v)$ for any pair of distinct edges $u$ and <em>υ</em> as follows: Let $u=v\alpha$, and interpret α as a $2×2$ matrix by letting <span class="middle"><img alt="Image" src="../Images/e599_01.gif" /></span> and <span class="middle"><img alt="Image" src="../Images/e599_02.gif" /></span>. Then $(u,v)$ is defined to be the element in the upper left corner of α. Notice that $\alpha^T$ is the transpose of the matrix α, since $R=L^T$; hence we have $(v,u)=(u,v)$. Notice also that $(u,v)=1$ if and only if $u_−$ and $v_−$ are joined by an edge of the triangulation, where $u_−$ denotes the vertex between edges $u$ and $u−1$.</p>

  <p class="indent">Let $(u,u)=0$ for all polygon edges $u$. We can now prove that $v=u\alpha$ implies</p>

  <div class="image"><img alt="Image" src="../Images/e599_03.gif" /></div>

  <p>where $u+1$ and $v+1$ are the clockwise successors of $u$ and $v$. The proof is by induction on $m$: Eq. $(*)$ is trivial when $m=2$, since the two parallel edges $u$ and <em>υ</em> are then related by $u=v\epsilon$, and $\alpha =\epsilon$ is the identity matrix. If any triangulation is augmented by extending some edge $v$ with a triangle $v v' v''$, then $v=u\alpha$ implies $v'=u\alpha L$ and $v''=u\alpha R$; hence $(u, v')$ and $(u, v'')$ in the extended polygon are respectively equal to $(u,v)$ and $(u,v)+(u, v+1)$ in the original one. It follows that</p>

  <div class="image"><img alt="Image" src="../Images/e599_04.gif" /></div>

  <p>and $(*)$ remains true in the extended polygon.</p>

  <p class="indent">The frieze pattern corresponding to the given triangulation is now defined to be the periodic sequence</p>

  <div class="image"><img alt="Image" src="../Images/e599_05.gif" /></div>

  <p>and so on until $m−1$ rows have been defined; the final row begins with $(\lceil{m/2}\rceil+1,\lceil{m/2}\rceil)$ when $m\gt 3$. Condition $(*)$ proves that this pattern is a frieze, namely that</p>

  <div class="image"><img alt="Image" src="../Images/e599_06.gif" /></div>

  <p>because $det L =\det R=1$ implies $\det\alpha=1$. Our example triangulation yields</p>

  <p class="uln-indent">1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  &nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  &nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  &nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  3&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  &nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  5&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.<br/>
  &nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;.&nbsp;.</p>

  <p id="page_600">The relation $(u,v)=1$ defines the edges of the triangulation, hence different triangulations yield different friezes. To complete the proof of one-to-one correspondence, we must show that every $(m−1)\unicode{45}\rm rowed$ frieze pattern of positive integers is obtained in this way from some triangulation.</p>

  <p class="indent">Given any frieze of $m−1$ rows, extend it by putting a new row 0 at the top and a new row $m$ at the bottom, both consisting entirely of zeros. Now let the elements of row 0 be called $(0,0)$, $(1,1)$, $(2,2)$, etc., and for all nonnegative integers $u\lt v\le u+m$ let $(u,v)$ be the element in the diagonal southeast of $(u,u)$ and in the diagonal southwest of $(v,v)$. By assumption, condition $(**)$ holds for all $u\lt v\lt u+m$. We can in fact extend $(**)$ to the considerably more general relation</p>

  <div class="image"><img alt="Image" src="../Images/e600_01.gif" /></div>

  <p>For if $(***)$ is false, let $(t,u,v,w)$ be a counterexample with the smallest value of $(w−t)m+u−t+w−v$. Clearly $t\neq u$ and $υ\neq w$. <em>Case 1:</em> $t+1\lt u$. Then $(***)$ holds for $(t, t+1, v, w)$, $(t, t+1, u, v)$, and $(t+1, u, v, w)$, so we find $((t,u)(v,w)+(t,w)(u,v))(t+1, v)=(t,v)(u,w)(t+1, v); this implies (t+1, v)=0$, a contradiction. <em>Case 2:</em> $v+1\lt w$. Then $(***)$ holds for $(t, u, w−1, w)$, $(u, v, w−1, w)$, and $(t, u, v, w−1)$; we obtain a similar contradiction $(u, w−1)=0$. <em>Case 3:</em> $u=t+1$ and $w=v+1$. In this case $(***)$ reduces to $(**)$.</p>

  <p class="indent">Now we set $u=t+1$ and $w=t+m$ in $(***)$, obtaining $(t,v)=(v, t+m)$ for $t\le v\le t+m$, because $(t+1, t+m)=1$ and $(t, t+m)=0$. We conclude that the entries of any $(m−1)\unicode{45}\rm rowed$ frieze are periodic: $(u,v)=(v, u+m)=(u+m, v+m)=(v+m, u+2m)=\cdots$.</p>

  <p class="indent">Every frieze pattern of positive integers contains a 1 in row 2. For if we set $t=0$, $v=u+1$, and $w=u+2$ in $(***)$ we get $(0, u+1)(u, u+2)=(0,u)+(0, u+2)$, hence $(0, u+2)−(0, u+1)\ge (0, u+1)−(0,u)$ if and only if $(u, u+2)\ge 2$. This cannot hold for all $u$ in the range $0\le u\le m−2$, because $(0,1)−(0,0)=1$ and $(0,m)−(0, m−1)=−1$.</p>

  <p class="indent">Finally, if $m\gt 3$ we cannot have two consecutive 1s in row 2, because $(u, u+2)=(u+1, u+3)=1$ implies $(u, u+3)=0$. Therefore we can reduce the frieze to another one with $m$ reduced by 1, as illustrated here for 7 rows reduced to 6:</p>

  <div class="image"><img alt="Image" src="../Images/e600_02.gif" /></div>

  <p>The reduced frieze corresponds to a triangulation, by induction, and the unreduced frieze corresponds to attaching one more triangle. [<em>Math. Gazette</em> <strong>57</strong> (1974), 87–94, 175–183; Conway and Guy, <em>The Book of Numbers</em> (New York: Copernicus, 1996), 74–76, 96–97, 101–102.]</p>

  <p class="indent"><em>Notes:</em> This proof demonstrates that the function $(u,v)$, which we defined on any triangulation via $2×2$ matrices, satisfies $(***)$ whenever $(t,u,v,w)$ are edges of the polygon in clockwise order. We can express each $(u,v)$ as a polynomial in the numbers $a_j=(j−1, j+1)$; these polynomials are essentially identical to the “continuants” discussed in Section 4.5.3, except for the signs of individual terms. In fact, $(j,k)=i^{1−k+j}K_{k−j−1}(ia_{j+1}, ia_{j+2},\ldots,ia_{k−1})$. Thus $(***)$ is equivalent to Euler’s identity <a id="page_601"></a>for continuants in the answer to exercise 4.5.3–32. The matrices $L$ and $R$ have the interesting property that any $2×2$ matrix of nonnegative integers with determinant 1 can be expressed uniquely as a product of $L\mathrm{’s}$ and $R\mathrm{’s}$.</p>

  <p class="indent">Many other interesting relationships are present; for example, the numbers in row 2 of an integer frieze count the number of triangles touching each vertex of the corresponding triangulated polygon. The total number of occurrences of $(u,v)=1$ in the basic region $0\le u\lt v−1\lt m−1$ and $(u,v)\neq (0, m−1)$ is the number of diagonals (chords) of the triangulation, namely $m−3=n−1$. The total number of 2s is also $n−1$, because $(u,v)=2$ if and only if $u_−$ and $v_−$ are opposing vertices of the two triangles adjacent to a chord.</p>

  <p class="indent">Another interpretation of $(u,v)$ was found by D. Broline, D. W. Crowe, and I. M. Isaacs [<em>Geometriæ Dedicata</em> <strong>3</strong> (1974), 171–176]: It is the number of ways to match the $v−u−1$ vertices between edges $u$ and $υ−1$ with distinct triangles adjacent to those vertices.</p>

  <div class="heading">
    <h4 id="app01lev2sec26">Section 2.3.5</h4>

    <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_1" id="ch02ex_2_11_1a">1</a>.</strong> A List structure is a directed graph in which the arcs leaving each vertex are ordered, and where some of the vertices that have out-degree 0 are designated “atoms.” Furthermore there is a vertex $S$ such that there is an oriented path from $S$ to $V$ for all vertices $V\neq S$. (With directions of arcs reversed, $S$ would be a “root.”)</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_2" id="ch02ex_2_11_2a">2</a>.</strong> Not in the same way, since thread links in the usual representation lead back to “$\tt PARENT$,” which is not unique for sub-Lists. The representation discussed in <a href="../Text/ch02b.html#ch02ex_3_2_25">exercise 2.3.4.2–25</a>, or some similar method, could perhaps be used (but this idea has not yet been exploited at the time of writing).</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_3" id="ch02ex_2_11_3a">3</a>.</strong> As mentioned in the text, we prove also that ${\tt P}=\tt P0$ upon termination. If only $\tt P0$ is to be marked, the algorithm certainly operates correctly. If $n\gt 1$ nodes are to be marked, we must have ${\tt ATOM(P0)}=0$. Step E4 then sets ${\tt ALINK(P0)}\gets\varLambda$ and executes the algorithm with $\tt P0$ replaced by $\tt ALINK(P0)$ and $\tt T$ replaced by $\tt P0$. By induction (note that since $\tt MARK(P0)$ is now 1, all links to $\tt P0$ are equivalent to $\varLambda$ by steps E4 and E5), we see that ultimately we will mark all nodes on paths that start with $\tt ALINK(P0)$ and do not pass through $\tt P0$; and we will then get to step E6 with ${\tt T}=\tt P0$ and ${\tt P}=\tt ALINK(P0)$. Now since ${\tt ATOM(T)}=1$, step E6 restores $\tt ALINK(P0)$ and $\tt ATOM(P0)$ and we reach step E5. Step E5 sets ${\tt BLINK(P0)}\gets\varLambda$, etc., and a similar argument shows that we will ultimately mark all nodes on paths that start with $\tt BLINK(P0)$ and do not pass through $\tt P0$ or nodes reachable from $\tt ALINK(P0)$. Then we will get to E6 with ${\tt T}=\tt P0$, ${\tt P}=\tt BLINK(P0)$, and finally we get to E6 with ${\tt T}=\varLambda$, ${\tt P}=\tt P0$.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_4" id="ch02ex_2_11_4a">4</a>.</strong> The program that follows incorporates the suggested improvements in the speed of processing atoms that appear in the text after the statement of <a href="../Text/ch02c.html#ch02alg-lev2sec11-E">Algorithm E</a>.</p>

  <p class="indent">In steps E4 and E5 of the algorithm, we want to test if ${\tt MARK(Q)}=0$. If ${\tt NODE(Q)}=+0$, this is an unusual case that can be handled properly by setting it to $− 0$ and treating it as if it were originally $− 0$, since it has $\tt ALINK$ and $\tt BLINK$ both $\varLambda$. This simplification is not reflected in the timing calculations below.</p>

  <p class="indent">$\rm rI1\equiv\tt P$, $\rm rI2\equiv\tt T$, $\rm rI3\equiv\tt Q$, and $rX\equiv −1$ (for setting $\tt MARK\rm{s}$).</p>

  <div class="image"><img alt="Image" src="../Images/601pro01.gif" /></div>

  <div class="image" id="page_602"><img alt="Image" src="../Images/601pro01a.gif" /></div>

  <p>By Kirchhoff’s law, $t_1+t_2+1=n$. The total time is $(34n+4t_1+3a−5b−8)u$, where $n$ is the number of nonatomic nodes marked, $a$ is the number of atoms marked, $b$ is the number of $\varLambda$ links encountered in marked nonatomic nodes, and $t_1$ is the number of times we went down an $\tt ALINK$ $(0\le t_1\lt n)$.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_5" id="ch02ex_2_11_5a">5</a>.</strong> (The following is the fastest known marking algorithm for a one-level memory.)</p>

  <p class="uln-indentC"><strong>S1.</strong> Set ${\tt MARK(P0)}\gets 1$. If $\tt ATOM(P0)=1$, the algorithm terminates; otherwise set $\tt S\gets 0$, $\tt R\gets P0$, ${\tt T}\gets\varLambda$.</p>

  <p class="uln-indentC"><strong>S2.</strong> Set $\tt P\gets BLINK(R)$. If ${\tt P}=\varLambda$ or $\tt MARK(P)=1$, go to S3. Otherwise set $\tt MARK(P)\gets 1$. Now if $\tt ATOM(P)=1$, go to S3; otherwise if ${\tt S}\lt\tt N$ set ${\tt S\gets S}+1$, $\tt STACK[S]\gets P$, and go to S3; otherwise go to S5.</p>

  <p class="uln-indentC" id="page_603"><strong>S3.</strong> Set $\tt P\gets ALINK(R)$. If ${\tt P}=\varLambda$ or ${\tt MARK(P)}=1$, go to S4. Otherwise set ${\tt MARK(P)}\gets 1$. Now if ${\tt ATOM(P)}=1$, go to S4; otherwise set $\tt R\gets P$ and return to S2.</p>

  <p class="uln-indentC"><strong>S4.</strong> If ${\tt S}=0$, terminate the algorithm; otherwise set $\tt R\gets STACK[S]$, ${\tt S\gets S}− 1$, and go to S2.</p>

  <p class="uln-indentC"><strong>S5.</strong> Set $\tt Q\gets ALINK(P)$. If ${\tt Q}=\varLambda$ or ${\tt MARK(Q)}=1$, go to S6. Otherwise set ${\tt MARK(Q)}\gets 1$. Now if ${\tt ATOM(Q)}=1$, go to S6; otherwise set ${\tt ATOM(P)}\gets 1$, $\tt ALINK(P)\gets T$, $\tt T\gets P$, $\tt P\gets Q$, go to S5.</p>

  <p class="uln-indentC"><strong>S6.</strong> Set $\tt Q\gets BLINK(P)$. If ${\tt Q}=\varLambda$ or ${\tt MARK(Q)}=1$, go to S7; otherwise set ${\tt MARK(Q)}\gets 1$. Now if ${\tt ATOM(Q)}=1$, go to S7; otherwise set $\tt BLINK(P)\gets T$, $\tt T\gets P$, $\tt P\gets Q$, go to S5.</p>

  <p class="uln-indentC"><strong>S7.</strong> If ${\tt T}=\varLambda$, go to S3. Otherwise set $\tt Q\gets T$. If ${\tt ATOM(Q)}=1$, set ${\tt ATOM(Q)}\gets 0$, $\tt T\gets ALINK(Q)$, $\tt ALINK(Q)\gets P$, $\tt P\gets Q$, and return to S6. If ${\tt ATOM(Q)}=0$, set $\tt T\gets BLINK(Q)$, $\tt BLINK(Q)\gets P$, $\tt P\gets Q$, and return to S7. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p><em>Reference: CACM</em> <strong>10</strong> (1967), 501–506.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_6" id="ch02ex_2_11_6a">6</a>.</strong> From the second phase of garbage collection (or perhaps also the initial phase, if all mark bits are set to zero at that time).</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_7" id="ch02ex_2_11_7a">7</a>.</strong> Delete steps E2 and E3, and delete “${\tt ATOM(P)}\gets 1$” in E4. Set ${\tt MARK(P)}\gets 1$ in step E5 and use “${\tt MARK(Q)}=0$”, “${\tt MARK(Q)}=1$” in step E6 in place of the present “${\tt ATOM(Q)}=1$”, “${\tt ATOM(Q)}=0$” respectively. The idea is to set the $\tt MARK$ bit only after the left subtree has been marked. This algorithm works even if the tree has overlapping (shared) subtrees, but it does not work for all recursive List structures such as those with ${\tt NODE(ALINK(Q))}$ an ancestor of $\tt NODE(Q)$. (Note that $\tt ALINK$ of a marked node is never changed.)</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_2_11_8" id="ch02ex_2_11_8a">8</a>.</strong> <em>Solution 1:</em> Analogous to <a href="../Text/ch02c.html#ch02alg-lev2sec11-E">Algorithm E</a>, but simpler.</p>

  <p class="uln-indentC"><strong>F1.</strong> Set ${\tt T}\gets\varLambda$, $\tt P\gets P0$.</p>

  <p class="uln-indentC"><strong>F2.</strong> Set ${\tt MARK(P)}\gets 1$, and set ${\tt P\gets P}+\tt SIZE(P)$.</p>

  <p class="uln-indentC"><strong>F3.</strong> If ${\tt MARK(P)}=1$, go to F5.</p>

  <p class="uln-indentC"><strong>F4.</strong> Set $\tt Q\gets LINK(P)$. If ${\tt Q}\neq\varLambda$ and ${\tt MARK(Q)}=0$, set $\tt LINK(P)\gets T$, $\tt T\gets P$, $\tt P\gets Q$ and go to F2. Otherwise set ${\tt P\gets P}− 1$ and return to F3.</p>

  <p class="uln-indentC"><strong>F5.</strong> If ${\tt T}=\varLambda$, stop. Otherwise set $\tt Q\gets T$, $\tt T\gets LINK(Q)$, $\tt LINK(Q)\gets P$, ${\tt P\gets Q}− 1$, and return to F3. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="indent">A similar algorithm, which sometimes decreases the storage overhead and which avoids all pointers into the middle of nodes, has been suggested by Lars-Erik Thorelli, <em>BIT</em> <strong>12</strong> (1972), 555–568.</p>

  <p class="indent"><em>Solution 2:</em> Analogous to <a href="../Text/ch02c.html#ch02alg-lev2sec11-D">Algorithm D</a>. For this solution, we assume that the $\tt SIZE$ field is large enough to contain a link address. Such an assumption is probably not justified by the statement of the problem, but it lets us use a slightly faster method than the first solution when it is applicable.</p>

  <p class="uln-indentC"><strong>G1.</strong> Set ${\tt T}\gets\varLambda$, ${\tt MARK(P0)}\gets 1$, ${\tt P\gets P0}+\tt SIZE(P0)$.</p>

  <p class="uln-indentC"><strong>G2.</strong> If ${\tt MARK(P)}=1$, go to G5.</p>

  <p class="uln-indentC"><strong>G3.</strong> Set $\tt Q\gets LINK(P)$, ${\tt P\gets P}− 1$.</p>

  <p class="uln-indentC"><strong>G4.</strong> If ${\tt Q}\neq\varLambda$ and ${\tt MARK(Q)}=0$, set ${\tt MARK(Q)}\gets 1$, $\tt S\gets SIZE(Q)$, $\tt SIZE(Q)\gets T$, ${\tt T\gets Q}+\tt S$. Go back to G2.</p>

  <p class="uln-indentC" id="page_604"><strong>G5.</strong> If ${\tt T}=\varLambda$, stop. Otherwise set $\tt P\gets T$ and find the first value of ${\tt Q}={\tt P},{\tt P}− 1,{\tt P}− 2,\ldots$ for which ${\tt MARK(Q)}=1$; set $\tt T\gets SIZE(Q)$ and ${\tt SIZE(Q)\gets P}−\tt Q$. Go back to G2. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="answer2"><strong><a href="../Text/ch02c.html#ch02ex_2_11_9" id="ch02ex_2_11_9a">9</a>. H1.</strong> Set ${\tt L}\gets 0$, ${\tt K\gets M}+1$, ${\tt MARK(0)}\gets 1$, ${\tt MARK(M}+1{\tt )}\gets 0$.</p>

  <p class="uln-indentC"><strong>H2.</strong> Increase $\tt L$ by one, and if ${\tt MARK(L)}=$ 1 repeat this step.</p>

  <p class="uln-indentC"><strong>H3.</strong> Decrease $\tt K$ by one, and if ${\tt MARK(K)}=0$ repeat this step.</p>

  <p class="uln-indentC"><strong>H4.</strong> If ${\tt L}\gt\tt K$, go to step H5; otherwise set ${\tt NODE(L)\gets NODE(K)}$, $\tt ALINK(K)\gets L$, ${\tt MARK(K)}\gets 0$, and return to H2.</p>

  <p class="uln-indentC"><strong>H5.</strong> For ${\tt L}=1, 2,\ldots,\tt K$ do the following: Set ${\tt MARK(L)}\gets 0$. If ${\tt ATOM(L)}=0$ and ${\tt ALINK(L)}\gt\tt K$, set ${\tt ALINK(L)\gets ALINK(ALINK(L))}$. If ${\tt ATOM(L)}=0$ and ${\tt BLINK(L)}\gt\tt K$, set ${\tt BLINK(L)\gets ALINK(BLINK(L))}$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>See also <a href="../Text/ch02c.html#ch02ex_1_5_33">exercise 2.5–33</a>.</p>

  <p class="answer3"><strong><a href="../Text/ch02c.html#ch02ex_2_11_10" id="ch02ex_2_11_10a">10</a>. Z1.</strong> [Initialize.] Set $\tt F\gets P0$, ${\tt R}\Leftarrow\tt AVAIL$, ${\tt NODE(R)\gets NODE(F)}$, $\tt REF(F)\gets R$. (Here $\tt F$ and $\tt R$ are pointers for a queue set up in the $\tt REF$ fields of all header nodes encountered.)</p>

  <p class="uln-indentC"><strong>Z2.</strong> [Begin new List.] Set $\tt P\gets F$, $\tt Q\gets REF(P)$.</p>

  <p class="uln-indentC"><strong>Z3.</strong> [Advance to right.] Set $\tt P\gets RLINK(P)$. If ${\tt P}=\varLambda$, go to Z6.</p>

  <p class="uln-indentC"><strong>Z4.</strong> [Copy one node.] Set ${\tt Q1}\Leftarrow\tt AVAIL$, ${\tt RLINK(Q)\gets Q1}$, $\tt Q\gets Q1$, ${\tt NODE(Q)\gets NODE(P)}$.</p>

  <p class="uln-indentC"><strong>Z5.</strong> [Translate sub-List link.] If ${\tt T(P)}=1$, set $\tt P1\gets REF(P)$, and if ${\tt REF(P1)}=\varLambda$ set $\tt REF(R)\gets P1$, ${\tt R}\Leftarrow\tt AVAIL$, $\tt REF(P1)\gets R$, ${\tt NODE(R)\gets NODE(P1)}$, $\tt REF(Q)\gets R$. If ${\tt T(P)}=1$ and ${\tt REF(P1)}\neq\varLambda$, set ${\tt REF(Q)\gets REF(P1)}$. Go to Z3.</p>

  <p class="uln-indentC"><strong>Z6.</strong> [Move to next List.] Set ${\tt RLINK(Q)}\gets\varLambda$. If $\tt REF(F)\neq R$, set ${\tt F\gets REF(REF(F))}$ and return to Z2. Otherwise set ${\tt REF(R)}\gets\varLambda$, $\tt P\gets P0$.</p>

  <p class="uln-indentC"><strong>Z7.</strong> [Final cleanup.] Set $\tt Q\gets REF(P)$. If ${\tt Q}\neq\varLambda$, set ${\tt REF(P)}\gets\varLambda$ and $\tt P\gets Q$ and repeat step Z7. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>Of course, this use of the $\tt REF$ fields makes it impossible to do garbage collection with <a href="../Text/ch02c.html#ch02alg-lev2sec11-D">Algorithm D</a>; moreover, <a href="../Text/ch02c.html#ch02alg-lev2sec11-D">Algorithm D</a> is ruled out by the fact that the Lists aren’t well-formed during the copying.</p>

  <p class="indent">Several elegant List-moving and List-copying algorithms that make substantially weaker assumptions about List representation have been devised. See D. W. Clark, <em>CACM</em> <strong>19</strong> (1976), 352–354; J. M. Robson, <em>CACM</em> <strong>20</strong> (1977), 431–433.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_2_11_11" id="ch02ex_2_11_11a">11</a>.</strong> Here is a pencil-and-paper method that can be written out more formally to answer the problem: First attach a unique name (e.g., a capital letter) to each List in the given set; in the example we might have $A=(a: C, b, a: F)$, $F=(b: D)$, $B=(a: F, b, a: E)$, $C=(b: G)$, $G=(a: C)$, $D=(a: F)$, $E=(b: G)$. Now make a list of pairs of List names that must be proved equal. Successively add pairs to this list until either a contradiction is found because we have a pair that disagree on the first level (then the originally given Lists are unequal), or until the list of pairs does not imply any further pairs (then the originally given Lists are equal). In the example, this list of pairs would originally contain only the given pair, <em>AB</em>; then it gets the further pairs <em>CF</em>, <em>EF</em> (by matching $A$ and $B$), <em>DG</em> (from <em>CF</em>); and then we have a self-consistent set.</p>

  <p class="indent">To prove the validity of this method, observe that (i) if it returns the answer “unequal”, the given Lists are unequal; (ii) if the given Lists are unequal, it returns the answer “unequal”; (iii) it always terminates.</p>

  <p class="exercises1" id="page_605"><strong><a href="../Text/ch02c.html#ch02ex_2_11_12" id="ch02ex_2_11_12a">12</a>.</strong> When the $\tt AVAIL$ list contains $N$ nodes, where $N$ is a specified constant to be chosen as discussed below, initiate another coroutine that shares computer time with the main routine and does the following: (a) Marks all $N$ nodes on the $\tt AVAIL$ list; (b) marks all other nodes that are accessible to the program; (c) links all unmarked nodes together to prepare a new $\tt AVAIL$ list for use when the current $\tt AVAIL$ list is empty, and (d) resets the mark bits in all nodes. One must choose $N$ and the ratio of time sharing so that operations (a), (b), (c), and (d) are guaranteed to be complete before $N$ nodes are taken from the $\tt AVAIL$ list, yet the main routine is running sufficiently fast. It is necessary to use some care in step (b) to make sure that all nodes “accessible to the program” are included, as the program continues to run; details are omitted here. If the list formed in (c) has fewer than $N$ nodes, it may be necessary to stop eventually because memory space might become exhausted. [For further information, see Guy L. Steele Jr., <em>CACM</em> <strong>18</strong> (1975), 495–508; P. Wadler, <em>CACM</em> <strong>19</strong> (1976), 491–500; E. W. Dijkstra, L. Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens, <em>CACM</em> <strong>21</strong> (1978), 966–975; H. G. Baker, Jr., <em>CACM</em> <strong>21</strong> (1978), 280–294.]</p>

  <div class="heading">
    <h3 id="app01lev1sec5">Section 2.4</h3>

    <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_1" id="ch02ex_1_4_1a">1</a>.</strong> Preorder.</p>
  </div>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_2" id="ch02ex_1_4_2a">2</a>.</strong> It is essentially proportional to the number of Data Table entries created.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_3" id="ch02ex_1_4_3a">3</a>.</strong> Change step A5 to:</p>

  <p class="indenthangingAA"><strong>A5'.</strong> [Remove top level.] Remove the top stack entry; and if the new level number at the top of the stack is $\ge\tt L$, let $({\tt L1},{\tt P1})$ be the new entry at the top of the stack and repeat this step. Otherwise set $\tt SIB(P1)\gets Q$ and then let $({\tt L1},{\tt P1})$ be the new entry at the top of the stack.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_4" id="ch02ex_1_4_4a">4</a>.</strong> (Solution by David S. Wise.) Rule (c) is violated if and only if there is a data item whose <em>complete qualification</em> $A_0 {\tt OF}\ldots{\tt OF}A_n$ is also a COBOL reference to some other data item. Since the parent $A_1 {\tt OF}\ldots{\tt OF}A_n$ must also satisfy rule (c), we may assume that this other data item is a descendant of the same parent. Therefore <a href="../Text/ch02c.html#ch02alg-lev1sec5-A">Algorithm A</a> would be extended to check, as each new data item is added to the Data Table, whether its parent is an ancestor of any other item of the same name, or if the parent of any other item of the same name is in the stack. (When the parent is $\varLambda$, it is everybody’s ancestor and always on the stack.)</p>

  <p class="indent">On the other hand, if we leave <a href="../Text/ch02c.html#ch02alg-lev1sec5-A">Algorithm A</a> as it stands, the COBOL programmer will get an error message from <a href="../Text/ch02c.html#ch02alg-lev1sec5-B">Algorithm B</a> when trying to use an illegal item. Only $\tt MOVE\;CORRESPONDING$ can make use of such items without error.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_5" id="ch02ex_1_4_5a">5</a>.</strong> Make these changes:</p>

  <div class="image"><img alt="Image" src="../Images/605pro01.gif" /></div>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_6" id="ch02ex_1_4_6a">6</a>.</strong> A simple modification of <a href="../Text/ch02c.html#ch02alg-lev1sec5-B">Algorithm B</a> makes it search only for complete references (if $k=n$ and ${\tt PARENT(S)}\neq\varLambda$ in step B3, or if ${\tt NAME(S)}\neq P_k$ in step B6, set $\tt P\gets PREV(P)$ and go to B2). The idea is to run through this modified <a href="../Text/ch02c.html#ch02alg-lev1sec5-B">Algorithm B</a> first; then, if $\tt Q$ is <em>still</em> $\varLambda$, to perform the unmodified algorithm.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_7" id="ch02ex_1_4_7a">7</a>.</strong>
  ${\tt MOVE MONTH OF DATE OF SALES TO MONTH <br/>  OF DATE OF PURCHASES. MOVE DAY OF DATE OF <br/>  SALES TO DAY OF DATE OF PURCHASES. MOVE YEAR <br/>  OF DATE OF SALES TO YEAR OF <a id="page_606"></a>DATE OF PURCHASES. <br/>  MOVE ITEM OF TRANSACTION OF SALES TO ITEM OF <br/>  TRANSACTION OF PURCHASES. MOVE QUANTITY OF <br/>  TRANSACTION OF SALES TO QUANTITY OF <br/>  TRANSACTION OF PURCHASES. MOVE PRICE OF <br/>  TRANSACTION OF SALES TO PRICE OF TRANSACTION <br/>  OF PURCHASES. MOVE TAX OF TRANSACTION OF <br/>  SALES TO TAX OF TRANSACTION OF PURCHASES}$.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_8" id="ch02ex_1_4_8a">8</a>.</strong> If and only if α or β is an elementary item. (It may be of interest to note that the author failed to handle this case properly in his first draft of <a href="../Text/ch02c.html#ch02alg-lev1sec5-C">Algorithm C</a>, and it actually made the algorithm more complicated.)</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_4_9" id="ch02ex_1_4_9a">9</a>.</strong> “${\tt MOVE\;CORRESPONDING}\;\alpha\;{\tt TO}\;β$”, if neither α nor β is elementary, is equivalent to the set of statements “${\tt MOVE\;CORRESPONDING}\;A\;{\tt OF}\;\alpha\;{\tt TO}\;A\;{\tt OF}\;β$” taken over all names $A$ common to groups α and β. (This is a more elegant way to state the definition than the more traditional and more cumbersome definition of “$\tt MOVE\;CORRESPONDING$” given in the text.) We may verify that <a href="../Text/ch02c.html#ch02alg-lev1sec5-C">Algorithm C</a> satisfies this definition, using an inductive proof that steps C2 through C5 will ultimately terminate with ${\tt P}=\tt P0$ and ${\tt Q}=\tt Q0$. Further details of the proof are filled in as we have done many times before in a “tree induction” (see, for example, the proof of <a href="../Text/ch02a.html#ch02alg-lev2sec7-T">Algorithm 2.3.1T</a>).</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_4_10" id="ch02ex_1_4_10a">10</a>.</strong> (a) Set ${\tt S1\gets LINK}(P_k)$. Then repeatedly set ${\tt S1\gets PREV(S1)}$ zero or more times until either ${\tt S1}=\varLambda({\tt NAME(S)}\neq P_k)$ or ${\tt S1}={\tt S}({\tt NAME(S)}=P_k)$. (b) Set $\tt P1\gets P$ and then set ${\tt P1\gets PREV(P1)}$ zero or more times until ${\tt PREV(P1)}=\varLambda$; do a similar operation with variables $\tt Q1$ and $\tt Q$; then test if ${\tt P1}=\tt Q1$. Alternatively, if the Data Table entries are ordered so that ${\tt PREV(P)}\lt\tt P$ for all $\tt P$, a faster test can be made in an obvious way depending on whether ${\tt P}\gt\tt Q$ or not, following the $\tt PREV$ links of the larger to see if the smaller is encountered.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_4_11" id="ch02ex_1_4_11a">11</a>.</strong> A minuscule improvement in the speed of step C4 would be achieved by adding a new link field ${\tt SIB1(P)}\equiv{\tt CHILD(PARENT(P))}$. More significantly, we could modify the $\tt CHILD$ and $\tt SIB$ links so that ${\tt NAME(SIB(P))}\gt\tt NAME(P)$; this would speed up the search in step C3 considerably because it would require only one pass over each family to find the matching members. This change would therefore remove the only “search” present in <a href="../Text/ch02c.html#ch02alg-lev1sec5-C">Algorithm C</a>. <a href="../Text/ch02c.html#ch02alg-lev1sec5-A">Algorithms A</a> and <a href="../Text/ch02c.html#ch02alg-lev1sec5-C">C</a> are readily modified for this interpretation, and the reader may find it an interesting exercise. (However, if we consider the relative frequency of $\tt MOVE\;CORRESPONDING$ statements and the usual size of family groups, the resulting speedup will not be terribly significant in the translation of actual COBOL programs.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_4_12" id="ch02ex_1_4_12a">12</a>.</strong> Leave steps B1, B2, B3 unchanged; change the other steps thus:</p>

  <p class="indenthangingAA1"><strong>B4'.</strong> Set $k\gets k+1$, ${\tt R\gets LINK(}P_k\tt )$.</p>

  <p class="indenthangingAA1"><strong>B5'.</strong> If ${\tt R}=\varLambda$, set $\tt P\gets PREV(P)$ and go to B2' (we haven’t found a match). If $R\lt {\tt S}\le\tt SCOPE(R)$, set $\tt S\gets R$ and go to B3'. Otherwise set $\tt R\gets PREV(R)$ and repeat step B5'. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>This algorithm does <em>not</em> adapt to the PL/I convention of <a href="../Text/ch02c.html#ch02ex_1_4_6">exercise 6</a>.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_4_13" id="ch02ex_1_4_13a">13</a>.</strong> Use the same algorithm, minus the operations that set $\tt NAME$, $\tt PARENT$, $\tt CHILD$, and $\tt SIB$. Whenever removing the top stack entry in step A5, set ${\tt SCOPE(P1)\gets Q}− 1$. When the input is exhausted in step A2, simply set ${\tt L}\gets 0$ and continue, then terminate the algorithm if ${\tt L}=0$ in step A7.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_4_14" id="ch02ex_1_4_14a">14</a>.</strong> The following algorithm, using an auxiliary stack, has steps numbered to show a direct correspondence with the text’s algorithm.</p>

  <p class="indenthangingAA1"><strong>C1'.</strong> Set $\tt P\gets P0$, $\tt Q\gets Q0$, and set the stack contents empty.</p>

  <p class="indenthangingAA1" id="page_607"><strong>C2'.</strong> If ${\tt SCOPE(P)}=\tt P$ or ${\tt SCOPE(Q)}=\tt Q$, output $({\tt P},{\tt Q})$ as one of the desired pairs and go to C5'. Otherwise put $({\tt P},{\tt Q})$ on the stack and set ${\tt P\gets P}+1$, ${\tt Q\gets Q}+1$.</p>

  <p class="indenthangingAA1"><strong>C3'.</strong> Determine if $\tt P$ and $\tt Q$ point to entries with the same name (see <a href="../Text/ch02c.html#ch02ex_1_4_10">exercise 10</a>(b)). If so, go to C2'. If not, let $({\tt P1},{\tt Q1})$ be the entry at the top of the stack; if ${\tt SCOPE(Q)}\lt\tt SCOPE(Q1)$, set ${\tt Q\gets SCOPE(Q)}+1$ and repeat step C3'.</p>

  <p class="indenthangingAA1"><strong>C4'.</strong> Let $({\tt P1},{\tt Q1})$ be the entry at the top of the stack. If ${\tt SCOPE(P)}\lt\tt SCOPE(P1)$, set ${\tt P\gets SCOPE(P)}+1$, ${\tt Q\gets Q1}+1$, and go back to C3'. If ${\tt SCOPE(P)}=\tt SCOPE(P1)$, set $\tt P\gets P1$, $\tt Q\gets Q1$ and remove the top entry of the stack.</p>

  <p class="indenthangingAA1"><strong>C5'.</strong> If the stack is empty, the algorithm terminates. Otherwise go to C4'. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <div class="heading">
    <h3 id="app01lev1sec6">Section 2.5</h3>

    <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_1" id="ch02ex_1_5_1a">1</a>.</strong> In such fortuitous circumstances, a stack-like operation may be used as follows: Let the memory pool area be locations 0 through ${\tt M}− 1$, and let $\tt AVAIL$ point to the lowest free location. To reserve $\tt N$ words, report failure if ${\tt AVAIL}+{\tt N}\ge\tt M$, otherwise set ${\tt AVAIL\gets AVAIL}+\tt N$. To free these $\tt N$ words, just set ${\tt AVAIL\gets AVAIL}−\tt N$.</p>
  </div>

  <p class="indent">Similarly, cyclic queue-like operation is appropriate for a first-in-first-out discipline.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_2" id="ch02ex_1_5_2a">2</a>.</strong> The amount of storage space for an item of length $l$ is $k\lceil{l/(k−b)}\rceil$, which has the average value $kL/(k−b)+(1 −\alpha)k$, where α is assumed to be $1/2$, independent of $k$. This expression is a minimum (for real values of $k$) when $k=b+\sqrt{2bL}$. So choose $k$ to be the integer just above or just below this value, whichever gives the lowest value of $kL/(k−b)+\left(\frac12\right)k$. For example, if $b=1$ and $L=10$, we would choose $k\approx 1+\sqrt{20}=5\;\rm or\;6$; both are equally good. For much greater detail about this problem, see <em>JACM</em> <strong>12</strong> (1965), 53–70.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_4" id="ch02ex_1_5_4a">4</a>.</strong> $\rm rI1\equiv\tt Q$, $\rm rI2\equiv\tt P$.</p>

  <div class="image"><img alt="Image" src="../Images/607pro01.gif" /></div>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_5" id="ch02ex_1_5_5a">5</a>.</strong> Probably not. The unavailable storage area just before location $\tt P$ will subsequently become available, and its length will be increased by the amount $\tt K$; an increase of 99 would not be negligible.</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_6" id="ch02ex_1_5_6a">6</a>.</strong> The idea is to try to search in different parts of the $\tt AVAIL$ list each time. We can use a “roving pointer,” called $\tt ROVER$ for example, which is treated as follows: In step A1, set $\tt Q\gets ROVER$. After step A4, set ${\tt ROVER\gets LINK(Q)}$ if ${\tt LINK(Q)}\neq\varLambda$, otherwise set ${\tt ROVER\gets LOC(AVAIL)}$. In step A2, when ${\tt P}=\varLambda$ the first time during a particular execution of <a href="../Text/ch02c.html#ch02alg-lev1sec5-A">Algorithm A</a>, set ${\tt Q\gets LOC(AVAIL)}$ and repeat step A2. When ${\tt P}=\varLambda$ the <em>second</em> time, the algorithm terminates unsuccessfully. In this way $\tt ROVER$ will tend to <a id="page_608"></a>point to a random spot in the $\tt AVAIL$ list, and the sizes will be more balanced. At the beginning of the program, set ${\tt ROVER\gets LOC(AVAIL)}$; it is <em>also</em> necessary to set $\tt ROVER$ to $\tt LOC(AVAIL)$ everywhere else in the program where the block whose address equals the current setting of $\tt ROVER$ is taken out of the $\tt AVAIL$ list. (Sometimes, however, it is useful to have small blocks at the beginning, as in the strict first-fit method; for example, we might want to keep a sequential stack at the high end of memory. In such cases we can reduce the search time by using trees as suggested in exercise 6.2.3–30.)</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_7" id="ch02ex_1_5_7a">7</a>.</strong> 2000, 1000 with requests of sizes 800, 1300. [An example where worst-fit succeeds, while best-fit fails, has been constructed by R. J. Weiland.]</p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_8" id="ch02ex_1_5_8a">8</a>.</strong> In step $A1''$, also set ${\tt M}\gets\infty$, ${\tt R}\gets\varLambda$. In step $A2''$, if ${\tt P}=\varLambda$ go to $A6''$. In step $A3''$, go to $A5''$ instead of to $A4''$. Add new steps as follows:</p>

  <p class="uln-indentC"><strong>A5''.</strong> [Better fit?] If ${\tt M}\gt\tt SIZE(P)$, set $\tt R\gets Q$ and $\tt M\gets SIZE(P)$. Then set $\tt Q\gets P$ and return to $A2''$.</p>

  <p class="uln-indentC"><strong>A6''.</strong> [Any found?] If ${\tt R}=\varLambda$, the algorithm terminates unsuccessfully. Otherwise set $\tt Q\gets R$, $\tt P\gets LINK(Q)$, and go to $A4''$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises"><strong><a href="../Text/ch02c.html#ch02ex_1_5_9" id="ch02ex_1_5_9a">9</a>.</strong> Obviously if we are so lucky as to find ${\tt SIZE(P)}=\tt N$, we have a best fit and it is not necessary to search farther. (When there are only very few different block sizes, this occurs rather often.) If a “boundary tag” method like <a href="../Text/ch02c.html#ch02alg-lev1sec5-C">Algorithm C</a> is being used, it is possible to maintain the $\tt AVAIL$ list in sorted order by size; so the length of search could be cut down to half the length of the list or less, on the average. But the best solution is to make the $\tt AVAIL$ list into a balanced tree structure as described in Section 6.2.3, if it is expected to be long.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_10" id="ch02ex_1_5_10a">10</a>.</strong> Make the following changes:</p>

  <p class="uln-indent">Step B2, for “${\tt P}\gt\tt P0$” read “${\tt P}\ge\tt P0$”.</p>

  <p class="indent">At the beginning of step B3, insert “If ${\tt P0}+{\tt N}\gt\tt P$ and ${\tt P}\neq\varLambda$, set ${\tt N}\gets max(\tt N$, ${\tt P}+{\tt SIZE(P)}− {\tt P0})$, $\tt P\gets LINK(P)$, and repeat step B3.”</p>

  <p class="indent">Step B4, for “${\tt Q}+{\tt SIZE(Q)}=\tt P0$”, read “${\tt Q}+{\tt SIZE(Q)}\ge\tt P0$”; and for “${\tt SIZE(Q)\gets SIZE(Q)}+\tt N$” read “$\tt SIZE(Q)\gets\operatorname{max}(SIZE(Q), P0+N−Q)$”.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_11" id="ch02ex_1_5_11a">11</a>.</strong> If $\tt P0$ is greater than $\tt ROVER$, we can set $\tt Q\gets ROVER$ instead of ${\tt Q\gets LOC(AVAIL)}$ in step B1. If there are $n$ entries in the $\tt AVAIL$ list, the average number of iterations of step B2 is $(2n+3)(n+2)/(6n+6)=\frac13 n+\frac56+O\left(\frac1n\right)$. For example if $n=2$ we get 9 equally probable situations, where $\tt P1$ and $\tt P2$ point to the two existing available blocks:</p>

  <div class="image"><img alt="Image" src="../Images/e608_02.gif" /></div>

  <p>This chart shows the number of iterations needed in each case. The average is</p>

  <div class="image"><img alt="Image" src="../Images/e608_03.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_12" id="ch02ex_1_5_12a">12</a></strong>. <strong>A1*.</strong> Set $\tt P\gets ROVER$, ${\tt F}\gets 0$.</p>

  <p class="indenthangingAA1"><strong>A2*.</strong> If ${\tt P}=\tt LOC(AVAIL)$ and ${\tt F}=0$, set $\tt P\gets AVAIL$, ${\tt F}\gets 1$, and repeat step $A2*$. If ${\tt P}=\tt LOC(AVAIL)$ and ${\tt F}\neq 0$, the algorithm terminates unsuccessfully.</p>

  <p class="indenthangingAA1"><strong>A3*.</strong> If ${\tt SIZE(P)}\ge\tt N$, go to A4*; otherwise set $\tt P\gets LINK(P)$ and return to A2*.</p>

  <p class="indenthangingAA1" id="page_609"><strong>A4*.</strong> Set ${\tt ROVER\gets LINK(P)}$, ${\tt K\gets SIZE(P)}−\tt N$. If ${\tt K}\lt c$ (where $c$ is a constant $\ge 2$), set ${\tt LINK(LINK(P+1))\gets ROVER}$, ${\tt LINK(ROVER+1)\gets LINK(P+1)}$, $\tt L\gets P$; otherwise set ${\tt L\gets P}+\tt K$, ${\tt SIZE(P)\gets SIZE(L−1)\gets K}$, ${\tt TAG(L−1)}\gets “−”$, $\tt SIZE(L)\gets N$. Finally set ${\tt TAG(L)\gets TAG(L}+{\tt SIZE(L)−1)}\gets “+”$. <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_13" id="ch02ex_1_5_13a">13</a>.</strong> $\rm rI1\equiv\tt P$, $rX\equiv\tt F$, $\rm rI2\equiv\tt L$.</p>

  <div class="image"><img alt="Image" src="../Images/609pro01.gif" /></div>

  <div class="image"><img alt="Image" src="../Images/609pro01a.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_14" id="ch02ex_1_5_14a">14</a>.</strong> (a) This field is needed to locate the beginning of the block, in step C2. It could be replaced (perhaps to advantage) by a link to the first word of the block. See also <a href="../Text/ch02c.html#ch02ex_1_5_19">exercise 19</a>. (b) This field is needed because we sometimes need to reserve more than $\tt N$ words (for example if ${\tt K}=1$), and the amount reserved must be known when the block is subsequently freed.</p>

  <p class="exercises1" id="page_610"><strong><a href="../Text/ch02c.html#ch02ex_1_5_15" id="ch02ex_1_5_15a">15</a>, <a href="../Text/ch02c.html#ch02ex_1_5_16" id="ch02ex_1_5_16a">16</a>.</strong> $\rm rI1\equiv\tt P0$, $\rm rI2\equiv\tt P1$, $\rm rI3\equiv\tt F$, $\rm rI4\equiv\rm B$, $\rm rI6\equiv\tt −N$.</p>

  <div class="image"><img alt="Image" src="../Images/610pro01.gif" /></div>

  <div class="image"><img alt="Image" src="../Images/610pro01a.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_17" id="ch02ex_1_5_17a">17</a>.</strong> Both $\tt LINK$ fields equal to $\tt LOC(AVAIL)$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_18" id="ch02ex_1_5_18a">18</a>.</strong> <a href="../Text/ch02c.html#ch02alg-lev1sec5-A">Algorithm A</a> reserves the upper end of a large block. When storage is completely available, the first-fit method actually begins by reserving the high-order locations, but once these become available again they are not re-reserved since a fit is usually found already in the lower locations; thus the initial large block at the lower end of memory quickly disappears with first-fit. A large block rarely is the best fit, however, so the best-fit method leaves a large block at the beginning of memory.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_19" id="ch02ex_1_5_19a">19</a>.</strong> Use the algorithm of <a href="../Text/ch02c.html#ch02ex_1_5_12">exercise 12</a>, except delete the references to $\tt SIZE(L−1)$, $\tt TAG(L−1)$, and ${\tt TAG(L+SIZE(L)−1)}$ from step A4*; also insert the following new step between steps A2* and A3*:</p>

  <p class="uln-indentCC"><strong>A2.5*.</strong> Set ${\tt P1\gets P}+\tt SIZE(P)$. If ${\tt TAG(P1)}=“+”$, proceed to step A3. Otherwise set ${\tt P2\gets LINK(P1)}$, ${\tt LINK(P2+1)\gets LINK(P1+1)}$, ${\tt LINK(LINK(P1}+1{\tt ))\gets P2}$, ${\tt SIZE(P)\gets SIZE(P)}+\tt SIZE(P1)$. If ${\tt ROVER}=\tt P1$, set $\tt ROVER\gets P2$. Repeat step A2.5*.</p>

  <p class="indent" id="page_611">Clearly the situation of (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-2">2</a></em>), (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-3">3</a></em>), (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-4">4</a></em>) can’t occur here; the only real effect on storage allocation is that the search here will tend to be longer than in <a href="../Text/ch02c.html#ch02ex_1_5_12">exercise 12</a>, and sometimes $\tt K$ will be less than $c$ although there is really another available block preceding this one that we do not know about.</p>

  <p class="indent">(An alternative is to take the collapsing out of the inner loop A3*, and to do the collapsing only in step A4* before the final allocation or in the inner loop when the algorithm would otherwise have terminated unsuccessfully. This alternative requires a simulation study to see if it is an improvement or not.)</p>

  <p class="indent">[This method, with a few refinements, has proved to be quite satisfactory in the implementations of TeX and $\tt METAFONT$. See <em>TeX: The Program</em> (Addison–Wesley, 1986), §125.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_20" id="ch02ex_1_5_20a">20</a>.</strong> When a buddy is found to be available, during the collapsing loop, we want to remove that block from its ${\tt AVAIL[}k{\tt]}$ list, but we do not know which links to update unless (i) we do a possibly long search, or (ii) the list is doubly linked.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_21" id="ch02ex_1_5_21a">21</a>.</strong> If $n=2^k\alpha$, where $1\le\alpha\le 2$, $a_n$ is $2^{2k+1}\left(\alpha −\frac23\right)+\frac13$, and $b_n$ is $2^{2k−1}\alpha^2+2^{k−1}\alpha$. The ratio $a_n/b_n$ for large $n$ is essentially ${4\left(\alpha −\frac23\right)}/\alpha^2$, which takes its minimum value $\frac43$ when $\alpha=1\;\rm and\;2$, and its maximum value $\frac32$ when $\alpha=1\frac13$. So $a_n/b_n$ approaches no limit; it oscillates between these two extremes. The averaging methods of Section 4.2.4 do, however, yield an average ratio of $4(\ln2)^{−1}\int_1^2\left(\alpha−\frac23\right)d\alpha/\alpha^3=(\ln2)^{−1}\approx 1.44$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_22" id="ch02ex_1_5_22a">22</a>.</strong> This idea requires a $\tt TAG$ field in several words of the $11\unicode{45}\rm word\;block$, not only in the first word. It is a workable idea, if those extra $\tt TAG$ bits can be spared, and it would appear to be especially suitable for use in computer hardware.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_23" id="ch02ex_1_5_23a">23</a>.</strong> 011011110100; 011011100000.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_24" id="ch02ex_1_5_24a">24</a>.</strong> This would introduce a bug in the program; we may get to step S1 when ${\tt TAG(}0{\tt )}=1$, since S2 may return to S1. To make it work, add “${\tt TAG(L)}\gets 0$” after “$\tt L\gets P$” in step S2. (It is easier to assume instead that ${\tt TAG(}2^m{\tt )}=0$.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_25" id="ch02ex_1_5_25a">25</a>.</strong> The idea is absolutely correct. (Criticism need not be negative.) The list heads ${\tt AVAIL[}k{\tt]}$ may be eliminated for $n\lt k\le m$; the algorithms of the text may be used if “$m$” is changed to “$n$” in steps R1, S1. The initial conditions (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-13">13</a></em>) and (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-14">14</a></em>) should be changed to indicate $2^{m−n}$ blocks of size $2^n$ instead of one block of size $2^m$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_26" id="ch02ex_1_5_26a">26</a>.</strong> Using the binary representation of $\tt M$, we can easily modify the initial conditions (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-13">13</a></em>), (<em><a href="../Text/ch02c.html#ch02eq-lev1sec5-14">14</a></em>) so that all memory locations are divided into blocks whose size is a power of two, with blocks in decreasing order of size. In <a href="../Text/ch02c.html#ch02alg-lev1sec5-S">Algorithm S</a>, $\tt TAG(P)$ should be regarded as 0 whenever ${\tt P}\ge {\tt M}− 2^k$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_27" id="ch02ex_1_5_27a">27</a>.</strong> ${\rm rI1}\equiv k$, ${\rm rI2}\equiv j$, ${\rm rI3}\equiv j−k$, $\rm rI4\equiv\tt L$, ${\tt LOC(AVAIL[}j{\tt])}={\tt AVAIL}+j$; assume that there is an auxiliary table ${\tt TWO[}j{\tt]}=2^j$, stored in location ${\tt TWO}+j$, for $0\le j\le m$. Assume further that “+” and “−” represent tags of 0 and 1, and that ${\tt TAG(LOC(AVAIL[}j{\tt]))}=“−”$; but ${\tt TAG(LOC(AVAIL[}m+1{\tt]))}=“+”$ is a sentinel.</p>

  <div class="image"><img alt="Image" src="../Images/611pro01.gif" /></div>

  <div class="image" id="page_612"><img alt="Image" src="../Images/611pro01a.gif" /></div>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_28" id="ch02ex_1_5_28a">28</a>.</strong> ${\rm rI1}\equiv k$, $\rm rI5\equiv\tt P$, $\rm rI4\equiv\tt L$; assume ${\tt TAG(}2^m{\tt )}=“+”$.</p>

  <div class="image"><img alt="Image" src="../Images/612pro01.gif" /></div>

  <p class="exercises1" id="page_613"><strong><a href="../Text/ch02c.html#ch02ex_1_5_29" id="ch02ex_1_5_29a">29</a>.</strong> Yes, but only at the expense of some searching, or (better) an additional table of $\tt TAG$ bits packed somehow. (It is tempting to suggest that buddies not be joined together during <a href="../Text/ch02c.html#ch02alg-lev1sec5-S">Algorithm S</a>, but only in <a href="../Text/ch02c.html#ch02alg-lev1sec5-R">Algorithm R</a> if there is no block large enough to meet the request; but that would probably lead to a badly fragmented memory.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_31" id="ch02ex_1_5_31a">31</a>.</strong> See David L. Russell, <em>SICOMP</em> <strong>6</strong> (1977), 607–621.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_32" id="ch02ex_1_5_32a">32</a>.</strong> Steven Crain points out that the method always frees all blocks and starts afresh before 16667 units of time have elapsed; hence the stated limit certainly exists. <em>Proof:</em> Let $u_n=n+t_n$, so that <span class="middle"><img alt="Image" src="../Images/e613_01.gif" /></span>. Let $x_0=0$ and $x_1=u_0$, and $x_{k+1}=max(u_0\ldots,u_{x_{k−1}})$ for $k\ge 1$. If $x_k\gt x_{k−1}$ then</p>

  <div class="image"><img alt="Image" src="../Images/e613_02.gif" /></div>

  <p>therefore <span class="middle"><img alt="Image" src="../Images/e613_03.gif" /></span>, and we must have $x_k=x_{k−1}$ before reaching time $12500+\lfloor{12500/4}\rfloor+\lfloor{12500/4^2}\rfloor+\cdots$.</p>

  <p class="answer2"><strong><a href="../Text/ch02c.html#ch02ex_1_5_33" id="ch02ex_1_5_33a">33</a>. G1.</strong> [Clear $\tt LINK\rm{s}$.] Set ${\tt P}\gets 1$, and repeat the operation ${\tt LINK(P)}\gets\varLambda$, ${\tt P\gets P}+\tt SIZE(P)$ until ${\tt P}=\tt AVAIL$. (This merely sets the $\tt LINK$ field in the first word of each node to $Λ$; we may assume in most cases that this step is unnecessary, since $\tt LINK(P)$ is set to $Λ$ in step G9 below and it can be set to $Λ$ by the storage allocator.)</p>

  <p class="uln-indentC"><strong>G2.</strong> [Initialize marking phase.] Set $\tt TOP\gets USE$, ${\tt LINK(TOP)\gets AVAIL}$, ${\tt LINK(AVAIL)}\gets\varLambda$. ($\tt TOP$ points to the top of a stack as in <a href="../Text/ch02c.html#ch02alg-lev2sec11-D">Algorithm 2.3.5D</a>.)</p>

  <p class="uln-indentC"><strong>G3.</strong> [Pop up stack.] Set $\tt P\gets TOP$, ${\tt TOP\gets LINK(TOP)}$. If ${\tt TOP}=\varLambda$, go to G5.</p>

  <p class="uln-indentC"><strong>G4.</strong> [Put new links on stack.] For $1\le k\le\tt T(P)$, do the following operations: Set ${\tt Q\gets LINK(P}+k\tt )$; then if ${\tt Q}\neq\varLambda$ and ${\tt LINK(Q)}=\varLambda$, set ${\tt LINK(Q)\gets TOP}$, $\tt TOP\gets Q$. Then go back to G3.</p>

  <p class="uln-indentC"><strong>G5.</strong> [Initialize next phase.] (Now ${\tt P}=\tt AVAIL$, and the marking phase has been completed so that the first word of each accessible node has a nonnull $\tt LINK$. Our next goal is to combine adjacent inaccessible nodes, for speed in later steps, and to assign new addresses to the accessible nodes.) Set ${\tt Q}\gets 1$, ${\tt LINK(AVAIL)\gets Q}$, ${\tt SIZE(AVAIL)}\gets 0$, ${\tt P}\gets 1$. (Location $\tt AVAIL$ is being used as a sentinel to signify the end of a loop in subsequent phases.)</p>

  <p class="uln-indentC"><strong>G6.</strong> [Assign new addresses.] If ${\tt LINK(P)}=\varLambda$, go to G7. Otherwise if ${\tt SIZE(P)}=0$, go to G8. Otherwise set $\tt LINK(P)\gets Q$, ${\tt Q\gets Q}+\tt SIZE(P)$, ${\tt P\gets P}+\tt SIZE(P)$, and repeat this step.</p>

  <p class="uln-indentC"><strong>G7.</strong> [Collapse available areas.] If ${\tt LINK(P}+{\tt SIZE(P))}=\varLambda$, increase $\tt SIZE(P)$ by ${\tt SIZE(P}+\tt SIZE(P))$ and repeat this step. Otherwise set ${\tt P\gets P}+\tt SIZE(P)$ and return to G6.</p>

  <p class="uln-indentC"><strong>G8.</strong> [Translate all links.] (Now the $\tt LINK$ field in the first word of each accessible node contains the address to which the node will be moved.) Set ${\tt USE\gets LINK(USE)}$, and $\tt AVAIL\gets Q$. Then set ${\tt P}\gets 1$, and repeat the following operation until ${\tt SIZE(P)}=0$: If ${\tt LINK(P)}\neq\varLambda$, set ${\tt LINK(Q)\gets LINK(LINK(Q))}$ for all $\tt Q$ such that ${\tt P}\lt {\tt Q}\le {\tt P}+\tt T(P)$ and ${\tt LINK(Q)}\neq\varLambda$; then regardless of the value of $\tt LINK(P)$, set ${\tt P\gets P}+\tt SIZE(P)$.</p>

  <p class="uln-indentC" id="page_614"><strong>G9.</strong> [Move.] Set ${\tt P}\gets 1$, and repeat the following operation until ${\tt SIZE(P)}=0$: Set $\tt Q\gets LINK(P)$, and if ${\tt Q}\neq\varLambda$ set ${\tt LINK(P)}\gets\varLambda$ and ${\tt NODE(Q)\gets NODE(P)}$; then whether ${\tt Q}=\varLambda$ or not, set ${\tt P\gets P}+\tt SIZE(P)$. (The operation ${\tt NODE(Q)\gets NODE(P)}$ implies the movement of $\tt SIZE(P)$ words; we always have ${\tt Q}\le\tt P$, so it is safe to move the words in order from smallest location to largest.) <span class="middle"><img alt="Image" src="../Images/box.gif" /></span></p>

  <p>[This method is called the “LISP 2 garbage collector.” An interesting alternative, which does not require the $\tt LINK$ field at the beginning of a node, can be based on the idea of linking together all pointers that point to each node — see Lars-Erik Thorelli, <em>BIT</em> <strong>16</strong> (1976), 426–441; R. B. K. Dewar and A. P. McCann, <em>Software Practice &amp; Exp.</em> <strong>7</strong> (1977), 95–113; F. Lockwood Morris, <em>CACM</em> <strong>21</strong> (1978), 662–665, <strong>22</strong> (1979), 571; H. B. M. Jonkers, <em>Inf. Proc. Letters</em> <strong>9</strong> (1979), 26–30; J. J. Martin, <em>CACM</em> <strong>25</strong> (1982), 571–581; F. Lockwood Morris, <em>Inf. Proc. Letters</em> <strong>15</strong> (1982), 139–142, <strong>16</strong> (1983), 215. Other methods have been published by B. K. Haddon and W. M. Waite, <em>Comp. J.</em> <strong>10</strong> (1967), 162–165; B. Wegbreit, <em>Comp. J.</em> <strong>15</strong> (1972), 204–208; D. A. Zave, <em>Inf. Proc. Letters</em> <strong>3</strong> (1975), 167–169. Cohen and Nicolau have analyzed four of these approaches in <em>ACM Trans. Prog. Languages and Systems</em> <strong>5</strong> (1983), 532–553.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_34" id="ch02ex_1_5_34a">34</a>.</strong> Let ${\tt TOP}\equiv\rm rI1$, ${\tt Q}\equiv\rm rI2$, ${\tt P}\equiv\rm rI3$, $k\equiv\rm rI4$, ${\tt SIZE(P)}\equiv\rm rI5$. Assume further that $\varLambda=0$, and ${\tt LINK(}0{\tt )}\neq 0$ to simplify step G4. Step G1 is omitted.</p>

  <div class="image"><img alt="Image" src="../Images/614pro01.gif" /></div>

  <div class="image"><img alt="Image" src="../Images/614pro01_a.gif" /></div>

  <div class="image" id="page_615"><img alt="Image" src="../Images/614pro01a.gif" /></div>

  <div class="image"><img alt="Image" src="../Images/614pro01b.gif" /></div>

  <p>In line 66 we are assuming that the size of each node is sufficiently small that it can be moved with a single $\tt MOVE$ instruction; this seems a fair assumption for most cases when this kind of garbage collection is applicable.</p>

  <p class="indent">The total running time for this program is $(44a+17b+2w+25c+8d+47)u$, where $a$ is the number of accessible nodes, $b$ is the number of link fields therein, $c$ is the number of inaccessible nodes that are <em>not</em> preceded by an inaccessible node, $d$ is the number of inaccessible nodes that <em>are</em> preceded by an inaccessible node, and $w$ is the total number of words in the accessible nodes. If the memory contains $n$ nodes, with $ρn$ of them <a id="page_616"></a>inaccessible, then we may estimate $a=(1−ρ)n$, $c=(1−ρ)ρn$, $d=ρ^2 n$. Example: five-word nodes (on the average), with two link fields per node (on the average), and a memory of 1000 nodes. Then when $ρ=0.2$, it takes $374u$ per available node recovered; when $ρ=0.5$, it takes $104u$; and when $ρ=0.8$, it takes only $33u$.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_36" id="ch02ex_1_5_36a">36</a>.</strong> A single customer will be able to sit in one of the sixteen seats $1, 3, 4, 6,\ldots,23$. If a pair enters, there must be room for them; otherwise there are at least two people in seats $(1,2,3)$, at least two in $(4,5,6),\ldots$, at least two in $(19, 20, 21)$, and at least one in 22 or 23, so at least fifteen people are already seated.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_37" id="ch02ex_1_5_37a">37</a>.</strong> First sixteen single males enter, and she seats them. There are 17 gaps of empty seats between the occupied seats, counting one gap at each end, with a gap of length zero assumed between adjacent occupied seats. The total number of empty seats, namely the sum of all seventeen gaps, is 6. Suppose $x$ of the gaps are of odd length; then $6−x$ spaces are available to seat pairs. (Note that $6−x$ is even and $\ge 0$.) Now each of the customers 1, 3, 5, 7, 9, 11, 13, 15, from left to right, who has an even gap on both sides, finishes his lunch and walks out. Each odd gap prevents at most one of these eight diners from leaving, hence at least $8−x$ people leave. There <em>still</em> are only $6−x$ spaces available to seat pairs. But now $(8−x)/2$ pairs enter.</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_38" id="ch02ex_1_5_38a">38</a>.</strong> The arguments generalize readily; $N(n,2)=\lfloor{(3n−1)/2}\rfloor$ for $n\ge 1$. [When the hostess uses a first-fit strategy instead of an optimal one, Robson has proved that the necessary and sufficient number of seats is $\lfloor{(5n−2)/3}\rfloor$.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_39" id="ch02ex_1_5_39a">39</a>.</strong> Divide memory into three independent regions of sizes $N(n_1, m)$, $N(n_2, m)$, and $N(2m−2, m)$. To process a request for space, put each block into the first region for which the stated capacity is not exceeded, using the relevant optimum strategy for that region. This cannot fail, for if we were unable to fill a request for $x$ locations we must have at least $(n_1−x+1)+(n_2−x+1)+(2m−x−1)\gt n_1+n_2−x$ locations already occupied.</p>

  <p class="indent">Now if $f(n)=N(n,m)+N(2m−2, m)$, we have the subadditive law $f(n_1+n_2)\le f(n_1)+f(n_2)$. Hence $\lim f(n)/n$ exists. (<em>Proof:</em> $f(a+bc)\le f(a)+bf(c)$; hence $\limsup_{n\to\infty}f(n)/n=max_{0\le a\lt c}\limsup_{b\to\infty}f(a+bc)/(a+bc)\le f(c)/c$ for all $c$; hence $\limsup_{n\to\infty}f(n)/n\le\liminf_{n\to\infty}f(n)/n$). Therefore $\lim N(n,m)/n$ exists.</p>

  <p class="indent">[From <a href="../Text/ch02c.html#ch02ex_1_5_38">exercise 38</a> we know that <span class="middle"><img alt="Image" src="../Images/e616_01.gif" /></span>. The value $N(m)$ is not known for any $m\gt 2$. It is not difficult to show that the multiplicative factor for just two block sizes, 1 and $b$, is $2−1/b$; hence <span class="middle"><img alt="Image" src="../Images/e616_02.gif" /></span>. Robson’s methods imply that <span class="middle"><img alt="Image" src="../Images/e616_03.gif" /></span>, and <span class="middle"><img alt="Image" src="../Images/e616_04.gif" /></span>.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_40" id="ch02ex_1_5_40a">40</a>.</strong> Robson has proved that $N(2^r)\le 1+r$, by using the following strategy: Allocate to each block of size $k$, where $2^m\le k\lt 2^{m+1}$, the first available block of $k$ locations starting at a multiple of $2^m$.</p>

  <p class="indent">Let $N(\{b_1, b_2,\ldots,b_n\})$ denote the multiplicative factor when all block sizes are constrained to lie in the set $\{b_1, b_2,\ldots,b_n\}$, so that $N(n)=N(\{1, 2,\ldots,n\})$. Robson and S. Krogdahl have discovered that $N(\{b_1, b_2,\ldots,b_n\})=n−(b_1/b_2+\cdots+b_{n−1}/b_n)$ whenever $b_i$ is a multiple of $b_{i−1}$ for $1\lt i\le n$; indeed, Robson has established the <em>exact</em> formula <span class="middle"><img alt="Image" src="../Images/e616_05.gif" /></span>. Thus in particular, <span class="middle"><img alt="Image" src="../Images/e616_06.gif" /></span>. He also has derived the upper bound $N(n)\le 1.1825\ln n+O(1)$, and he conjectures tentatively that $N(n)=H_n$. This conjecture would follow if $N(\{b_1, b_2,\ldots,b_n\})$ were equal to $n−(b_1/b_2+\cdots+b_{n−1}/b_n)$ in general, but this is unfortunately not the case since Robson has proved that <span class="middle"><img alt="Image" src="../Images/e616_07.gif" /></span>. (See <em>Inf. Proc. Letters</em> <strong>2</strong> (1973), 96–97; <em>JACM</em> <strong>21</strong> (1974), 491–499.)</p>

  <p class="exercises1" id="page_617"><strong><a href="../Text/ch02c.html#ch02ex_1_5_41" id="ch02ex_1_5_41a">41</a>.</strong> Consider maintaining the blocks of size $2^k$: The requests for sizes $1, 2, 4,\ldots,2^{k−1}$ will periodically call for a new block of size $2^k$ to be split, or a block of that size will be returned. We can prove by induction on $k$ that the total storage consumed by such split blocks never exceeds $kn$; for after every request to split a block of size $2^{k+1}$, we are using at most $kn$ locations in split $2^k\unicode{45}\rm blocks$ and at most $n$ locations in unsplit ones.</p>

  <p class="indent">This argument can be strengthened to show that $a_rn$ cells suffice, where $a_0=1$ and $a_k=1+a_{k−1}(1−2^{− k})$; we have</p>

  <div class="image"><img alt="Image" src="../Images/e617_01.gif" /></div>

  <p>Conversely for $r\le 5$ it can be shown that a buddy system sometimes <em>requires</em> as many as $a_rn$ cells, if the mechanism of steps R1 and R2 is modified to choose the worst possible available $2^j\unicode{45}\rm block$ to split instead of the first such block.</p>

  <p class="indent">Robson’s proof that $N(2^r)\le 1+r$ (see <a href="../Text/ch02c.html#ch02ex_1_5_40">exercise 40</a>) is easily modified to show that such a “leftmost” strategy will never need more than <span class="middle"><img alt="Image" src="../Images/e617_02.gif" /></span> cells to allocate space for blocks of sizes $1, 2, 4,\ldots,2^r$, since blocks of size $2^k$ will never be placed in locations <span class="middle"><img alt="Image" src="../Images/e617_03.gif" /></span>. Although his algorithm seems very much like the buddy system, it turns out that no buddy system will be this good, even if we modify steps R1 and R2 to choose the best possible available $2^j\unicode{45}\rm block$ to split. For example, consider the following sequence of “snapshots” of the memory, for $n=16$ and $r=3$:</p>

  <div class="image"><img alt="Image" src="../Images/e617_04.gif" /></div>

  <p>Here 0 denotes an available location and $k$ denotes the beginning of a $k\unicode{45}\rm block$. In a similar way there is a sequence of operations, whenever $n$ is a multiple of 16, that forces $\frac{3}{16}n$ blocks of size 8 to be $\frac18$ full, and another $\frac{1}{16}n$ to be $\frac12$ full. If $n$ is a multiple of 128, a subsequent request for $\frac{9}{128}n$ blocks of size 8 will require more than $2.5n$ memory cells. (The buddy system allows unwanted 1s to creep into $\frac{3}{16}n$ of the $8\unicode{45}\rm blocks$, since there are no other available 2s to be split at a crucial time; the “leftmost” algorithm keeps all 1s confined.)</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_42" id="ch02ex_1_5_42a">42</a>.</strong> We can assume that $m\ge 6$. The main idea is to establish the occupancy pattern $R_{m−2}(F_{m−3}R_1)^k$ at the beginning of the memory, for $k=0, 1,\ldots$, where $R_j$ and $F_j$ denote reserved and free blocks of size $j$. The transition from $k$ to $k+1$ begins with</p>

  <div class="image"><img alt="Image" src="../Images/e617_08.gif" /></div>

  <p>then the commutation sequence $F_{m−3}R_1 F_m R_{m−5}R_1\to F_{m−3}R_1 R_{m−2}R_2 R_{m−5}R_1\to F_{2m−4}R_2 R_{m−5}R_1\to<br/> R_m R_{m−5}R_1 R_2 R_{m−5}R_1\to F_m R_{m−5}R_1 F_{m−3}R_1$ is used $k$ times until we get $F_m R_{m−5}R_1(F_{m−3}R_1)^k\to F_{2m−5}R_1(F_{m−3}R_1)^k\to<br/> R_{m−2}(F_{m−3}R_1)^{k+1}$. Finally, when $k$ gets large enough, there is an endgame that forces overflow unless the memory size is at least $(n−4m+11)(m−2)$; details appear in <em>Comp. J.</em> <strong>20</strong> (1977), <a id="page_618"></a>242–244. [Notice that the worst conceivable worst case, which begins with the pattern $F_{m−1}R_1 F_{m−1}R_1 F_{m−1}R_1\ldots$, is only slightly worse than this; the next-fit strategy of <a href="../Text/ch02c.html#ch02ex_1_5_6">exercise 6</a> can produce this pessimal pattern.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_43" id="ch02ex_1_5_43a">43</a>.</strong> We will show that if $D_1, D_2,\ldots$ is any sequence of numbers such that $D_1/m+D_2/(m+1)+\cdots+D_m/(2m−1)\ge 1$ for all $m\ge 1$, and if $C_m=D_1/1+D_2/2+\cdots+D_m/m$, then $N_{FF}(n,m)\le nC_m$. In particular, since</p>

  <div class="image"><img alt="Image" src="../Images/e618_01.gif" /></div>

  <p>the constant sequence $D_m=1/\ln 2$ satisfies the necessary conditions. The proof is by induction on $m$. Let $N_j=nC_j$ for $j\ge 1$, and suppose that some request for a block of size $m$ cannot be allocated in the leftmost $N_m$ cells of memory. Then $m\gt 1$. For $0\le j\lt m$, we let <span class="middle"><img alt="Image" src="../Images/e618_02.gif" /></span> denote the rightmost position allocated to blocks of sizes $\le j$, or 0 if all reserved blocks are larger than $j$; by induction we have <span class="middle"><img alt="Image" src="../Images/e618_03.gif" /></span>. Furthermore we let <span class="middle"><img alt="Image" src="../Images/e618_04.gif" /></span> be the rightmost occupied position $\le N_m$, so that <span class="middle"><img alt="Image" src="../Images/e618_05.gif" /></span>. Then the interval <span class="middle"><img alt="Image" src="../Images/e618_06.gif" /></span> contains at least <span class="middle"><img alt="Image" src="../Images/e618_07.gif" /></span> occupied cells, since its free blocks are of size $\lt m$ and its reserved blocks are of size $\ge j$. It follows that $n−m\ge$ number of occupied cells $\ge$$\sum_{j=1}^mj(N'_j-N'_{j-1})/(m+j-1)=mN'_m/(2m-1)-(m-1)$$\sum_{j=1}^{m-1}N'_j/(m+j)(m+j-1)\gt$$mN_m/(2m-1)-m-(m-1)$$\sum_{j=1}^{m-1}N_j(1/(m+j-1)-1/(m+j))=$$\sum_{j=1}^mnD_j/(m+j-1)-m\ge n-m$, a contradiction.</p>

  <p class="indent">[This proof establishes slightly more than was asked. If we define the $D\rm\unicode{39}s$ by $D_1/m+\cdots+D_m/(2m−1)=1$, then the sequence $C_1, C_2,\ldots$ is <span class="middle"><img alt="Image" src="../Images/e618_09.gif" /></span>; and the result can be improved further, even in the case $m=2$, as in <a href="../Text/ch02c.html#ch02ex_1_5_38">exercise 38</a>.]</p>

  <p class="exercises1"><strong><a href="../Text/ch02c.html#ch02ex_1_5_44" id="ch02ex_1_5_44a">44</a>.</strong> $\lceil{F^{−1}(1/N)}\rceil,\lceil{F^{−1}(2/N)}\rceil,\ldots,\lceil{F^{−1}(N/N)}\rceil$.</p>
</body>
</html>
